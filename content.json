{"meta":{"title":"Nian's Blog","subtitle":"","description":"Blog","author":null,"url":"https://l0s1.github.io","root":"/"},"pages":[{"title":"tags","date":"2022-06-08T09:22:55.000Z","updated":"2022-06-09T02:56:29.687Z","comments":true,"path":"categories/index.html","permalink":"https://l0s1.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-06-08T09:20:01.000Z","updated":"2022-06-09T02:56:45.983Z","comments":true,"path":"tags/index.html","permalink":"https://l0s1.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Wormhole赏金漏洞学习.md","slug":"Wormhole赏金漏洞学习","date":"2022-08-08T10:18:34.000Z","updated":"2022-08-08T10:20:08.917Z","comments":true,"path":"2022/08/08/Wormhole赏金漏洞学习/","link":"","permalink":"https://l0s1.github.io/2022/08/08/Wormhole%E8%B5%8F%E9%87%91%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"简介Wormhole 是一个跨链桥，可以连接到多个链，如 solana、Ethereum、BSC 等。2022年2月24日，名为 satya0x 的白帽子负责任地披露了以太坊上 Wormhole 核心桥接合约的一个严重漏洞，该漏洞和可升级的代理合约有关。Wormhole 向 satya0x 支付了创纪录的 1000 万美元的漏洞赏金（太猛了家人们就是说）。 前置知识 delegatecall 和 call delegatecall 不会修改 msg 中的信息，且会将调用的合约在当前合约中运行（执行环境为当前合约），也就是 storage 使用的当前合约。 call 会修改 msg.sender 为当前合约，但是执行环境在调用的目标合约。 透明代理模式 (TPP) 和通用可升级代理标准 (UUPS) 通过 delegatecall 的特性，我们可以实现可升级的合约。代理合约除了通过 delegatecall 调用实现合约，其本身也会实现一些方法，如 upgradeTo，如果实现合约中存在同名方法，那如何判断到底调哪个合约的方法呢？ 其中透明代理模式（TPP）是一种解决方式，具体做法是当调用者是代理合约的管理员时，调用的是代理合约的方法；当调用者是其他的用户地址时，通过代理合约调用逻辑合约的方法。在该模式中，如果调用者是代理的管理员，则代理合约不会进行任何 delegatecall 调用。 通用可升级代理标准则（UUPS）是一种新的方式，其和透明代理模式的区别在于，透明代理模式的升级逻辑在代理合约中，而 UUPS 则在实现合约中。 漏洞分析Wormhole采用的代理模式为 UUPS，也就是升级逻辑也存在在实现合约中，项目方只通过代理合约调用了 initialize 方法，未在实现合约中调用该方法，而该方法默认所有人都可调用，因此漏洞攻击的路径如下： 攻击者调用 initialize 方法，初始化 initialGuardians 以及 chainId、governanceChainId 、 governanceContract 等参数，其中最重要的参数为 initialGuardians，将其设置为攻击地址。 攻击者部署 destructor 合约，在其 initialize 方法中实现 destructor。 然后调用 submitContractUpgrade 方法，传入的参数为 bytes，其中包含了 timestamp、nonce、chainId、governance.address、destructor.address、attackerSigner.address、guardianSetIndex等。 当校验传入的 vm， 通过以后，会调用 upgradeImplementation 升级合约。该函数中调用 _upgradeTo 方法去升级合约，同时还会通过 delegatecall 调用新的实现合约的 initialize 方法。由于新的实现合约的 initialize 中会进行 destructor 操作，因此该合约会被毁掉，而代理合约没有任何逻辑实现，只靠 delegatecall 调用该合约，因此代理合约会无法使用。 总结Wormhole 采用 UUPS 的代理模式，但未对实现合约进行初始化导致漏洞产生。 在使用 UUPS 代理模式时，需要注意实现合约初始化的问题，防止被黑客调用初始化方法获得管理员权限，从而恶意调用更新方法销毁实现合约，锁定代理合约所有资产。 参考Wormhole Uninitialized Proxy Bugfix Review 跨链桥：Web3黑客必争之地 Transparent vs UUPS Proxies","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Audius攻击事件学习","slug":"Audius攻击事件学习","date":"2022-07-27T13:50:21.000Z","updated":"2022-07-27T13:57:03.658Z","comments":true,"path":"2022/07/27/Audius攻击事件学习/","link":"","permalink":"https://l0s1.github.io/2022/07/27/Audius%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"事件概述Web3 音乐平台 Audius 在 UTC 时间2022年7月23日11点遭到攻击，其社区金库中的1850万枚 AUDIO 代币被盗，黑客在 Uniswap 上将其换成 ETH 后，转入 Tornado 。此次攻击的主要原因是代理合约和实现合约之前存在插槽冲突，导致其 initialize 函数可以被重复调用。 事件分析攻击者EOA地址：0xa0c7BD318D69424603CBf91e9969870F21B8ab4c 攻击合约地址：0xbdbB5945f252bc3466A319CDcC3EE8056bf2e569 攻击交易HASH： 0xfefd829e246002a8fd061eede7501bccb6e244a9aacea0ebceaecef5d877a984 0x3c09c6306b67737227edc24c663462d870e7c2bf39e9ab66877a980c900dd5d5 0x4227bca8ed4b8915c7eec0e14ad3748a88c4371d4176e16e8007249b9980dc9 首先攻击者部署攻击合约 0xbdbB5945f252bc3466A319CDcC3EE8056bf2e569，然后调用攻击合约的 0x5bc7c6ac 方法，交易哈希为 0xfefd829e246002a8fd061eede7501bccb6e244a9aacea0ebceaecef5d877a984，具体的调用的函数如下： 可以看到攻击者首先通过代理合约调用了 Governance 合约的 initialize 函数，进行了一系列初始化设置： 1(_registryAddress = 0xbdbb5945f252bc3466a319cdcc3ee8056bf2e569, _votingPeriod = 3, _executionDelay = 0, _votingQuorumPercent = 1, _maxInProgressProposals = 4, _guardianAddress = 0xbdbb5945f252bc3466a319cdcc3ee8056bf2e569) 在合约中找到 initialize 函数： 发现其存在修饰器 initializer，找到该修饰器： 第一次调用 initialize 时，initialized 以及 initializing 的值都为 false ，因此 require 中的条件满足，函数执行完后，initialized 的值变成了 true，initializing 的值为 false，因此被 initializer 修饰的函数只能够调用一次。 那么攻击者是如何再次调用的呢？大概率是因为代理合约和实现合约之前的存储槽冲突。 首先看代理合约： 该合约继承了 UpgradeabilityProxy 合约，查看该合约以及该合约继承的合约等，发现只有一个 Implementation 变量需要存储，但其插槽位于指定的位置，并非0槽： 然后就是 AudiusAdminUpgradeabilityProxy 合约的 proxyadmin 变量，位于0槽。 再看实现合约： Governance 合约继承 InitializableV2 合约，InitializableV2 合约继承 Initializable 合约： 因此 Governance 插槽0处存在 initialized、initializing、isInitialized 三个布尔变量，后续变量如果小于29字节也会在0槽。 因此两个合约的 storage 布局如下： 由于代理合约中存储实现合约的所有状态变量，因此在0槽会发生冲突： 当代理合约的创建后，构造函数初始化 proxyAdmin，因此 initialized、initializing 会被覆盖，导致其恒为 true，因此 initializer 修饰器失效，可以无限制调用 initialize 函数。 攻击合约调用完 initialize 函数后，调用 evaluateProposalOutcome 函数评估84提案，但并未成功执行该提案。 然后调用 AUDIO 合约的 balanceOf 函数查看代币余额。 接着调用 submitProposal 函数发起新的提案，提案内容为向攻击合约转币，数量为1850万： 123(_targetContractRegistryKey = 3078000000000000000000000000000000000000000000000000000000000000, _callValue = 0, _functionSignature = transfer(address,uint256), _callData = 000000000000000000000000bdbb5945f252bc3466a319cdcc3ee8056bf2e5690000000000000000000000000000000000000000000f5b2f71812d138f71f6f5, _name = Hello, _description = World) 接着调用 Staking 的 initialize 函数，将攻击合约地址设置为 tokenAddress、governanceAddress。 调用 DelegateManagerV2 的 initialize 函数，将攻击合约地址设置为 tokenAddress、governanceAddress。 调用 DelegateManagerV2 的 setServiceProviderFactoryAddress 函数，将攻击合约地址设置为 spFactory。 调用 DelegateManagerV2 的 delegateStake 函数，给攻击合约地址大量投票。 接下来攻击者调用攻击合约的 0xcc66ce79 函数，交易哈希为0x3c09c6306b67737227edc24c663462d870e7c2bf39e9ab66877a980c900dd5d5，相关的调用栈如下： 攻击合约调用 Governance 合约的 submitVote 函数，向85号提案投票。 最后攻击者调用攻击合约的 0x543db4c4 函数，交易哈希为0x4227bca8ed4b8915c7eec0e14ad3748a88c4371d4176e716e8007249b9980dc9，相关调用栈如下： 攻击合约调用 Governance 合约的 evaluateProposalOutcome 函数，评估85号提案，并成功执行，向攻击合约地址转了1850万枚 AUDIO 代币。 至此攻击结束，攻击者将这1850万枚代币在 Uniswap 上换成 ETH，然后转入混币器 Tornado.Cash。 修复建议官方发声明已经修复，查看代码： 发现在 Initializable 合约处新增了三个变量，address private proxyAdmin 以及两个填充变量 uint256 private filler1、uint256 private filler2，这样就不会存在插槽冲突了。同时在修饰器 initializer 中添加了判断条件 msg.sender == proxyAdmin，限定了调用者。 总结代理合约与实现合约的存储槽冲突是导致此次攻击事件的主要原因。个人学习了很久才分析明白，暴露了自己在 storage 方面知识的缺失，后续还需要多学习学习。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Revest Finance攻击事件学习","slug":"Revest-Finance攻击事件学习","date":"2022-07-12T08:39:09.000Z","updated":"2022-07-12T12:16:47.039Z","comments":true,"path":"2022/07/12/Revest-Finance攻击事件学习/","link":"","permalink":"https://l0s1.github.io/2022/07/12/Revest-Finance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"事件概述2022年3月27日，Revest Finance 被攻击，损失大约 2M$(352,835 RENA)，主要的攻击方式为重入攻击。 前置知识Revest Finance 的合约 Revest 提供三种方式进行质押资产，mint 相应的 FNFT： mintTimeLock : 用户质押的数字资产在一段时间之后才能被解锁； mintValueLock : 用户质押的数字资产只有在升值或者贬值到预设数值才能被解锁； mintAddressLock : 用户质押的数字资产只能被预设的账户解锁。 例如 mintAddressLock，用户需要传入参数为：trigger(解锁人)，arguments(可省略)，recipients(接受人)，quantities(FNFT 数量)，FNFTConfig(结构体，包含质押物 asset，每枚 FNFT 对应的质押物数量 depositAmount 以及其他信息)。 同时还提供depositAdditionalToFNFT方法，用于让用户为存在的FNFT质押更多的质押物。传入的参数为：fnftId(存在的 FNFT 的 ID)，amount(每枚 FNFT 对应的质押物数量)，quantity(FNFT 数量)。其中 quantity 可以小于或者等于 mint 的数量，当等于时，合约会 burn 掉之前的 FNFT，并生成新的 FNFT，修改其对应的质押物数量；当小于时，合约会 burn 掉增加质押物数量的 FNFT，生成新的 FNFT，并修改其对应的质押物数量，此时用户存在两种 ID 的 FNFT，一种是原来质押物数量的，一种是增加了质押物数量的。 事件分析攻击交易哈希：0xe0b0c2672b760bef4e2851e91c69c8c0ad135c6987bbf1f43f5846d89e691428 攻击者通过 uniswap 闪电贷获取了2 RENA，然后调用mintAddressLock，铸造 ID 为1027的 FNFT： 其中解锁人以及接受人都是攻击合约，铸造 FNFT 的数量为2，质押物为 RENA，数量为0。 然后攻击者再次调用mintAddressLock，铸造新的 FNFT，其 ID 为1028： 其中解锁人以及接受人都是攻击合约，铸造 FNFT 的数量为360000，质押物为 RENA，数量依然为0。 然后攻击合约在收到此次铸造的 FNFT 后触发 onERC1155Received函数（攻击者通过条件判断让第一次调用onERC1155Received时不执行操作，第二次才执行），该函数调用 Revest 合约中的depositAdditionalToFNFT函数，此时攻击者传入的该函数的参数为：fnftId &#x3D; 1,027, amount &#x3D; 1,000,000,000,000,000,000, quantity &#x3D; 1 因此合约会 burn 掉 一个 ID 为1027，对应质押物为0 RENA 的 FNFT，生成一个 ID 为1028，对应质押物为1 RENA的 FNFT，至于为什么ID还是1028，因为其 handle 合约中的mint 函数这样写的： 123456789function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController &#123; supply[id] += amount; _mint(account, id, amount, data); fnftsCreated += 1; &#125; depositAdditionalToFNFT函数中会调用 vault 合约的handleMultipleDeposits函数更新对应的质押关系： 12345678910111213function handleMultipleDeposits( uint fnftId, uint newFNFTId, uint amount ) external override onlyRevestController &#123; require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;); IRevest.FNFTConfig storage config = fnfts[fnftId]; config.depositAmount = amount; mapFNFTToToken(fnftId, config); if(newFNFTId != 0) &#123; mapFNFTToToken(newFNFTId, config); &#125; &#125; 此时传入的值为：fnftId&#x3D;1027，newFNFTId&#x3D;1028，amount&#x3D;1,000,000,000,000,000,000 因此最后 ID 为1028的 FNFT 对应的质押物被修改为1 RENA。之前攻击者铸造了360000枚 ID 为1028的 FNFT，再加上这新铸造的1枚，对应的质押物也就变成了360001个 RENA。 最后攻击者调用withdrawNFNFT函数，burn 掉 FNFT，提走 RENA，并偿还闪电贷： 额外的漏洞此漏洞为 BlockSec团队发现，位于 vault 合约的handleMultipleDeposits函数： 12345678910111213function handleMultipleDeposits( uint fnftId, uint newFNFTId, uint amount ) external override onlyRevestController &#123; require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;); IRevest.FNFTConfig storage config = fnfts[fnftId]; config.depositAmount = amount; mapFNFTToToken(fnftId, config); if(newFNFTId != 0) &#123; mapFNFTToToken(newFNFTId, config); &#125; &#125; 当想增加已存在的 FNTF 对应的质押物时，用户可以调用depositAdditionalToFNFT函数，正常逻辑是 burn 掉用户传入的数量，生成相应数量的新的 FNFT，并修改新生成的 FNFT 对应的质押关系。但是此处handleMultipleDeposits函数会将所有的 FNFT 的质押关系都修改，也即原来的 FNFT 和新生成的 FNFT 的质押关系都会被修改。我们可以铸造10枚 FNFT，对应质押数量为0 ，ID为1，然后调用depositAdditionalToFNFT，增加其中一枚的 FNFT 对应的质押数量为1，那么执行handleMultipleDeposits函数后，我会有9枚对应质押数量为1、ID 为1的 FNFT，1枚对应质押数量为1，ID 为2的 FNFT，算下来净获利9个币。 修复建议mint以及mintBatchRec函数建议先修改变量状态： 12345678910111213function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController &#123; supply[id] += amount; fnftsCreated += 1; _mint(account, id, amount, data); &#125;function mintBatchRec(address[] calldata recipients, uint[] calldata quantities, uint id, uint newSupply, bytes memory data) external override onlyRevestController &#123; supply[id] += newSupply; fnftsCreated += 1; for(uint i = 0; i &lt; quantities.length; i++) &#123; _mint(recipients[i], id, quantities[i], data); &#125; &#125; handleMultipleDeposits函数在 newFNFTId为0时不修改fnftId对应的config: 1234567891011121314function handleMultipleDeposits( uint fnftId, uint newFNFTId, uint amount) external override onlyRevestController &#123; require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;); IRevest.FNFTConfig memory config = fnfts[fnftId]; config.depositAmount = amount; if(newFNFTId != 0) &#123; mapFNFTToToken(newFNFTId, config); &#125; else &#123; mapFNFTToToken(fnftId, config); &#125;&#125; 总结此次事件攻击者通过 ERC1155 的回调结合mint函数和handleMultipleDeposits的缺陷，成功进行了攻击，攻击技巧比较巧妙，十分牛逼。 参考More than Re-entrancy : Revest Finance 被攻击事件分析 Revest Finance漏洞–NFT的重入攻击？","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"OP代币被盗事件学习","slug":"OP代币被盗事件学习","date":"2022-06-13T10:52:02.000Z","updated":"2022-06-14T03:08:19.438Z","comments":true,"path":"2022/06/13/OP代币被盗事件学习/","link":"","permalink":"https://l0s1.github.io/2022/06/13/OP%E4%BB%A3%E5%B8%81%E8%A2%AB%E7%9B%97%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"事件概述2022年6月9日，Optimism 和加密货币做市商 Wintermute 发布公告，2000万个 OP 代币被黑客盗取。OP 向 Wintermute 提供了2000万代币，委托其提供流动性服务，OP 在向 Wintermute 发送了1 OP 代币和100万 OP 两笔交且 Wintermute 确认无误后，又向其发送了1900万 OP 代币。但在发送完 OP代币后，Wintermute 发现其无法控制这些代币。因为其多签钱包只部署在以太坊主网上，未在 Optimism 网络部署，黑客通过抢先将该多签地址部署在 Optimism 网络上，成功控制代币。 前置知识多签钱包往区块链上发送一笔交易，需要使用钱包做一个签名，签名好后将交易发送出去，交易执行成功转装就成功，这是单签钱包。而多签钱包则是需要多个人去签名执行操作的钱包，使用时需要多个人签名发送交易后，转账操作才完成。多签钱包可以使用 m&#x2F;n 的模式，即 n 个人里有 m 个人签名即可完成操作。 常说的多签主要针对的是比特币和以太坊 ERC-20 标准代币。在比特币中有2种类型的地址，1开头的是 P2PKH，表示个人地址，3开头的是 P2SH，一般表示多签地址。普通的比特币地址是由公钥做哈希后得到的，而多重签名地址基于脚本哈希，所以能够实现复杂的交易逻辑，在原生上比特币就支持多签。而以太坊原生并不支持多签地址，多签钱包在以太坊中往往是一个智能合约。Ownbit 和 Gnosis 代表了当前主流的两种以太坊多签实现方式。其中 Wintermute 使用的 Gnosis 多签钱包。 EIP155 标准EIP155 标准用于防范重放攻击。 当区块高度大于 FORK_BLKNUM (2,675,000) 且 CHAIN_ID 可用时，在计算交易的哈希以进行签名时，不只是对六个 rlp 编码元素（nonce, gasprice, startgas, to, value, data）进行哈希处理，应对9个 rlp 编码元素（nonce, gasprice, startgas, to, value, data, chainid, 0, 0）进行哈希处理，所以签名后的 v 值为：{0,1} + CHAIN_ID * 2 + 35，而如果只对6个元素进行哈希处理，则签名后的 v 值为：{0,1} + 27。 当区块高度大于 FORK_BLKNUM (2,675,000) 且 v 值等于 CHAIN_ID * 2 + 35 或者 CHAIN_ID * 2 + 36 时，在计算交易的哈希以进行签名时，不只是对六个 rlp 编码元素进行哈希处理，应对9个 rlp 编码元素（nonce, gasprice, startgas, to, value, data, chainid, 0, 0）进行哈希处理。当前存在的使用 v 值等于27或者28签名方案保持有效，并继续在与以前相同的规则下运行。 简单点说的就是不加 CHAIN_ID 的签名后的 v 值在27-28之间，交易可以在不同的链上进行重放。 合约地址生成方式智能合约生成合约地址有两种方式，分别是 CREATE 指令和 CREATE2 指令，其中使用 CREATE 指令创建的合约地址可以使用keccak256(rlp.encode(deployingAddress, nonce))[12:]计算出来，其中 nonce的值每发送一笔交易或者创建一个合约就会 +1。 使用 CREATE2 指令创建的合约的地址使用keccak256(0xff ++ deployingAddr ++ salt ++ keccak256(init_code))[12:]计算，其中 init_code 是被部署合约的字节码。 事件分析首先是 Optimism 向 Wintermute 的多签钱包地址发送 OP 代币： 由于此时 Wintermute 的多签钱包只在以太坊主网上部署，未在 Optimism 网络上部署，因此其对2000万 OP 代币无控制权。 黑客此时抢先将该多签钱包地址部署到 Optimism 网络上。 黑客攻击地址为：0x60b28637879b5a09d21b68040020ffbf7dba5107 其首先分别向两个地址 0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A、0x8BcFe4f1358E50A1db10025D731C8b3b17f04DBB转账0.2 eth、0.5 eth： 其中 0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A 用来部署 Gnosis Safe 的 ProxyFactory 合约： 0x8BcFe4f1358E50A1db10025D731C8b3b17f04DBB 则用来部署 0xe7145dd6287ae53326347f3a6694fcf2954bcd8a 合约，该合约用于多次调用 ProxyFactory 中的 createProxy函数： 由于生成多签钱包地址的是 Gnosis Safe 的 ProxyFactory 合约，因此找到创建该合约的记录。 首先在 etherscan 搜索多签钱包地址0x4f3a120e72c76c22ae802d129f599bfdbc31cb81，然后找到其创建的记录： 然后找到 Gnosis Safe 的 ProxyFactory 合约的创建记录： 然后查看此时 v 值，不知道在 etherscan 如何查看，学习慢雾的方法，注册了一个 infura.io 账号，使用该命令查看详情：curl -s -H &#39;content-type:application/json&#39; -d &#39;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getTransactionByHash&quot;,&quot;params&quot;:[&quot;0x75a42f240d229518979199f56cd7c82e4fc1f1a20ad9a4864c635354b4a34261&quot;],&quot;id&quot;:1&#125;&#39; https://mainnet.infura.io/v3/xxxx 可以看到此时的 v 值为 0x1c，换算为十进制为28，因此该 v 值不符合 EIP155标准，不带 CHAIN_ID，可以在其他链进行重放攻击，以得到相同地址的合约，攻击者在 Optimism 网络重放，得到地址与在以太坊主网相同的 ProxyFactory 合约： 然后再看 Gnosis Safe 的 ProxyFactory 合约的源代码： 12345678910111213141516171819202122contract ProxyFactory &#123; event ProxyCreation(Proxy proxy); /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction. /// @param masterCopy Address of master copy. /// @param data Payload for message call sent to new proxy contract. function createProxy(address masterCopy, bytes memory data) public returns (Proxy proxy) &#123; proxy = new Proxy(masterCopy); if (data.length &gt; 0) // solium-disable-next-line security/no-inline-assembly assembly &#123; if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) &#123; revert(0, 0) &#125; &#125; emit ProxyCreation(proxy); &#125; //省略其他代码 N 行&#125; 这里可以看到新建合约地址使用的new Proxy(masterCopy)，即使用的 CREATE 指令进行创建，合约地址是 msg.sender 以及 nonce 来计算的，由于此时工厂合约地址已经和以太坊主网相同，只需要 nonce 和在以太坊主网上生成多签钱包地址的 nonce 相同，则可完成部署，攻击者通过调用合约 0xe7145dd6287ae53326347f3a6694fcf2954bcd8a 来实现，该合约内部则多次调用 ProxyFactory 合约的createProxy函数，来增加 nonce 值达到该目的： 最后成功将该多签钱包地址部署在 Optimism网络： 总结引发此次安全事件的原因：一是 Wintermute 未验证在侧链是否对其多签钱包地址具有控制权；二是 Solidity 旧版本的漏洞导致使用 CREATE 指令来创建合约地址；三是交易签名未带 CHAIN_ID，不符合 EIP155 标准导致交易可在其他链重放。 参考 2000 万 OP 代币被盗关键：交易重放 重入攻击 + 管理漏洞：2000 万枚 OP 被盗事件分析 交易重放+管理漏洞—2000万枚OP被盗事件分析 2000万OP因何被盗? 来看看链上细节 EIP-155: Simple replay attack protection 深入剖析 Ownbit 和 Gnosis 多签 多签钱包的工作原理与使用方式 CREATE2指令在广义状态通道中的应用介绍","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"闪电贷攻击学习","slug":"闪电贷攻击学习","date":"2022-06-09T08:41:17.000Z","updated":"2022-06-13T06:33:21.193Z","comments":true,"path":"2022/06/09/闪电贷攻击学习/","link":"","permalink":"https://l0s1.github.io/2022/06/09/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"什么是闪电贷闪电贷最早是由 Marble 协议引入的概念，当时是为了让用户可以在以太坊借用 Ether 和 ERC-20 代币，后来由 Aave、dYdX 等进行了普及。 简单来说，闪电贷就是在一个区块交易中，同时完成借款和还款操作这两个操作，无需抵押任何资产，只需支付手续费即可。因为要求借款和还款操作都在一个区块中完成（以太坊平均每个区块时间大概是14秒，币安智能链每个区块时间大约3秒），所以时间非常短，普通人难以操作，一般是专业人员（科学家）使用。 用户在借到款之后，可以利用借到的资产进行其他操作，然后在交易结束的时候，用户只要把借到的款项及手续费及时归还就可以，否则该笔交易就会回滚，就像什么也没有发生过一样。 闪电贷的作用闪电贷作用大致有以下： 套利。比如在两个不同DEX（中心化交易平台）之间ETH价格是有差异的，在A平台 ETH: DAI&#x3D;1: 2700，在B平台上1：2750，那么，这个时候可以去AAVE里面借入2700DAI，在A平台买入1个ETH，在B平台以2750的价格卖出ETH，然后还掉2700DAI，净赚50DAI。 自我清算。比如你在去中心化平台抵押的一笔ETH即将到达清算点，在清算之后你要付一大笔清算费（一般是5-8%左右），这个时候你可以借一笔闪电贷，归还所贷资产，然后将平台抵押的ETH取出，用ETH换成相应的DAI或其他资产归还闪电贷，此时只需要付0.09%的闪电贷手续费而已（AAVE平台闪电贷手续费0.09%，每个平台手续费不一样）。 更换抵押物。比如你在借代平台上抵押的是ETH，你想把抵押物换成USDC，这个时候你可以用闪电贷借一笔DAI，用DAI换成USDC，然后抵押进去，随后将ETH取出，换成DAI，归还闪电贷所借DAI即可。 迁移资产或债务。比如我在A平台上面有抵押ETH借出BNB，这个时候我感觉A平台有一些风险，所以想把整个借代迁移到B平台上，我可以在AAVE用闪电贷借一笔DAI，把DAI换成BNB，在A平台归还之后取出ETH，然后将ETH抵押到B平台借出相同数量的BNB，然后将BNB换成DAI归还闪电贷，在不挪动原来借出来的BNB的基础上完成了不同平台资产和债务的转移。 当然还存在更多的应用场景。 闪电贷项目主流的几个闪电贷项目，主要为Aave，Uniswap，dYdX。 Aave。Aave 是一个去中心化的非托管流动性市场协议，用户可以作为存款人或借款人参与其中。存款人向市场提供流动性以赚取被动收入，而借款人能够以超额抵押（永久）或抵押不足（单块流动性）的方式借款。 其中Aave V3 为闪电贷提供了两种选择： flahsLoan。允许借款人在单次闪贷交易中获得多个准备金的流动性。 flahsLoanSimple。允许借款人为交易获取单一准备金的流动性。 ​ 流程大概为实现 IFlashLoanSimpleReceiver.sol 或者 IFlashLoanReceiver.sol 中的 executeOperation 函数，该函数用来利用闪电贷，然后再调用flahsLoan函数或者 flahsLoanSimple 函数，传入相应的参数即可。executeOperation函数在flashLoan函数成功执行后被内部调用。其中Aave的手续费用为0.09%。 Uniswap。Uniswap 作为 DeFi 中最受欢迎的去中心化交易所之一，从V2版本开始支持闪电贷（Flash Swaps）功能，该功能通过调用UniswapV2pair 合约实例的 swap 方法带入额外 data 实现。手续费为0.3%。 dYdX。dYdX 是一个针对专业交易者的去中心化交易所，本身并没有闪电贷功能，但是可以通过对 SoloMargin 合约执行一系列操作来实现类似闪电贷功能。其主要原理是通过继承 DydxFlashloanBase 合约编写initiateFlashLoan 回调 callFunction 实现借贷、套利、还款等操作。手续费 2 Wei。 闪电贷攻击闪电贷本身的存在是没有漏洞的，但闪电贷可以在短时间内获取到大量资金，黑客将闪电贷和其他漏洞进行结合，进行价格操控、套利。其中其他漏洞一般是合约逻辑存在问题导致黑客可以进行价格操控，或者是存在重入漏洞。以下是学习的闪电贷攻击实例。 Grim Finance 被黑事件问题出在Grim Finance vault 的depositFor函数上： 123456789101112131415function depositFor(address token, uint _amount,address user ) public &#123; uint256 _pool = balance(); IERC20(token).safeTransferFrom(msg.sender, address(this), _amount); earn(); uint256 _after = balance(); _amount = _after.sub(_pool); // Additional check for deflationary tokens uint256 shares = 0; if (totalSupply() == 0) &#123; shares = _amount; &#125; else &#123; shares = (_amount.mul(totalSupply())).div(_pool); &#125; _mint(user, shares); &#125; 其中由用户传入的token参数未做过滤，导致第四行调用的safeTransferFrom函数可被用户控制，攻击者传入自己的部署的恶意合约的地址，并在恶意合约的safeTransferFrom函数中调用depositFor，以此造成重入攻击。 其中在调用safeTransferFrom前计算了一次balance，在调用后又计算了一次balance，其差值amount为用户传入的代币数，那么攻击者只需要在最后一次重入的时候传入真实代币，当最后一次重入完成，after变成了充值后的余额，那么前面重入的amount也将改变，攻击者实现了充值一次当充值N次的目的。 大概的攻击合约伪代码如下： 1234567891011contract Attack &#123; uint times = 0; function safeTransferFrom(address token, uint _amount,address user) public &#123; if(times &lt; 4)&#123; times ++; GrimBoostVault.depositFor(address(this), 0, attackaddress); &#125; else&#123; GrimBoostVault.depositFor(SLPToken, 200, attackaddress); &#125; &#125;&#125; Wault Finance 被黑事件问题出在WUSDMaster合约中的staking函数： 123456789101112131415161718192021function stake(uint256 amount) external nonReentrant &#123; require(amount &lt;= maxStakeAmount, &#x27;amount too high&#x27;); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille &gt; 0) &#123; uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; &#125; uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, 0, swapPath, address(this), block.timestamp ); wusd.mint(msg.sender, amount); emit Stake(msg.sender, amount); &#125; 该质押函数一比一质押USDT获得WUSD，同时还会进行swap操作，调用wswapRouter的swapExactTokensForTokensSupportingFeeOnTransferTokens，将质押一部分的 USDT 换成 WEX，这样就会使得 WaultSwapPair (BSC_USDT-WEX) 池子的 WEX 数量减少，价值变高，在多次调用stake函数后，WEX价格上涨，攻击者再将之前通过redeem和利用USDT兑换的WEX在USDT-WEX池中卖出，换取更多的WEX，完成套利。 防御1、合理设计经济模型。 2、使用去中心化预言机获取价格。 3、对关键函数建立完备的访问控制机制。 参考 科普 | 无抵押借巨资的闪电贷是什么？缘何频频成为DeFi暴雷帮凶？ 揭开闪电贷的神秘面纱 Flash Loans 这波很 “严峻” – Grim Finance 被黑细节分析 外部调用的不可控因素之 Grim Finance 被黑分析 又一经典的闪电贷套利 —— Wault.Finance 被黑事件分析","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"闪电贷","slug":"闪电贷","permalink":"https://l0s1.github.io/tags/%E9%97%AA%E7%94%B5%E8%B4%B7/"}]}],"categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"},{"name":"闪电贷","slug":"闪电贷","permalink":"https://l0s1.github.io/tags/%E9%97%AA%E7%94%B5%E8%B4%B7/"}]}