{"meta":{"title":"Nian's Blog","subtitle":"","description":"Blog","author":null,"url":"https://l0s1.github.io","root":"/"},"pages":[{"title":"tags","date":"2022-06-08T09:22:55.000Z","updated":"2022-06-09T02:56:29.687Z","comments":true,"path":"categories/index.html","permalink":"https://l0s1.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-06-08T09:20:01.000Z","updated":"2022-06-09T02:56:45.983Z","comments":true,"path":"tags/index.html","permalink":"https://l0s1.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Reentrancy","slug":"Reentrancy","date":"2023-02-03T05:49:23.000Z","updated":"2023-02-07T07:06:00.506Z","comments":true,"path":"2023/02/03/Reentrancy/","link":"","permalink":"https://l0s1.github.io/2023/02/03/Reentrancy/","excerpt":"","text":"重入漏洞是智能合约中最常见的漏洞，也是危害最大的漏洞。每年因为链上发生的重入攻击，损失了大量的资金。 重入漏洞的本质我认为的重入的本质：状态变量的改变后于外部恶意调用。 重入点Solidity 智能合约中存入重入点的地方很多，但并不是存在重入点就存在重入漏洞。常见的一些重入点： 使用 call 发送 Ether； ERC721 中的 _checkOnERC721Received() ; ERC1155 中的 _doSafeTransferAcceptanceCheck() ; ERC677中的 transferAndCall() ; ERC777 中的 _callTokensToSend(), _callTokensReceived() ; 重入类型重入类型一般有下面三种： 单 函数重入：重入发生在一个合约的一个函数 ; 多函数重入：重入发生了一个合约的多个函数 ; 多合约重入：重入发生在多个合约 ; 单函数重入这种重入是最简单的重入，一个简单的例子如下： 123456789101112contract ReentrancyA &#123; mapping(address =&gt; uint) public balances; function withdraw(uint256 _amount) external &#123; require(_amount &lt;= balances[msg.sender]); (bool success, ) = payable(msg.sender).call&#123;value: _amount&#125;(&quot;&quot;); require(success); balances[msg.sender] -= _amount; &#125; &#125; withdraw 函数中 balances 的改变在外部调用之后，因此可以编写攻击合约调用受害合约的 withdraw 函数，然后受害合约向攻击合约发送 Ether ，会触发攻击合约的 fallback 函数，攻击合约在 fallback 函数中继续调用受害合约的 withdraw 函数，因为 balances 一直未修改，因此函数第一行的余额校验会一直通过，最后重复以上步骤直到受害合约内的 Ether 被全部提取。 多函数重入这里的多函数重入指一个合约内的函数。多函数重入发生的情况一般是合约存在可被攻击者控制的函数(状态变量)，而其他函数会使用该函数中的状态变量，这种情况下会存在多函数的重入。 一个简单的例子如下： 12345678910111213141516contract ReentrancyB is ERC721 &#123; mapping (address =&gt; bool) whiteList; uint256 tokenId; function mint() public &#123; require(whiteList[msg.sender] = true); tokenId++; _safeMint(msg.sender, tokenid); whiteList[msg.sender] = false; &#125; function claim() public &#123; uint256 count = balanceOf(msg.sender); payable(msg.sender).call&#123;value: count * Ether&#125;(&quot;&quot;); &#125;&#125; 多合约重入多合约重入一般是一个合约中的某个函数(状态变量)可被攻击者控制，而其他的合约会使用该函数中的影响的状态变量，这种情况下会存在多合约重入。 一个简单的例子如下： 123456789101112131415161718192021222324252627282930contract A &#123; mapping (address =&gt; uint256) balancesA; uint256 totalSupply; funtion claim(uint256 _amount) lock &#123; require(balancesA[msg.sender] &gt;= _amount); balancesA[msg.sender] -= _amount; payalbe(msg.sender).call&#123;value: _amount&#125;(&quot;&quot;); totalSupply -= _amount; &#125; function lastPrice() external view returns (uint256)&#123; return totalSupply / address(this).balance; &#125;contract B &#123; mapping (address =&gt; uint256) balancesB; A a; funtion withdraw(uint256 _amount) external &#123; require(balancesB[msg.sender] &gt;= _amount); balancesB[msg.sender] -= _amount; uint256 price = a.lastPrice(); uint256 amount = _amount * price; payable(msg.sender).call&#123;value: amount&#125;(&quot;&quot;); &#125;&#125; 案例 - Curve Read-Only Reentrancy2022年10月，ChainSecurity 团队在 DevCon 上披露了 Curve 中存在的一种新型的重入漏洞：只读重入漏洞。攻击者可以通过该漏洞操控虚拟价格，为恶意套利创造条件。 首先 Curve 中存在一个函数用来获取虚拟价格： 12345@external@viewdef get_virtual_price() -&gt; uint256: return 10**18 * self.get_xcp(self.D) / CurveToken(self.token).totalSupply() 其中 D 是所有基础资产的余额，虚拟价格由 D 除以 LP 代币的总发行量来得到。当 D 和 totalSupply 的值同步不及时的时候会发生虚拟价格失真的情况。其中一种发生在合约的 remove_liquidity 函数中： 123456789101112131415161718192021222324252627282930313233343536@external@nonreentrant(&#x27;lock&#x27;)def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS], use_eth: bool = False, receiver: address = msg.sender): &quot;&quot;&quot; This withdrawal method is very safe, does no complex math &quot;&quot;&quot; lp_token: address = self.token total_supply: uint256 = CurveToken(lp_token).totalSupply() CurveToken(lp_token).burnFrom(msg.sender, _amount) balances: uint256[N_COINS] = self.balances amount: uint256 = _amount - 1 # Make rounding errors favoring other LPs a tiny bit for i in range(N_COINS): d_balance: uint256 = balances[i] * amount / total_supply assert d_balance &gt;= min_amounts[i] self.balances[i] = balances[i] - d_balance balances[i] = d_balance # now it&#x27;s the amounts going out coin: address = self.coins[i] if use_eth and coin == WETH20: raw_call(receiver, b&quot;&quot;, value=d_balance) else: if coin == WETH20: WETH(WETH20).deposit(value=d_balance) response: Bytes[32] = raw_call( coin, _abi_encode(receiver, d_balance, method_id=method_id(&quot;transfer(address,uint256)&quot;)), max_outsize=32, ) if len(response) != 0: assert convert(response, bool) D: uint256 = self.D self.D = D - D * amount / total_supply log RemoveLiquidity(msg.sender, balances, total_supply - _amount) 可以看到移除流动性函数首先会燃烧掉传入数量的 LP 代币(#10)，此时 LP 代币的总供应量减少，然后判断 use_eth 标识以及代币类型，然后将以太转给接收者，最后修改 D 的值。 如果接收者是智能合约，则会触发其 fallback 函数，如果此时在该函数中调用 get_virtual_price 函数，则会发现此时的虚拟价格会上升，因为 LP 代币的总量变小了，但是 D 的值此时还未修改。如果添加大量的流动性，再移除大量流动性，触发 fallback ，则此时的虚拟价格会剧烈飙升。而在本合约中关键函数都添加了重入锁无法利用，但有其他的项目引入了 Curve，并使用了 get_virtual_price 函数，导致其项目遭到了黑客的攻击。 其中一个例子是 Market.xyz。 攻击者使用闪电贷借出大量 WMATIC : 然后在回调函数中先添加流动性： 然后再移除流动性，并在攻击合约的 fallback 函数中调用 Market 池子的 borrwo 函数进行借贷，借出大量的包装代币： 其取价函数中调用了 Curve 的 get_virtual_price 函数： 解决 编写合约代码遵循“CEI”模式； 针对 Read-Only Reentrancy，可以在 关键的 view 函数也加上重入锁，或者将锁的状态公开，使得外部合约也能够获取到锁的状态。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://l0s1.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"可升级合约","slug":"可升级合约","date":"2023-02-02T08:38:35.000Z","updated":"2023-02-02T08:46:08.708Z","comments":true,"path":"2023/02/02/可升级合约/","link":"","permalink":"https://l0s1.github.io/2023/02/02/%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6/","excerpt":"","text":"在以太坊上，合约部署后是无法修改其代码的。如果部署后发现代码有漏洞，或者想更新版本，想直接修改部署好的合约是不可能的。好在有一个操作码 delegatecall，借助这个操作码，我们可以曲线救国，实现可升级合约这一方案。下面我们讲述一下可升级合约的几种模式以及在使用可升级合约时的注意事项。 Delegatecalldelegatecall 操作码用于外部调用其他合约的方法，但是执行环境是在当前合约当中，调用者不会发生变化，且状态变量是存储在当前合约当中。因此我们可以利用这种特性，设计出最简单的可升级合约，即一个代理合约，实现了升级逻辑以及在 fallback 方法中实现 delegatecall 调用逻辑，一个逻辑合约，实现真正的项目的逻辑。 Transparent Proxies上述实现了一个最为简单的可升级合约，但其实我们可以发现它存在了一些问题。第一个问题是 选择器冲突，即我们在 proxy 合约会实现升级相关的逻辑，我们在 logic 合约会实现项目逻辑，当两者都实现了一个相同声明的函数，则会发生选择器冲突，当然不同也可能会发生冲突，只是概率较小。发生冲突时我们只能够调用 proxy 合约实现的函数，而无法调用 logic 合约实现的函数。第二个问题是 插槽冲突，在 proxy 合约中存在升级逻辑，很明显这些升级相关的函数只能够由管理员来调用，因此 proxy 合约中需要有两个存储槽，一个用来存储管理员地址，一个用来存储 logic 合约地址，如果这些存储槽位置处理不当，则会和 logic 合约产生冲突，覆盖掉 logic 合约相同存储槽的状态变量，导致合约出现意料之外的情况。为了解决选择器冲突这个问题，设计出了 Transparent proxies 模式，即透明代理模式。透明代理模式 会区分 proxy 合约特权账户和普通用户，在升级相关的逻辑处会判断是否为特权账户，是的话则调用 proxy 合约的升级逻辑，否则进入到 fallback 函数中；而在 fallback 函数中则会校验调用者是否为普通用户，是的话继续逻辑，否则会被 revert。也即该模式针对合约升级账户和普通用户进行了区分，解决了选择器冲突这个问题。 123456789101112131415161718192021modifier ifAdmin() &#123; if (msg.sender == _getAdmin()) &#123; _; &#125; else &#123; _fallback(); &#125; &#125; function changeAdmin(address newAdmin) external virtual ifAdmin &#123; _changeAdmin(newAdmin); &#125; function upgradeTo(address newImplementation) external ifAdmin &#123; _upgradeToAndCall(newImplementation, bytes(&quot;&quot;), false); &#125; function _beforeFallback() internal virtual override &#123; require(msg.sender != _getAdmin(), &quot;TransparentUpgradeableProxy: admin cannot fallback to proxy target&quot;); super._beforeFallback(); &#125; 而针对插槽冲突这个问题，在 OpenZeppelin 实现的透明代理合约中，通过使用 非结构化存储 来解决这个问题。即 proxy 合约中的状态变量存储在特定位置的槽中，类似于 mapping，而不是存储在第零槽或者第一槽这种顺序存储，这样就不会跟 logic 合约的状态变量冲突。 1234567891011121314151617181920212223/*** @dev Storage slot with the address of the current implementation.* This is the keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1, and is* validated in the constructor.*/bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;/*** @dev Storage slot with the admin of the contract.* This is the keccak-256 hash of &quot;eip1967.proxy.admin&quot; subtracted by 1, and is* validated in the constructor.*/bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103; Universal Upgradeable Proxies透明代理模式虽然解决了选择器冲突这一问题，但是缺点也非常明显，那就是每次调用都会去判断调用者的身份，会增加 gas 的消耗。另外一种常见的可升级合约的模式为 Universal upgradeable proxies，即通用可升级代理模式。通用可升级代理模式 与透明代理模式最大的区别在于合约升级的逻辑在逻辑合约中而不是在代理合约中，即 proxy 合约唯一的作用就是简单的通过 delegatecall 调用 logic 合约。因此使用 UUPS 模式的合约不会存在选择器冲突这个问题。 但 UUPS 模式也有其缺点。升级相关的逻辑在逻辑合约中，容易和功能逻辑混淆，权限分配上容易混乱。如果逻辑合约如果忘记初始化容易出现被恶意利用的问题。与 TPPS 模式相比，UUPS 模式的使用更具有挑战性。 Beacon Pattern Proxies有时候我们会遇到需要通过工厂合约部署很多相同合约的情况，如果这些合约也使用可升级合约，那么或许使用 Beacon pattern proxies 是一个好的方案。信标代理模式 满足了多个代理合约都使用一个相同的逻辑合约的场景。它在架构上比 TPPS 模式多出了一个 Beacon 合约，该合约存储了逻辑合约的地址，以及修改改地址的函数。然后代理合约每次需要从 Beacon 合约中取出逻辑合约的地址，然后对该地址进行 delegatecall 调用。 信标代理模式和透明代理模式相比，其不存在插槽冲突的问题。因为 Proxy 合约中无需存储 Logic 合约的地址，也不需要编写升级的逻辑，Proxy 合约只需要保存 Beacon 合约的地址，该地址不会变化，因此地址变量可以通过 immutable 修饰，并在初始化时赋值，不占用存储槽。当需要升级时只需要在 Beacon 合约中修改 Logic 合约的地址，即可实现多个代理合约同时升级。一个简单的信标代理模式的可升级合约的例子： 1234567891011121314151617contract Proxy &#123; address immutable beacon; fallback() external payable &#123; address implementation = beacon.implementation(); return implementation.delegatecall.value(msg.value)(msg.data); &#125;&#125;contract Beacon is Ownable &#123; address public implementation; function upgrade(address newImplementation) public onlyOwner &#123; implementation = newImplementation; &#125;&#125; Diamonds, Multi-Facet Proxy既然存在多个代理合约对一个逻辑合约的情况，那么也会存在一个代理合约对多个逻辑合约的情况。钻石标准 则可用于一个代理合约对多个逻辑合约的场景。当业务逻辑复杂的时候，代码的大小可能会超出以太坊规定的合约最大的限制(24K)，这个时候钻石标准可以解决这个问题。钻石标准将逻辑合约分为不同的切面，每一个或多个功能为一个切面，这样一个复杂的大小超过限制的逻辑合约被分成了很多个小的切面合约。例如可以将一个复杂的 Defi 分成预言机切面、权限切面、721切面等。其实现原理就是在代理合约中添加一个 mapping，由函数签名指向切面地址，这样每次调用 fallback 函数时都会根据传入的签名去寻找到切面的地址，然后执行对应的函数。 钻石标准需要实现相应的对切面进行修改的函数，也即所谓的升级逻辑，当需要升级时，只需要修改对应的 mapping 中的值就行。 由于所有的切面合约的数据都保存在 proxy 合约当中，因此对存储槽的分配十分重要。提案发起人提出了三种方案来解决插槽冲突，一种是利用非结构化存储，将切面的数据放在一个结构体中，然后将结构体存储在特定的插槽中；第二种是继承，即 proxy 和 logic 都继承相同的合约来达到存储槽一致；第三种方案是将结构体使用 internal 修饰，没太理解这样为什么没有冲突。 一般的中小型的项目不大可能用上钻石标准，切钻石标准真正实现起来较为复杂，尤其是对于数据的存储，如何保证不会存在插槽冲突，又如何去判定不同的切面中的变量是否需要共享，需要将业务切割成多少个切面，等等这些问题都使得钻石标准的实现难度大大增加。 注意事项 编写可升级合约虽然看起来十分简单，但是也需要注意以下几点，避免出现漏洞。 插槽冲突 可升级合约中最常见的漏洞。如果使用开源的库，如 OpenZeppelin，务必谨慎添加状态变量。自己编写的话更要警惕。使用非结构化存储可以很好地解决该问题。 选择器冲突 这个问题一般很少遇到，如果使用 OpenZeppelin 的透明代理或者通用代理不会存在该问题。如果是自己编写部署前检查一下函数的签名。 初始化问题 可升级合约中逻辑合约无法使用构造函数进行初始化，因此逻辑合约需要编写一个初始化函数来进行初始化变量，且需要添加上相应的修饰器保证该函数只能够被调用一次。 升级账户私钥丢失 这是很多项目被攻击的原因，因为管理不当或者操作失误，导致了管理升级的特权账户私钥丢失了，攻击者直接将合约升级成恶意的合约，盗走资产。建议安全保管升级账户私钥，同时建议升级账户使用多签钱包方案。 UUPS 模式逻辑合约未初始化 在 UUPS 模式中，升级的逻辑在逻辑合约中，因此带有 upgradeAndCall 这样的方法，往往需要特权账户才能够调用，但是很多项目方只是调用初始化方法初始化了代理合约，而没有初始化逻辑合约，攻击者调用逻辑合约的初始化方法，将自己变成逻辑合约的特权账户，然后调用 upgradeAndCall 方法，将逻辑合约升级并且调用恶意合约的方法，一般是进行 selfdestruct，这样逻辑合约就会被销毁。代理合约只是存储了逻辑合约的地址，而无法修改，所以相当于没办法进行任何操作，资金会全部锁死在代理合约中。 使用 OpenZeppelin 的 UUPS 合约不会存在该问题，因为其升级逻辑限定了只能由 Proxy 合约进行调用。 继承问题 由于可升级合约无法使用构造函数进行初始化，所以继承的也不能是通过构造函数初始化的合约，需要添加初始化函数，或者继承可升级的版本。如 OpenZeppelin 中 使用可升级合约就需要继承其 contract-upgrade 里面的合约。 权限控制不当 项目方如果没有做好权限分配，将升级特权账户和业务特权账户混淆，容易出现问题。如果是透明代理则无法调用业务的特权函数。在 UUPS 模式中更加容易混淆权限，因为升级逻辑和业务逻辑都在逻辑合约中，建议区分两种权限。 第二种是合约编写时未做升级权限控制。如 Openzeppelin 的 UUPS 模式默认是任何人都可以去升级，我们需要去重写其 _authorizeUpgrade 函数，添加鉴权模块，使用时这一点很容易忘记。 升级合约随意修改状态变量 升级合约时添加了新的业务逻辑，这个时候需要添加或者修改之前的变量，一个稳妥的做法是在原来的状态变量后顺序新增，而不是插入或者删除原来的状态变量。粗暴的修改之前的状态变量可能会造成插槽冲突、覆盖，业务逻辑将会被破坏。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://l0s1.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"The Analysis of GDS Token Attack","slug":"The-Analysis-of-GDS-Token-Attack","date":"2023-01-04T08:29:47.000Z","updated":"2023-01-05T10:20:35.841Z","comments":true,"path":"2023/01/04/The-Analysis-of-GDS-Token-Attack/","link":"","permalink":"https://l0s1.github.io/2023/01/04/The-Analysis-of-GDS-Token-Attack/","excerpt":"","text":"Event OverviewThe $GDS was attacked at 12:21 UTC on January 3, 2023, and the loss is about 180K USDT. The root cause is a flaw in the liquidity reward logic. Attacker adds liquidity through flashloans, and then collects rewards through multiple contracts. Attack AnalysisThis is the transaction hash of the attack： https://bscscan.com/tx/0x2bb704e0d158594f7373ec6e53dc9da6c6639f269207da8dab883fc3b5bf6694 First, attacker lent a large amount of USDT through two flashloans: Then he swapped 600k USDT to $GDS, and added liquidity to PancakeSwap pool: He transferred LP token to a new attack contract, and then called its withdraw function. This function called GDS.transfer function to transfer $GDS to dead address, next attack contract received reward and swapped all $GDS to USDT on PancakeSwap: The attacker then repeated the operations so many times: At the end of arbitrage operation, the attacker removed the liquidity and repaid the flashloans, and transferred USDT from attack contract to attack’s EOA： Through the above operations, the attacker made a profit of 39K USDT and 10M $GDS. Vulnerability AnalysisThrough the above attack analysis, we can find that the anomaly is located in the transfer to the dead address, so let’s find the transfer function: 12345function transfer(address to, uint256 amount) public virtual override returns (bool) &#123; address owner = _msgSender(); _transfer(owner, to, amount); return true; &#125; Okay, let’s see the internal funciton _transfer: 123456789101112131415161718192021222324252627282930313233343536function _transfer( address from, address to, uint256 amount ) internal virtual &#123; require(from != address(0), &quot;ERC20: transfer from the zero address&quot;); require(to != address(0), &quot;ERC20: transfer to the zero address&quot;); require(amount &gt;0, &quot;ERC20: transfer to the zero amount&quot;); _beforeTokenTransfer(from, to, amount); //indicates if fee should be deducted from transfer bool _takeFee = takeFee; //if any account belongs to isExcludedTxFee account then remove the fee if (isExcludedTxFee[from] || isExcludedTxFee[to]) &#123; _takeFee = false; &#125; if(_takeFee)&#123; if(to == dead)&#123; _transferStandard(from, to, amount); &#125;else&#123; if(uniswapV2Pairs[from] || uniswapV2Pairs[to])&#123; _transferFee(from, to, amount); &#125;else &#123; _destoryTransfer(from,to,amount); &#125; &#125; &#125;else&#123; _transferStandard(from, to, amount); &#125; _afterTokenTransfer(from, to, amount); &#125; In this function, we should check the implementation of the _beforeTokenTransfer、 _transferStandard、 _afterTokenTransfer. Finally find that the exception is located in _afterTokenTransfer: 12345678function _afterTokenTransfer( address from, address to, uint256 amount ) internal virtual &#123; _refreshDestroyMiningAccount(from,to,amount); _activateAccount(from,to,amount); &#125; Continue to follow up the _refreshDestroyMiningAccount: 12345678910111213141516171819function _refreshDestroyMiningAccount(address _from,address _to,uint256 _amount)internal &#123; if(_to == dead)&#123; _settlementDestoryMining(_from); if(isOpenLpMining)&#123; _settlementLpMining(_from); &#125; destroyMiningAccounts[_from] += _amount; if(lastBlock[_from] == 0)&#123; lastBlock[_from] = block.number; &#125; &#125; if(uniswapV2Pairs[_from] || uniswapV2Pairs[_to])&#123; if(isOpenLpMining)&#123; _settlementLpMining(_from); &#125; &#125; &#125; When destination address is dead address, and the isOpenLpMining is true, function will enter the logic of _settlementLpMining: 123456789101112131415161718192021222324function _settlementLpMining(address _from)internal &#123; uint256 _lpTokenBalance = IERC20(gdsUsdtPair).balanceOf(_from); uint256 _lpTokenTotalSupply = IERC20(gdsUsdtPair).totalSupply(); if(lastEpoch[_from] &gt;0 &amp;&amp; currentEpoch &gt; lastEpoch[_from] &amp;&amp; _lpTokenBalance&gt;0)&#123; uint256 _totalRewardAmount= 0; for (uint i = lastEpoch[_from]; i &lt; currentEpoch; i++) &#123; _totalRewardAmount += everyEpochLpReward[i]; _totalRewardAmount += everyDayLpMiningAmount; &#125; uint256 _lpRewardAmount = _totalRewardAmount*_lpTokenBalance/_lpTokenTotalSupply; _internalTransfer(lpPoolContract,_from,_lpRewardAmount,4); lastEpoch[_from] = currentEpoch; &#125; if(lastEpoch[_from] == 0 &amp;&amp; _lpTokenBalance &gt;0)&#123; lastEpoch[_from] = currentEpoch; &#125; if(_lpTokenBalance == 0)&#123; lastEpoch[_from] = 0; &#125; &#125; We can find this function will transfer $GDS from lpPoolContract to caller. The amount is _lpRewardAmount, which is determined by the three parameters _totalRewardAmount, _lpTokenBalance, _lpTokenTotalSupply. The patameter _totalRewardAmount is a constant, _lpTokenBalance is the caller’s balance of lp token, _lpTokenTotalSupply is the total supply of the lp token. So the larger the _lpTokenBalance, the more rewards attacker will get. The attacker obtained large amounts of lp token by adding liquidity through flashloans, and transferred these tokens to different attack contracts to repeatedly obtain rewards. SummaryThe root cause of this attack is the single factor in calculating rewards. Therefore, we recommend that multiple factors should be considered when calculating rewards to avoid be manipulated by attackers through flashloans and other methods.","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://l0s1.github.io/categories/BlockChain/"}],"tags":[{"name":"Security Events Learn","slug":"Security-Events-Learn","permalink":"https://l0s1.github.io/tags/Security-Events-Learn/"}]},{"title":"Defrost Finance攻击事件分析","slug":"Defrost-Finance攻击事件分析","date":"2022-12-29T06:05:47.000Z","updated":"2022-12-29T11:36:32.104Z","comments":true,"path":"2022/12/29/Defrost-Finance攻击事件分析/","link":"","permalink":"https://l0s1.github.io/2022/12/29/Defrost-Finance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/","excerpt":"","text":"事件概述Defrost Finance 是位于 AVAX 链上的 Defi 项目，经过了 Certik 的审计，且被 AVAX 链官方推广过。2022年12月23日，Defrost Finance V2 遭到闪电贷攻击，损失17K的资金。紧接着在12月25日，Defrost Finance V1 又遭受恶意攻击，攻击者将预言机修改为恶意地址，铸造了1亿枚 H2O代币，同时恶意清算了大量的仓位，项目损失了12M的资金。短时间内遭受两次攻击，且第二次攻击属于特权攻击，加上受害者无法联系到项目方，很难让人不去相信一切都是项目方监守自盗。 事件分析我们只看23号的攻击，攻击者使用闪电贷针对的V2版本的攻击。 攻击交易哈希： https://snowtrace.io/tx/0xc6fb8217e45870a93c25e2098f54f6e3b24674a3083c30664867de474bf0212d 首先攻击者调用 Defrost Finance V2 的 LendingSwitchUSDC 合约的 maxFlashLoan 方法以及 flashFee 方法，查看池子最多能贷出的 USDC 以及 贷出最大 USDC 需要的手续费，然后向攻击合约转入了手续费数量的 USDC： 首先攻击者从 Trader Joe (AVAX链上的Uniswap) 的 WAVAX-USDC 池子中闪电贷出了 194263.946117个 USDC，然后在 Joecall 回调函数中调用 Defrost Finance V2 的 LendingSwitchUSDC 合约的 flashloan 方法，继续贷出 194263.946117个 USDC： 接下来在二层回调 onFlashLoan 方法中调用 LendingSwitchUSDC 合约的 deposit 方法，存入 194263.946117个 USDC，并铸造了1844317.410414个 LSWUSDC。 然后向 LendingSwitchUSDC 合约转入194283.372511个 USDC，归还闪电贷，LendingSwitchUSDC 合约里会将其存入 AAVE，到这里 LendingSwitchUSDC 合约的 flashloan 方法结束。 然后继续调用 LendingSwitchUSDC 合约的 redeem 方法，提取出 368503793484个 USDC，最后归还 Trander Joe 的闪电贷，共194866.164349个USDC： 到这里针对 V2 的闪电贷攻击流程就结束了。 漏洞分析针对 V2 的攻击异常点在于攻击者调用 LendingSwitchUSDC 合约的 flashLoan 方法，在回调函数中调用 deposit 方法，存入了194263.946117个 USDC，但是在 flashLoan 方法结束后调用 redeem 方法取出了368503. 793484个 USDC。 查看 redeem 方法： 123456function redeem(uint256 shares,address receiver,address owner) external returns (uint256) &#123; uint256 _value = convertToAssets(shares); _withdraw(_value,shares,receiver,owner); emit Withdraw(msg.sender,receiver,_value,shares); return _value; &#125; 主要点在 _value 的计算上，查看 convertToAssets ： 123function convertToAssets(uint256 _shareNum) public view returns(uint256)&#123; return _shareNum.mul(getTotalAssets())/totalSupply(); &#125; 其中 getTotalAssets 方法如下： 123function getTotalAssets() internal virtual override(superSwitchErc20,superTokenInterface) view returns (uint256)&#123; return getAvailableBalance().add(totalAssetAmount()); &#125; 其中 getAvailableBalance 是当前 AAVE 包装代币的余额，而 totalAssetAmount 计算出来是一个固定的值，可以不用理会。 即 _value &#x3D; amount * (getAvailableBalance + totalAssetAmount ) &#x2F; totalSupply 正常情况下 redeemAmount 会等于 depositAmount。 查看合约的闪电贷方法： 1234567891011121314151617function flashLoan( IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data ) external virtual returns (bool) &#123; require(token == address(asset),&quot;flash borrow token Error!&quot;); uint256 fee = flashFee(token, amount); onWithdraw(address(receiver),amount); require( receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE, &quot;invalid return value&quot; ); onDeposit(address(receiver),amount + fee,0); emit FlashLoan(msg.sender,address(receiver),token,amount); return true; &#125; 可以看到逻辑是先去 AAVE 提款给 receiver， 然后调用 receiver.onFlashLoan 方法，最后再将还款存入到 AAVE。 攻击者在闪电贷的情况下调用 deposit 方法，取钱时 getAvailableBalance 为 0 ，闪电贷结束时，getAvailableBalance 的值为攻击者 deposit 的数量加上闪电贷还款存入 AAVE 的数量，和普通的 deposit 相比， getAvailableBalance 的值 多了 flashloanAmount + fee。因此攻击者 redeem 时能够获得更多的 USDC。 总结在 Defi 中使用 token.balanceOf(address(this)) 这个方法有一定的风险，需要谨慎对待，另外在重要方法中加入重入锁也能够增加安全性。在各类 Defi 项目层出不穷的情况下，判定项目是否有 rug pull 的风险十分重要。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"ElasticSwap攻击事件分析","slug":"ElasticSwap攻击事件分析","date":"2022-12-19T09:56:20.000Z","updated":"2022-12-20T08:21:23.181Z","comments":true,"path":"2022/12/19/ElasticSwap攻击事件分析/","link":"","permalink":"https://l0s1.github.io/2022/12/19/ElasticSwap%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/","excerpt":"","text":"事件概述2022年12月14日，ElasticSwap 项目遭到黑客攻击，在以太坊上的 AMPL-USDC 池子被盗，黑客获利445个 ETH。发生该事件的根本原因是合约中添加流动性和移除流动性两个操作使用的是两种不同数据源。 事件分析攻击交易哈希： https://etherscan.io/tx/0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f 首先攻击者调用 approve 进行授权，然后在 Uniswap V2 的 WETH-AMPL、USDC-USDT 池子调用闪电贷借出 AMPL 和 USDC: 然后第二次回调 uniswapV2Call 时候开始进攻攻击。 首先向 AMPL-USDC-ELATICSWAP 池子中添加两次流动性，第一次添加只转入了 AMPL，第二次添加转入了 AMPL 和 USDC ： 然后攻击者调用 transfer 方法向池子中转入 USDC，增加 baseTokenReserveQty 的值，然后再移除流动性： 这里攻击者 AMPL 以及 USDC 都没有回本，尤其是 AMPL，所以攻击者先将部分的 USDC 换成了 AMPL，使得能够归还闪电贷，然后再进行添加&#x2F;移除流动性操作，继续套利： 在进行了以上的操作后攻击者已经成功获利，然后攻击者开始归还闪电贷，在二层回调归还 USDC，一层回调归还 AMPL： 最后攻击者将获得的 AMPL 以及 USDC 全部换成 ETH，然后转移： 漏洞分析由上面的事件分析可以看到异常点位于添加&#x2F;移除流动性时，首先查看 Exchange 合约(类似Uinswap 的 Pair 合约)的 addLiquidity 方法： 123456789101112131415161718192021function addLiquidity( uint256 _baseTokenQtyDesired, uint256 _quoteTokenQtyDesired, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _liquidityTokenRecipient, uint256 _expirationTimestamp ) external nonReentrant() isNotExpired(_expirationTimestamp) &#123; uint256 totalSupply = this.totalSupply(); MathLib.TokenQtys memory tokenQtys = MathLib.calculateAddLiquidityQuantities( _baseTokenQtyDesired, _quoteTokenQtyDesired, _baseTokenQtyMin, _quoteTokenQtyMin, IERC20(baseToken).balanceOf(address(this)), totalSupply, internalBalances ); _mint(_liquidityTokenRecipient, tokenQtys.liquidityTokenQty); // mint liquidity tokens to recipient 可以看到关键点在 MathLib.calculateAddLiquidityQuantities 这个函数，找到这个函数的关键代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function calculateAddLiquidityQuantities( uint256 _baseTokenQtyDesired, uint256 _quoteTokenQtyDesired, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, uint256 _baseTokenReserveQty, uint256 _totalSupplyOfLiquidityTokens, InternalBalances storage _internalBalances ) public returns (TokenQtys memory tokenQtys) &#123; if ( quoteTokenQtyFromDecay &lt; _quoteTokenQtyDesired &amp;&amp; baseTokenQtyFromDecay &lt; _baseTokenQtyDesired ) &#123; // the user still has qty that they desire to contribute to the exchange for liquidity ( tokenQtys.baseTokenQty, tokenQtys.quoteTokenQty, tokenQtys.liquidityTokenQty ) = calculateAddTokenPairLiquidityQuantities( _baseTokenQtyDesired - baseTokenQtyFromDecay, // safe from underflow quoted on above IF _quoteTokenQtyDesired - quoteTokenQtyFromDecay, // safe from underflow quoted on above IF 0, // we will check minimums below 0, // we will check minimums below _totalSupplyOfLiquidityTokens + liquidityTokenQtyFromDecay, _internalBalances // NOTE: these balances have already been updated when we did the decay math. ); &#125; tokenQtys.baseTokenQty += baseTokenQtyFromDecay; tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay; tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay; require( tokenQtys.baseTokenQty &gt;= _baseTokenQtyMin, &quot;MathLib: INSUFFICIENT_BASE_QTY&quot; ); require( tokenQtys.quoteTokenQty &gt;= _quoteTokenQtyMin, &quot;MathLib: INSUFFICIENT_QUOTE_QTY&quot; ); &#125; else &#123; // the user is just doing a simple double asset entry / providing both base and quote. ( tokenQtys.baseTokenQty, tokenQtys.quoteTokenQty, tokenQtys.liquidityTokenQty ) = calculateAddTokenPairLiquidityQuantities( _baseTokenQtyDesired, _quoteTokenQtyDesired, _baseTokenQtyMin, _quoteTokenQtyMin, _totalSupplyOfLiquidityTokens, _internalBalances ); &#125; &#125; 可以看到会调用 calculateAddTokenPairLiquidityQuantities 计算 tokenQtys 中的值。跟进该函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function calculateAddTokenPairLiquidityQuantities( uint256 _baseTokenQtyDesired, uint256 _quoteTokenQtyDesired, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, uint256 _totalSupplyOfLiquidityTokens, InternalBalances storage _internalBalances ) public returns ( uint256 baseTokenQty, uint256 quoteTokenQty, uint256 liquidityTokenQty ) &#123; uint256 requiredQuoteTokenQty = calculateQty( _baseTokenQtyDesired, _internalBalances.baseTokenReserveQty, _internalBalances.quoteTokenReserveQty ); if (requiredQuoteTokenQty &lt;= _quoteTokenQtyDesired) &#123; // user has to provide less than their desired amount require( requiredQuoteTokenQty &gt;= _quoteTokenQtyMin, &quot;MathLib: INSUFFICIENT_QUOTE_QTY&quot; ); baseTokenQty = _baseTokenQtyDesired; quoteTokenQty = requiredQuoteTokenQty; &#125; else &#123; // we need to check the opposite way. uint256 requiredBaseTokenQty = calculateQty( _quoteTokenQtyDesired, _internalBalances.quoteTokenReserveQty, _internalBalances.baseTokenReserveQty ); require( requiredBaseTokenQty &gt;= _baseTokenQtyMin, &quot;MathLib: INSUFFICIENT_BASE_QTY&quot; ); baseTokenQty = requiredBaseTokenQty; quoteTokenQty = _quoteTokenQtyDesired; &#125; liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry( _totalSupplyOfLiquidityTokens, quoteTokenQty, _internalBalances.quoteTokenReserveQty ); _internalBalances.baseTokenReserveQty += baseTokenQty; _internalBalances.quoteTokenReserveQty += quoteTokenQty; &#125; 计算 liquidityTokenQty 使用的函数 calculateLiquidityTokenQtyForDoubleAssetEntry，跟进该函数： 123456789function calculateLiquidityTokenQtyForDoubleAssetEntry( uint256 _totalSupplyOfLiquidityTokens, uint256 _quoteTokenQty, uint256 _quoteTokenReserveBalance ) public pure returns (uint256 liquidityTokenQty) &#123; liquidityTokenQty = (_quoteTokenQty * _totalSupplyOfLiquidityTokens) / _quoteTokenReserveBalance; &#125; 到这里可以发现计算 liquidityTokenQty 使用的 _quoteTokenReserveBalance，该值来自_internalBalances.quoteTokenReserveQty，因此添加流动性这个操作使用的 internalBalances 的数据。 再看移除流动性函数 removeLiquidity 的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394function removeLiquidity( uint256 _liquidityTokenQty, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _tokenRecipient, uint256 _expirationTimestamp ) external nonReentrant() isNotExpired(_expirationTimestamp) &#123; require(this.totalSupply() != 0, &quot;Exchange: INSUFFICIENT_LIQUIDITY&quot;); require( _baseTokenQtyMin != 0 &amp;&amp; _quoteTokenQtyMin != 0, &quot;Exchange: MINS_MUST_BE_GREATER_THAN_ZERO&quot; ); uint256 baseTokenReserveQty = IERC20(baseToken).balanceOf(address(this)); uint256 quoteTokenReserveQty = IERC20(quoteToken).balanceOf(address(this)); uint256 totalSupplyOfLiquidityTokens = this.totalSupply(); // calculate any DAO fees here. uint256 liquidityTokenFeeQty = MathLib.calculateLiquidityTokenFees( totalSupplyOfLiquidityTokens, internalBalances ); // we need to factor this quantity in to any total supply before redemption totalSupplyOfLiquidityTokens += liquidityTokenFeeQty; uint256 baseTokenQtyToReturn = (_liquidityTokenQty * baseTokenReserveQty) / totalSupplyOfLiquidityTokens; uint256 quoteTokenQtyToReturn = (_liquidityTokenQty * quoteTokenReserveQty) / totalSupplyOfLiquidityTokens; require( baseTokenQtyToReturn &gt;= _baseTokenQtyMin, &quot;Exchange: INSUFFICIENT_BASE_QTY&quot; ); require( quoteTokenQtyToReturn &gt;= _quoteTokenQtyMin, &quot;Exchange: INSUFFICIENT_QUOTE_QTY&quot; ); // this ensures that we are removing the equivalent amount of decay // when this person exits. &#123; //scoping to avoid stack too deep errors uint256 internalBaseTokenReserveQty = internalBalances.baseTokenReserveQty; uint256 baseTokenQtyToRemoveFromInternalAccounting = (_liquidityTokenQty * internalBaseTokenReserveQty) / totalSupplyOfLiquidityTokens; internalBalances.baseTokenReserveQty = internalBaseTokenReserveQty = internalBaseTokenReserveQty - baseTokenQtyToRemoveFromInternalAccounting; // We should ensure no possible overflow here. uint256 internalQuoteTokenReserveQty = internalBalances.quoteTokenReserveQty; if (quoteTokenQtyToReturn &gt; internalQuoteTokenReserveQty) &#123; internalBalances .quoteTokenReserveQty = internalQuoteTokenReserveQty = 0; &#125; else &#123; internalBalances .quoteTokenReserveQty = internalQuoteTokenReserveQty = internalQuoteTokenReserveQty - quoteTokenQtyToReturn; &#125; internalBalances.kLast = internalBaseTokenReserveQty * internalQuoteTokenReserveQty; &#125; if (liquidityTokenFeeQty != 0) &#123; _mint( IExchangeFactory(exchangeFactoryAddress).feeAddress(), liquidityTokenFeeQty ); &#125; _burn(msg.sender, _liquidityTokenQty); IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn); IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn); emit RemoveLiquidity( msg.sender, baseTokenQtyToReturn, quoteTokenQtyToReturn ); &#125; 关键的部分代码： 12345678910111213uint256 baseTokenReserveQty = IERC20(baseToken).balanceOf(address(this));uint256 quoteTokenReserveQty = IERC20(quoteToken).balanceOf(address(this));uint256 baseTokenQtyToReturn = (_liquidityTokenQty * baseTokenReserveQty) / totalSupplyOfLiquidityTokens;uint256 quoteTokenQtyToReturn = (_liquidityTokenQty * quoteTokenReserveQty) / totalSupplyOfLiquidityTokens;_burn(msg.sender, _liquidityTokenQty);IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn); 可以看到池子储量代币量使用的 balanceOf(address(this)) 数据，用户移除流动性获得的代币为：用户的流动性 * 池子储量 &#x2F; 总的流动性。 添加流动性时使用的 internalBalabnces 数据，而移除流动性时使用的 balanceOf(address(this)) 数据。 因此添加流动性后，往池子内转入相应的代币，然后再移除流动性，此时计算的 quoteTokenReserveQty 则会变大，因此用户获得的代币也会相应变大。 正常移除流动性所得： 1liquidity * Reserve / totalliquidity; 往池子内转入代币后再移除流动性所得： 1liquidity * (Reserve + Tansfer) / totalliquidity; 那么多获得的数量为： 1liquidity * Tansfer / totalliquidity 再减去转入的代币后计算出一次添加&#x2F;移除流动性的获利： 1liquidity * Tansfer / totalliquidity - Transfer = （（liquidity / totalliquidity）-1）* Transfer 由于liquidity / totalliquidity 是肯定小于1的，因此如果只是添加&#x2F;移除流动性一次的话是无法获利的，但是我们可以通过多次的添加&#x2F;移除流动性操作来完成获利，因为池子没有方法来平衡 internalBalances 和 balancesOf(address(this))，转入池子的代币会让这两个变量一直存在差值。所以我们只要保证 (liquidity / totalliquidity) * N &gt; 1 即可获利，N 为添加&#x2F;移除流动性操作的次数。 总结合约中添加流动性和移除流动性使用的数据源不同导致了这次的攻击。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"NimbusPlatform攻击事件分析","slug":"NimbusPlatform攻击事件分析","date":"2022-12-19T06:40:13.000Z","updated":"2022-12-19T09:49:27.916Z","comments":true,"path":"2022/12/19/NimbusPlatform攻击事件分析/","link":"","permalink":"https://l0s1.github.io/2022/12/19/NimbusPlatform%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/","excerpt":"","text":"事件概述2022年12月24日，BSC 链上的 NimbusPlatform 项目遭到攻击，损失大约278个 BNB。遭受攻击的根本原因是其质押合约使用的预言机存在缺陷，可以被操控。 事件分析攻击交易哈希： https://bscscan.com/tx/0x42f56d3e86fb47e1edffa59222b33b73e7407d4b5bb05e23b83cb1771790f6c1 首先攻击者从三个池子中闪电贷出 WBNB 共计75477个，分别是 DODO、Biswap-WBNB-BUSD、 Biswap-USDT-WBNB，并全部将其兑换成 NBU_WBNB : 然后给 NimbusRouter 授权，调用 swapExactTokensForTokensSupportingFeeOnTransferTokens 将 NBU_WBNB 兑换成 NIMB： 然后调用 0xe166a1d4b551db58c80ad3de194a01ec20d9c47d 合约的 0xa66edba2 方法，该方法调用 StakingRewardFixedAPY.getReward，获取GNIMB，然后再调用 0xe166a1d4b551db58c80ad3de194a01ec20d9c47d 的 0x484e4699 方法，该方法调用 StakingRewardFixedAPY.withdraw，提出 GNIMB： 然后攻击者调用其他两个攻击合约的方法，利用相同的方法，从质押池中提取奖励 GNIMB： 到这里攻击者提取奖励阶段完成了，接下来就是将各个池子掏空。 首先在 Biswap-NBU_WBNB-NIMB 池子中将NIMB兑换成 NBU_WBNB： 然后攻击者多次调用 NimbusRouter.getAmountsOut 方法，寻找兑换 NBU_WBNB 最多的方式： 接着在 Biswap-GNIMB-NIMB 池子中将部分 GNIMB 兑换成 NIMB，然后将兑换的 NIMB 在 Biswap-NBU_WBNB-NIMB 池子中兑换成 NBU_WBNB： 最后将剩下的 GNIMB 在Biswap-GNIMB-NBU_WBNB 池子中兑换成 NBU_WBNB： 最后将 NBU_WBNB 兑换成 BNB，再将 BNB 换成 WBNB，归还闪电贷，转移攻击获利： 漏洞分析通过上面的攻击步骤能发现异常点在攻击者提取奖励时，攻击者每次提取奖励都能够提取巨量的奖励，我们找到 StakingRewardFixedAPY 合约的 getReward 方法： 12345678910function getReward() public override nonReentrant whenNotPaused &#123; uint256 reward = earned(msg.sender); if (reward &gt; 0) &#123; for (uint256 i = 0; i &lt; stakeNonces[msg.sender]; i++) &#123; stakeNonceInfos[msg.sender][i].stakeTime = block.timestamp; &#125; rewardsPaymentToken.safeTransfer(msg.sender, reward); emit RewardPaid(msg.sender, address(rewardsPaymentToken), reward); &#125; &#125; 奖励的数量由 earned 方法计算，找到 earned 方法： 12345function earned(address account) public view override returns (uint256 totalEarned) &#123; for (uint256 i = 0; i &lt; stakeNonces[account]; i++) &#123; totalEarned += earnedByNonce(account, i); &#125; &#125; OK，继续套娃，找到 earnedByNonce 方法： 123456function earnedByNonce(address account, uint256 nonce) public view returns (uint256) &#123; uint256 amount = stakeNonceInfos[account][nonce].rewardsTokenAmount * (block.timestamp - stakeNonceInfos[account][nonce].stakeTime) * stakeNonceInfos[account][nonce].rewardRate / (100 * rewardDuration); return getTokenAmountForToken(address(rewardsToken), address(rewardsPaymentToken), amount); &#125; 这里可以看到 amount 取决于质押的数量以及时间以及 rewardRate 变量，该变量在合约构造函数中初始化，因此 amount 攻击者无法操控，继续看 getTokenAmountForToken 方法，其中 tokenSrc 是 NIMB，tokenDest 是 GNIMB ： 1234567891011function getTokenAmountForToken(address tokenSrc, address tokenDest, uint256 tokenAmount) public view returns (uint) &#123; if (tokenSrc == tokenDest) return tokenAmount; if (usePriceFeeds &amp;&amp; address(priceFeed) != address(0)) &#123; (uint256 rate, uint256 precision) = priceFeed.queryRate(tokenSrc, tokenDest); return tokenAmount * rate / precision; &#125; address[] memory path = new address[](2); path[0] = tokenSrc; path[1] = tokenDest; return swapRouter.getAmountsOut(tokenAmount, path)[1]; &#125; 这里如果不使用 priceFeed 则返回 getAmountsOut 的值，如果使用 priceFeed 则调用 priceFeed的 queryRate 方法，并返回 tokenAmount * rate / precision 的值，跟进 queryRate 方法： 12345678910111213function queryRate( address sourceToken, address destToken) public view returns (uint256 rate, uint256 precision) &#123; require(!globalPricingPaused, &quot;pricing is paused&quot;); return _queryRate( sourceToken, destToken ); &#125; 继续套娃，查看 _queryRate 方法： 123456789101112131415161718192021function _queryRate( address sourceToken, address destToken) internal view returns (uint256 rate, uint256 precision) &#123; if (sourceToken != destToken) &#123; uint256 sourceRate = _queryRateCall(sourceToken); uint256 destRate = _queryRateCall(destToken); rate = sourceRate .mul(WEI_PRECISION) .div(destRate); precision = _getDecimalPrecision(sourceToken, destToken); &#125; else &#123; rate = WEI_PRECISION; precision = WEI_PRECISION; &#125; &#125; 这里的 rate 由 sourceRate、destRate相除所得，这俩又由 _queryRateCall 求出，查看该函数： 123456789101112131415function _queryRateCall( address token) internal view returns (uint256 rate) &#123; if (token != address(wbnbToken)) &#123; IPriceFeedsExt _Feed = pricesFeeds[token]; require(address(_Feed) != address(0), &quot;unsupported price feed&quot;); rate = uint256(_Feed.latestAnswer()); require(rate != 0 &amp;&amp; (rate &gt;&gt; 128) == 0, &quot;price error&quot;); &#125; else &#123; rate = WEI_PRECISION; &#125; &#125; 可以看到由 pricesFeeds[token].latestAnswer 求出，找到两种代币对应的 pricesFeeds[token]，然后查看其 latestAnswer 方法： 123function latestAnswer() external override view returns (uint256) &#123; return swapRouter.getAmountsOut(10 ** decimals, swapPath)[swapPath.length - 1] * multiplier / MULTIPLIER_DEFAULT; &#125; 可以看到 latestAnswer 方法就是调用 swapRouter 的 getAmountsOut 方法，其中 swapPath 是用两种代币兑换 NBU_WBNB，即 1 个 NIMB 或者 GNIMMB 能兑换多少个 NBU_WBNB。 那么最终可以得出，PriceFeeds.queryRate方法的值为 Biswap-NBU_WBNB-NIMB 池子中 NIMB 的价格除以 Biswap-GNIMB-NBU_WBNB 池子中 GNIMB的价格。 攻击者最开始通过闪电贷借入了大量的 WBNB，将其兑换为 NBU_WBNB 并 swap 成 NIMB ，因此 Biswap-NBU_WBNB-NIMB 池子中 NIMB 的价格大幅度上涨，而 GNIMB 的价格不变，因此 queryRate 的返回值变大，攻击者获取质押奖励时也会变多。 到这里漏洞分析结束。 漏洞修复项目方在攻击事件发生后，重新部署了预言机合约，将链上预言机修改成了链下预言机，latestAnswer 方法的值由 owner 设置： 总结质押合约使用的预言机存在缺陷导致了此次漏洞。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"GenomesDao攻击事件学习","slug":"GenomesDao攻击事件学习","date":"2022-08-08T10:28:16.000Z","updated":"2022-10-08T09:29:45.206Z","comments":true,"path":"2022/08/08/GenomesDao攻击事件学习/","link":"","permalink":"https://l0s1.github.io/2022/08/08/GenomesDao%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"事件概述UTC 时间2022年8月5日8时，MATIC 链上的项目 GenomesDAO 被攻击，其 LPSTAKING 合约以及 VeGnomeLock 合约中的资金被盗走。事件的主要原因是因为合约中的 initialized 函数可被无限制调用。 事件分析攻击者 EOA 地址： 0x43EC1D163cc4C15B574F86d8203c3B0F3EbED7a3 攻击合约： 0x9aa63491bb927f024d37b0e6017137f7f03da3c6 0x8e10c9493501a828304d77630b6f862bbf50c052 0x4a7c088099f744d5c6c838c71502a04e0983f266 攻击交易哈希： 0x252a7e6f23ffb516c23df2a3b2e09b42d00a06fa4e9a5830e74fb35581f7632c 0x82cebaf092bc6a4c9235daeda6a9b504a873844c41dc31c51dbeebbab96a90bf 首先查看交易 0x252a7e6f23ffb516c23df2a3b2e09b42d00a06fa4e9a5830e74fb35581f7632c ，其首先通过代理合约调用了 LPStakingOnPoly 合约的 initialized 方法，更新了 _stakingToken 的值，修改为攻击者创建的攻击合约的地址： 然后调用通过代理合约 LPStakingOnPoly 的 stake 方法，质押数量为 946677946000000000000。由于其 _stakingToken 的值已经被攻击者控制，因此会 stake 虚假的代币，并修改相应的 _balances 的值： 接下来攻击者再次调用 LPStakingOnPoly 合约的 initialized 方法，将 _stakingToken 的值修改为正常的 SushiSwap LP Token 的地址： 然后攻击者通过代理合约调用 LPStakingOnPoly 合约的 withdraw 方法，由于 _stakingToken 的值已经变成正常的 SushiSwap LP Token 的地址，因此攻击者提取了 946677946000000000000 数量的 LP： 接下来攻击者继续重复上面的步骤，先 initialized 修改为虚假的代币地址，然后再 satke ，接着再 initialized 为真实的代币地址，最后调用 withdraw 提取真实的代币。不同的地方在于修改的真实代币的地址不同。 改笔交易最后还对 VeGnomeLock 合约进行了攻击，因为使用了一样的 initialized 方法。具体步骤是先 initialized 修改 _lockToken 为虚假代币地址，然后调用 lock 进行锁仓，接着再 initialized 为真实的代币地址，最后调用 emergencyUnlock 方法解除锁仓，提取真实代币。 攻击者通过以上步骤提取的大量的真实代币： 然后再看交易 0x82cebaf092bc6a4c9235daeda6a9b504a873844c41dc31c51dbeebbab96a90bf，攻击者将获取到的 LP Token 兑换成相应的代币，最后将 WETH 发送至攻击者的 EOA 地址： 后续攻击者通过 anyswap 进行兑换及转移资产： 漏洞详解漏洞点位于 initialized 方法，该函数可见性为 public ，其位于父合约中，作用就是初始化质押代币的地址： 12345function initialized(address _stakingToken, string memory _nameArg, string memory _symbolArg) public &#123; stakingToken = IERC20(_stakingToken); name = _nameArg; symbol = _symbolArg; &#125; 然后子合约中存在 initialize 方法，该方法会调用父合约的 initialized 方法，进行初始化操作，且带有修饰器 initializer ，只能够调用一次： 123456789101112131415function initialize( string memory _name, string memory _symbol, address _stakingToken, address _rewardToken, address _veToken ) public initializer &#123; __Ownable_init(); LPStakingOnPolyWrapper.initialized( _stakingToken, _name, _symbol ); ... &#125; 但是其并未重写 initialized 方法，并且其可见性为 public ，因此任何人都可以调用该方法。 修复将父合约的 initialized 方法的可见性修改为 internal ，或者添加修饰器进行限定。 总结此次攻击事件原理较为简单，在编写合约时务必考虑好各个方法的可见性，防止发生越权。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Wormhole赏金漏洞学习","slug":"Wormhole赏金漏洞学习","date":"2022-08-08T10:18:34.000Z","updated":"2022-08-08T10:26:09.475Z","comments":true,"path":"2022/08/08/Wormhole赏金漏洞学习/","link":"","permalink":"https://l0s1.github.io/2022/08/08/Wormhole%E8%B5%8F%E9%87%91%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"简介Wormhole 是一个跨链桥，可以连接到多个链，如 solana、Ethereum、BSC 等。2022年2月24日，名为 satya0x 的白帽子负责任地披露了以太坊上 Wormhole 核心桥接合约的一个严重漏洞，该漏洞和可升级的代理合约有关。Wormhole 向 satya0x 支付了创纪录的 1000 万美元的漏洞赏金（太猛了家人们就是说）。 前置知识 delegatecall 和 call delegatecall 不会修改 msg 中的信息，且会将调用的合约在当前合约中运行（执行环境为当前合约），也就是 storage 使用的当前合约。 call 会修改 msg.sender 为当前合约，但是执行环境在调用的目标合约。 透明代理模式 (TPP) 和通用可升级代理标准 (UUPS) 通过 delegatecall 的特性，我们可以实现可升级的合约。代理合约除了通过 delegatecall 调用实现合约，其本身也会实现一些方法，如 upgradeTo，如果实现合约中存在同名方法，那如何判断到底调哪个合约的方法呢？ 其中透明代理模式（TPP）是一种解决方式，具体做法是当调用者是代理合约的管理员时，调用的是代理合约的方法；当调用者是其他的用户地址时，通过代理合约调用逻辑合约的方法。在该模式中，如果调用者是代理的管理员，则代理合约不会进行任何 delegatecall 调用。 通用可升级代理标准则（UUPS）是一种新的方式，其和透明代理模式的区别在于，透明代理模式的升级逻辑在代理合约中，而 UUPS 则在实现合约中。 漏洞分析Wormhole采用的代理模式为 UUPS，也就是升级逻辑也存在在实现合约中，项目方只通过代理合约调用了 initialize 方法，未在实现合约中调用该方法，而该方法默认所有人都可调用，因此漏洞攻击的路径如下： 攻击者调用 initialize 方法，初始化 initialGuardians 以及 chainId、governanceChainId 、 governanceContract 等参数，其中最重要的参数为 initialGuardians，将其设置为攻击地址。 攻击者部署 destructor 合约，在其 initialize 方法中实现 destructor。 然后调用 submitContractUpgrade 方法，传入的参数为 bytes，其中包含了 timestamp、nonce、chainId、governance.address、destructor.address、attackerSigner.address、guardianSetIndex等。 当校验传入的 vm， 通过以后，会调用 upgradeImplementation 升级合约。该函数中调用 _upgradeTo 方法去升级合约，同时还会通过 delegatecall 调用新的实现合约的 initialize 方法。由于新的实现合约的 initialize 中会进行 destructor 操作，因此该合约会被毁掉，而代理合约没有任何逻辑实现，只靠 delegatecall 调用该合约，因此代理合约会无法使用。 总结Wormhole 采用 UUPS 的代理模式，但未对实现合约进行初始化导致漏洞产生。 在使用 UUPS 代理模式时，需要注意实现合约初始化的问题，防止被黑客调用初始化方法获得管理员权限，从而恶意调用更新方法销毁实现合约，锁定代理合约所有资产。 参考Wormhole Uninitialized Proxy Bugfix Review 跨链桥：Web3黑客必争之地 Transparent vs UUPS Proxies","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Audius攻击事件学习","slug":"Audius攻击事件学习","date":"2022-07-27T13:50:21.000Z","updated":"2022-07-27T13:57:03.658Z","comments":true,"path":"2022/07/27/Audius攻击事件学习/","link":"","permalink":"https://l0s1.github.io/2022/07/27/Audius%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"事件概述Web3 音乐平台 Audius 在 UTC 时间2022年7月23日11点遭到攻击，其社区金库中的1850万枚 AUDIO 代币被盗，黑客在 Uniswap 上将其换成 ETH 后，转入 Tornado 。此次攻击的主要原因是代理合约和实现合约之前存在插槽冲突，导致其 initialize 函数可以被重复调用。 事件分析攻击者EOA地址：0xa0c7BD318D69424603CBf91e9969870F21B8ab4c 攻击合约地址：0xbdbB5945f252bc3466A319CDcC3EE8056bf2e569 攻击交易HASH： 0xfefd829e246002a8fd061eede7501bccb6e244a9aacea0ebceaecef5d877a984 0x3c09c6306b67737227edc24c663462d870e7c2bf39e9ab66877a980c900dd5d5 0x4227bca8ed4b8915c7eec0e14ad3748a88c4371d4176e16e8007249b9980dc9 首先攻击者部署攻击合约 0xbdbB5945f252bc3466A319CDcC3EE8056bf2e569，然后调用攻击合约的 0x5bc7c6ac 方法，交易哈希为 0xfefd829e246002a8fd061eede7501bccb6e244a9aacea0ebceaecef5d877a984，具体的调用的函数如下： 可以看到攻击者首先通过代理合约调用了 Governance 合约的 initialize 函数，进行了一系列初始化设置： 1(_registryAddress = 0xbdbb5945f252bc3466a319cdcc3ee8056bf2e569, _votingPeriod = 3, _executionDelay = 0, _votingQuorumPercent = 1, _maxInProgressProposals = 4, _guardianAddress = 0xbdbb5945f252bc3466a319cdcc3ee8056bf2e569) 在合约中找到 initialize 函数： 发现其存在修饰器 initializer，找到该修饰器： 第一次调用 initialize 时，initialized 以及 initializing 的值都为 false ，因此 require 中的条件满足，函数执行完后，initialized 的值变成了 true，initializing 的值为 false，因此被 initializer 修饰的函数只能够调用一次。 那么攻击者是如何再次调用的呢？大概率是因为代理合约和实现合约之前的存储槽冲突。 首先看代理合约： 该合约继承了 UpgradeabilityProxy 合约，查看该合约以及该合约继承的合约等，发现只有一个 Implementation 变量需要存储，但其插槽位于指定的位置，并非0槽： 然后就是 AudiusAdminUpgradeabilityProxy 合约的 proxyadmin 变量，位于0槽。 再看实现合约： Governance 合约继承 InitializableV2 合约，InitializableV2 合约继承 Initializable 合约： 因此 Governance 插槽0处存在 initialized、initializing、isInitialized 三个布尔变量，后续变量如果小于29字节也会在0槽。 因此两个合约的 storage 布局如下： 由于代理合约中存储实现合约的所有状态变量，因此在0槽会发生冲突： 当代理合约的创建后，构造函数初始化 proxyAdmin，因此 initialized、initializing 会被覆盖，导致其恒为 true，因此 initializer 修饰器失效，可以无限制调用 initialize 函数。 攻击合约调用完 initialize 函数后，调用 evaluateProposalOutcome 函数评估84提案，但并未成功执行该提案。 然后调用 AUDIO 合约的 balanceOf 函数查看代币余额。 接着调用 submitProposal 函数发起新的提案，提案内容为向攻击合约转币，数量为1850万： 123(_targetContractRegistryKey = 3078000000000000000000000000000000000000000000000000000000000000, _callValue = 0, _functionSignature = transfer(address,uint256), _callData = 000000000000000000000000bdbb5945f252bc3466a319cdcc3ee8056bf2e5690000000000000000000000000000000000000000000f5b2f71812d138f71f6f5, _name = Hello, _description = World) 接着调用 Staking 的 initialize 函数，将攻击合约地址设置为 tokenAddress、governanceAddress。 调用 DelegateManagerV2 的 initialize 函数，将攻击合约地址设置为 tokenAddress、governanceAddress。 调用 DelegateManagerV2 的 setServiceProviderFactoryAddress 函数，将攻击合约地址设置为 spFactory。 调用 DelegateManagerV2 的 delegateStake 函数，给攻击合约地址大量投票。 接下来攻击者调用攻击合约的 0xcc66ce79 函数，交易哈希为0x3c09c6306b67737227edc24c663462d870e7c2bf39e9ab66877a980c900dd5d5，相关的调用栈如下： 攻击合约调用 Governance 合约的 submitVote 函数，向85号提案投票。 最后攻击者调用攻击合约的 0x543db4c4 函数，交易哈希为0x4227bca8ed4b8915c7eec0e14ad3748a88c4371d4176e716e8007249b9980dc9，相关调用栈如下： 攻击合约调用 Governance 合约的 evaluateProposalOutcome 函数，评估85号提案，并成功执行，向攻击合约地址转了1850万枚 AUDIO 代币。 至此攻击结束，攻击者将这1850万枚代币在 Uniswap 上换成 ETH，然后转入混币器 Tornado.Cash。 修复建议官方发声明已经修复，查看代码： 发现在 Initializable 合约处新增了三个变量，address private proxyAdmin 以及两个填充变量 uint256 private filler1、uint256 private filler2，这样就不会存在插槽冲突了。同时在修饰器 initializer 中添加了判断条件 msg.sender == proxyAdmin，限定了调用者。 总结代理合约与实现合约的存储槽冲突是导致此次攻击事件的主要原因。个人学习了很久才分析明白，暴露了自己在 storage 方面知识的缺失，后续还需要多学习学习。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Revest Finance攻击事件学习","slug":"Revest-Finance攻击事件学习","date":"2022-07-12T08:39:09.000Z","updated":"2022-07-12T12:16:47.039Z","comments":true,"path":"2022/07/12/Revest-Finance攻击事件学习/","link":"","permalink":"https://l0s1.github.io/2022/07/12/Revest-Finance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"事件概述2022年3月27日，Revest Finance 被攻击，损失大约 2M$(352,835 RENA)，主要的攻击方式为重入攻击。 前置知识Revest Finance 的合约 Revest 提供三种方式进行质押资产，mint 相应的 FNFT： mintTimeLock : 用户质押的数字资产在一段时间之后才能被解锁； mintValueLock : 用户质押的数字资产只有在升值或者贬值到预设数值才能被解锁； mintAddressLock : 用户质押的数字资产只能被预设的账户解锁。 例如 mintAddressLock，用户需要传入参数为：trigger(解锁人)，arguments(可省略)，recipients(接受人)，quantities(FNFT 数量)，FNFTConfig(结构体，包含质押物 asset，每枚 FNFT 对应的质押物数量 depositAmount 以及其他信息)。 同时还提供depositAdditionalToFNFT方法，用于让用户为存在的FNFT质押更多的质押物。传入的参数为：fnftId(存在的 FNFT 的 ID)，amount(每枚 FNFT 对应的质押物数量)，quantity(FNFT 数量)。其中 quantity 可以小于或者等于 mint 的数量，当等于时，合约会 burn 掉之前的 FNFT，并生成新的 FNFT，修改其对应的质押物数量；当小于时，合约会 burn 掉增加质押物数量的 FNFT，生成新的 FNFT，并修改其对应的质押物数量，此时用户存在两种 ID 的 FNFT，一种是原来质押物数量的，一种是增加了质押物数量的。 事件分析攻击交易哈希：0xe0b0c2672b760bef4e2851e91c69c8c0ad135c6987bbf1f43f5846d89e691428 攻击者通过 uniswap 闪电贷获取了2 RENA，然后调用mintAddressLock，铸造 ID 为1027的 FNFT： 其中解锁人以及接受人都是攻击合约，铸造 FNFT 的数量为2，质押物为 RENA，数量为0。 然后攻击者再次调用mintAddressLock，铸造新的 FNFT，其 ID 为1028： 其中解锁人以及接受人都是攻击合约，铸造 FNFT 的数量为360000，质押物为 RENA，数量依然为0。 然后攻击合约在收到此次铸造的 FNFT 后触发 onERC1155Received函数（攻击者通过条件判断让第一次调用onERC1155Received时不执行操作，第二次才执行），该函数调用 Revest 合约中的depositAdditionalToFNFT函数，此时攻击者传入的该函数的参数为：fnftId &#x3D; 1,027, amount &#x3D; 1,000,000,000,000,000,000, quantity &#x3D; 1 因此合约会 burn 掉 一个 ID 为1027，对应质押物为0 RENA 的 FNFT，生成一个 ID 为1028，对应质押物为1 RENA的 FNFT，至于为什么ID还是1028，因为其 handle 合约中的mint 函数这样写的： 123456789function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController &#123; supply[id] += amount; _mint(account, id, amount, data); fnftsCreated += 1; &#125; depositAdditionalToFNFT函数中会调用 vault 合约的handleMultipleDeposits函数更新对应的质押关系： 12345678910111213function handleMultipleDeposits( uint fnftId, uint newFNFTId, uint amount ) external override onlyRevestController &#123; require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;); IRevest.FNFTConfig storage config = fnfts[fnftId]; config.depositAmount = amount; mapFNFTToToken(fnftId, config); if(newFNFTId != 0) &#123; mapFNFTToToken(newFNFTId, config); &#125; &#125; 此时传入的值为：fnftId&#x3D;1027，newFNFTId&#x3D;1028，amount&#x3D;1,000,000,000,000,000,000 因此最后 ID 为1028的 FNFT 对应的质押物被修改为1 RENA。之前攻击者铸造了360000枚 ID 为1028的 FNFT，再加上这新铸造的1枚，对应的质押物也就变成了360001个 RENA。 最后攻击者调用withdrawNFNFT函数，burn 掉 FNFT，提走 RENA，并偿还闪电贷： 额外的漏洞此漏洞为 BlockSec团队发现，位于 vault 合约的handleMultipleDeposits函数： 12345678910111213function handleMultipleDeposits( uint fnftId, uint newFNFTId, uint amount ) external override onlyRevestController &#123; require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;); IRevest.FNFTConfig storage config = fnfts[fnftId]; config.depositAmount = amount; mapFNFTToToken(fnftId, config); if(newFNFTId != 0) &#123; mapFNFTToToken(newFNFTId, config); &#125; &#125; 当想增加已存在的 FNTF 对应的质押物时，用户可以调用depositAdditionalToFNFT函数，正常逻辑是 burn 掉用户传入的数量，生成相应数量的新的 FNFT，并修改新生成的 FNFT 对应的质押关系。但是此处handleMultipleDeposits函数会将所有的 FNFT 的质押关系都修改，也即原来的 FNFT 和新生成的 FNFT 的质押关系都会被修改。我们可以铸造10枚 FNFT，对应质押数量为0 ，ID为1，然后调用depositAdditionalToFNFT，增加其中一枚的 FNFT 对应的质押数量为1，那么执行handleMultipleDeposits函数后，我会有9枚对应质押数量为1、ID 为1的 FNFT，1枚对应质押数量为1，ID 为2的 FNFT，算下来净获利9个币。 修复建议mint以及mintBatchRec函数建议先修改变量状态： 12345678910111213function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController &#123; supply[id] += amount; fnftsCreated += 1; _mint(account, id, amount, data); &#125;function mintBatchRec(address[] calldata recipients, uint[] calldata quantities, uint id, uint newSupply, bytes memory data) external override onlyRevestController &#123; supply[id] += newSupply; fnftsCreated += 1; for(uint i = 0; i &lt; quantities.length; i++) &#123; _mint(recipients[i], id, quantities[i], data); &#125; &#125; handleMultipleDeposits函数在 newFNFTId为0时不修改fnftId对应的config: 1234567891011121314function handleMultipleDeposits( uint fnftId, uint newFNFTId, uint amount) external override onlyRevestController &#123; require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;); IRevest.FNFTConfig memory config = fnfts[fnftId]; config.depositAmount = amount; if(newFNFTId != 0) &#123; mapFNFTToToken(newFNFTId, config); &#125; else &#123; mapFNFTToToken(fnftId, config); &#125;&#125; 总结此次事件攻击者通过 ERC1155 的回调结合mint函数和handleMultipleDeposits的缺陷，成功进行了攻击，攻击技巧比较巧妙，十分牛逼。 参考More than Re-entrancy : Revest Finance 被攻击事件分析 Revest Finance漏洞–NFT的重入攻击？","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"OP代币被盗事件学习","slug":"OP代币被盗事件学习","date":"2022-06-13T10:52:02.000Z","updated":"2022-06-14T03:08:19.438Z","comments":true,"path":"2022/06/13/OP代币被盗事件学习/","link":"","permalink":"https://l0s1.github.io/2022/06/13/OP%E4%BB%A3%E5%B8%81%E8%A2%AB%E7%9B%97%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"事件概述2022年6月9日，Optimism 和加密货币做市商 Wintermute 发布公告，2000万个 OP 代币被黑客盗取。OP 向 Wintermute 提供了2000万代币，委托其提供流动性服务，OP 在向 Wintermute 发送了1 OP 代币和100万 OP 两笔交且 Wintermute 确认无误后，又向其发送了1900万 OP 代币。但在发送完 OP代币后，Wintermute 发现其无法控制这些代币。因为其多签钱包只部署在以太坊主网上，未在 Optimism 网络部署，黑客通过抢先将该多签地址部署在 Optimism 网络上，成功控制代币。 前置知识多签钱包往区块链上发送一笔交易，需要使用钱包做一个签名，签名好后将交易发送出去，交易执行成功转装就成功，这是单签钱包。而多签钱包则是需要多个人去签名执行操作的钱包，使用时需要多个人签名发送交易后，转账操作才完成。多签钱包可以使用 m&#x2F;n 的模式，即 n 个人里有 m 个人签名即可完成操作。 常说的多签主要针对的是比特币和以太坊 ERC-20 标准代币。在比特币中有2种类型的地址，1开头的是 P2PKH，表示个人地址，3开头的是 P2SH，一般表示多签地址。普通的比特币地址是由公钥做哈希后得到的，而多重签名地址基于脚本哈希，所以能够实现复杂的交易逻辑，在原生上比特币就支持多签。而以太坊原生并不支持多签地址，多签钱包在以太坊中往往是一个智能合约。Ownbit 和 Gnosis 代表了当前主流的两种以太坊多签实现方式。其中 Wintermute 使用的 Gnosis 多签钱包。 EIP155 标准EIP155 标准用于防范重放攻击。 当区块高度大于 FORK_BLKNUM (2,675,000) 且 CHAIN_ID 可用时，在计算交易的哈希以进行签名时，不只是对六个 rlp 编码元素（nonce, gasprice, startgas, to, value, data）进行哈希处理，应对9个 rlp 编码元素（nonce, gasprice, startgas, to, value, data, chainid, 0, 0）进行哈希处理，所以签名后的 v 值为：{0,1} + CHAIN_ID * 2 + 35，而如果只对6个元素进行哈希处理，则签名后的 v 值为：{0,1} + 27。 当区块高度大于 FORK_BLKNUM (2,675,000) 且 v 值等于 CHAIN_ID * 2 + 35 或者 CHAIN_ID * 2 + 36 时，在计算交易的哈希以进行签名时，不只是对六个 rlp 编码元素进行哈希处理，应对9个 rlp 编码元素（nonce, gasprice, startgas, to, value, data, chainid, 0, 0）进行哈希处理。当前存在的使用 v 值等于27或者28签名方案保持有效，并继续在与以前相同的规则下运行。 简单点说的就是不加 CHAIN_ID 的签名后的 v 值在27-28之间，交易可以在不同的链上进行重放。 合约地址生成方式智能合约生成合约地址有两种方式，分别是 CREATE 指令和 CREATE2 指令，其中使用 CREATE 指令创建的合约地址可以使用keccak256(rlp.encode(deployingAddress, nonce))[12:]计算出来，其中 nonce的值每发送一笔交易或者创建一个合约就会 +1。 使用 CREATE2 指令创建的合约的地址使用keccak256(0xff ++ deployingAddr ++ salt ++ keccak256(init_code))[12:]计算，其中 init_code 是被部署合约的字节码。 事件分析首先是 Optimism 向 Wintermute 的多签钱包地址发送 OP 代币： 由于此时 Wintermute 的多签钱包只在以太坊主网上部署，未在 Optimism 网络上部署，因此其对2000万 OP 代币无控制权。 黑客此时抢先将该多签钱包地址部署到 Optimism 网络上。 黑客攻击地址为：0x60b28637879b5a09d21b68040020ffbf7dba5107 其首先分别向两个地址 0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A、0x8BcFe4f1358E50A1db10025D731C8b3b17f04DBB转账0.2 eth、0.5 eth： 其中 0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A 用来部署 Gnosis Safe 的 ProxyFactory 合约： 0x8BcFe4f1358E50A1db10025D731C8b3b17f04DBB 则用来部署 0xe7145dd6287ae53326347f3a6694fcf2954bcd8a 合约，该合约用于多次调用 ProxyFactory 中的 createProxy函数： 由于生成多签钱包地址的是 Gnosis Safe 的 ProxyFactory 合约，因此找到创建该合约的记录。 首先在 etherscan 搜索多签钱包地址0x4f3a120e72c76c22ae802d129f599bfdbc31cb81，然后找到其创建的记录： 然后找到 Gnosis Safe 的 ProxyFactory 合约的创建记录： 然后查看此时 v 值，不知道在 etherscan 如何查看，学习慢雾的方法，注册了一个 infura.io 账号，使用该命令查看详情：curl -s -H &#39;content-type:application/json&#39; -d &#39;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getTransactionByHash&quot;,&quot;params&quot;:[&quot;0x75a42f240d229518979199f56cd7c82e4fc1f1a20ad9a4864c635354b4a34261&quot;],&quot;id&quot;:1&#125;&#39; https://mainnet.infura.io/v3/xxxx 可以看到此时的 v 值为 0x1c，换算为十进制为28，因此该 v 值不符合 EIP155标准，不带 CHAIN_ID，可以在其他链进行重放攻击，以得到相同地址的合约，攻击者在 Optimism 网络重放，得到地址与在以太坊主网相同的 ProxyFactory 合约： 然后再看 Gnosis Safe 的 ProxyFactory 合约的源代码： 12345678910111213141516171819202122contract ProxyFactory &#123; event ProxyCreation(Proxy proxy); /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction. /// @param masterCopy Address of master copy. /// @param data Payload for message call sent to new proxy contract. function createProxy(address masterCopy, bytes memory data) public returns (Proxy proxy) &#123; proxy = new Proxy(masterCopy); if (data.length &gt; 0) // solium-disable-next-line security/no-inline-assembly assembly &#123; if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) &#123; revert(0, 0) &#125; &#125; emit ProxyCreation(proxy); &#125; //省略其他代码 N 行&#125; 这里可以看到新建合约地址使用的new Proxy(masterCopy)，即使用的 CREATE 指令进行创建，合约地址是 msg.sender 以及 nonce 来计算的，由于此时工厂合约地址已经和以太坊主网相同，只需要 nonce 和在以太坊主网上生成多签钱包地址的 nonce 相同，则可完成部署，攻击者通过调用合约 0xe7145dd6287ae53326347f3a6694fcf2954bcd8a 来实现，该合约内部则多次调用 ProxyFactory 合约的createProxy函数，来增加 nonce 值达到该目的： 最后成功将该多签钱包地址部署在 Optimism网络： 总结引发此次安全事件的原因：一是 Wintermute 未验证在侧链是否对其多签钱包地址具有控制权；二是 Solidity 旧版本的漏洞导致使用 CREATE 指令来创建合约地址；三是交易签名未带 CHAIN_ID，不符合 EIP155 标准导致交易可在其他链重放。 参考 2000 万 OP 代币被盗关键：交易重放 重入攻击 + 管理漏洞：2000 万枚 OP 被盗事件分析 交易重放+管理漏洞—2000万枚OP被盗事件分析 2000万OP因何被盗? 来看看链上细节 EIP-155: Simple replay attack protection 深入剖析 Ownbit 和 Gnosis 多签 多签钱包的工作原理与使用方式 CREATE2指令在广义状态通道中的应用介绍","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]},{"title":"闪电贷攻击学习","slug":"闪电贷攻击学习","date":"2022-06-09T08:41:17.000Z","updated":"2023-02-03T05:50:51.569Z","comments":true,"path":"2022/06/09/闪电贷攻击学习/","link":"","permalink":"https://l0s1.github.io/2022/06/09/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"什么是闪电贷闪电贷最早是由 Marble 协议引入的概念，当时是为了让用户可以在以太坊借用 Ether 和 ERC-20 代币，后来由 Aave、dYdX 等进行了普及。 简单来说，闪电贷就是在一个区块交易中，同时完成借款和还款操作这两个操作，无需抵押任何资产，只需支付手续费即可。因为要求借款和还款操作都在一个区块中完成（以太坊平均每个区块时间大概是14秒，币安智能链每个区块时间大约3秒），所以时间非常短，普通人难以操作，一般是专业人员（科学家）使用。 用户在借到款之后，可以利用借到的资产进行其他操作，然后在交易结束的时候，用户只要把借到的款项及手续费及时归还就可以，否则该笔交易就会回滚，就像什么也没有发生过一样。 闪电贷的作用闪电贷作用大致有以下： 套利。比如在两个不同DEX（中心化交易平台）之间ETH价格是有差异的，在A平台 ETH: DAI&#x3D;1: 2700，在B平台上1：2750，那么，这个时候可以去AAVE里面借入2700DAI，在A平台买入1个ETH，在B平台以2750的价格卖出ETH，然后还掉2700DAI，净赚50DAI。 自我清算。比如你在去中心化平台抵押的一笔ETH即将到达清算点，在清算之后你要付一大笔清算费（一般是5-8%左右），这个时候你可以借一笔闪电贷，归还所贷资产，然后将平台抵押的ETH取出，用ETH换成相应的DAI或其他资产归还闪电贷，此时只需要付0.09%的闪电贷手续费而已（AAVE平台闪电贷手续费0.09%，每个平台手续费不一样）。 更换抵押物。比如你在借代平台上抵押的是ETH，你想把抵押物换成USDC，这个时候你可以用闪电贷借一笔DAI，用DAI换成USDC，然后抵押进去，随后将ETH取出，换成DAI，归还闪电贷所借DAI即可。 迁移资产或债务。比如我在A平台上面有抵押ETH借出BNB，这个时候我感觉A平台有一些风险，所以想把整个借代迁移到B平台上，我可以在AAVE用闪电贷借一笔DAI，把DAI换成BNB，在A平台归还之后取出ETH，然后将ETH抵押到B平台借出相同数量的BNB，然后将BNB换成DAI归还闪电贷，在不挪动原来借出来的BNB的基础上完成了不同平台资产和债务的转移。 当然还存在更多的应用场景。 闪电贷项目主流的几个闪电贷项目，主要为Aave，Uniswap，dYdX。 Aave。Aave 是一个去中心化的非托管流动性市场协议，用户可以作为存款人或借款人参与其中。存款人向市场提供流动性以赚取被动收入，而借款人能够以超额抵押（永久）或抵押不足（单块流动性）的方式借款。 其中Aave V3 为闪电贷提供了两种选择： flahsLoan。允许借款人在单次闪贷交易中获得多个准备金的流动性。 flahsLoanSimple。允许借款人为交易获取单一准备金的流动性。 ​ 流程大概为实现 IFlashLoanSimpleReceiver.sol 或者 IFlashLoanReceiver.sol 中的 executeOperation 函数，该函数用来利用闪电贷，然后再调用flahsLoan函数或者 flahsLoanSimple 函数，传入相应的参数即可。executeOperation函数在flashLoan函数成功执行后被内部调用。其中Aave的手续费用为0.09%。 Uniswap。Uniswap 作为 DeFi 中最受欢迎的去中心化交易所之一，从V2版本开始支持闪电贷（Flash Swaps）功能，该功能通过调用UniswapV2pair 合约实例的 swap 方法带入额外 data 实现。手续费为0.3%。 dYdX。dYdX 是一个针对专业交易者的去中心化交易所，本身并没有闪电贷功能，但是可以通过对 SoloMargin 合约执行一系列操作来实现类似闪电贷功能。其主要原理是通过继承 DydxFlashloanBase 合约编写initiateFlashLoan 回调 callFunction 实现借贷、套利、还款等操作。手续费 2 Wei。 闪电贷攻击闪电贷本身的存在是没有漏洞的，但闪电贷可以在短时间内获取到大量资金，黑客将闪电贷和其他漏洞进行结合，进行价格操控、套利。其中其他漏洞一般是合约逻辑存在问题导致黑客可以进行价格操控，或者是存在重入漏洞。以下是学习的闪电贷攻击实例。 Grim Finance 被黑事件问题出在Grim Finance vault 的depositFor函数上： 123456789101112131415function depositFor(address token, uint _amount,address user ) public &#123; uint256 _pool = balance(); IERC20(token).safeTransferFrom(msg.sender, address(this), _amount); earn(); uint256 _after = balance(); _amount = _after.sub(_pool); // Additional check for deflationary tokens uint256 shares = 0; if (totalSupply() == 0) &#123; shares = _amount; &#125; else &#123; shares = (_amount.mul(totalSupply())).div(_pool); &#125; _mint(user, shares); &#125; 其中由用户传入的token参数未做过滤，导致第四行调用的safeTransferFrom函数可被用户控制，攻击者传入自己的部署的恶意合约的地址，并在恶意合约的safeTransferFrom函数中调用depositFor，以此造成重入攻击。 其中在调用safeTransferFrom前计算了一次balance，在调用后又计算了一次balance，其差值amount为用户传入的代币数，那么攻击者只需要在最后一次重入的时候传入真实代币，当最后一次重入完成，after变成了充值后的余额，那么前面重入的amount也将改变，攻击者实现了充值一次当充值N次的目的。 大概的攻击合约伪代码如下： 1234567891011contract Attack &#123; uint times = 0; function safeTransferFrom(address token, uint _amount,address user) public &#123; if(times &lt; 4)&#123; times ++; GrimBoostVault.depositFor(address(this), 0, attackaddress); &#125; else&#123; GrimBoostVault.depositFor(SLPToken, 200, attackaddress); &#125; &#125;&#125; Wault Finance 被黑事件问题出在WUSDMaster合约中的staking函数： 123456789101112131415161718192021function stake(uint256 amount) external nonReentrant &#123; require(amount &lt;= maxStakeAmount, &#x27;amount too high&#x27;); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille &gt; 0) &#123; uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; &#125; uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, 0, swapPath, address(this), block.timestamp ); wusd.mint(msg.sender, amount); emit Stake(msg.sender, amount); &#125; 该质押函数一比一质押USDT获得WUSD，同时还会进行swap操作，调用wswapRouter的swapExactTokensForTokensSupportingFeeOnTransferTokens，将质押一部分的 USDT 换成 WEX，这样就会使得 WaultSwapPair (BSC_USDT-WEX) 池子的 WEX 数量减少，价值变高，在多次调用stake函数后，WEX价格上涨，攻击者再将之前通过redeem和利用USDT兑换的WEX在USDT-WEX池中卖出，换取更多的WEX，完成套利。 防御1、合理设计经济模型。 2、使用去中心化预言机获取价格。 3、对关键函数建立完备的访问控制机制。 参考 科普 | 无抵押借巨资的闪电贷是什么？缘何频频成为DeFi暴雷帮凶？ 揭开闪电贷的神秘面纱 Flash Loans 这波很 “严峻” – Grim Finance 被黑细节分析 外部调用的不可控因素之 Grim Finance 被黑分析 又一经典的闪电贷套利 —— Wault.Finance 被黑事件分析","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://l0s1.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]}],"categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"BlockChain","slug":"BlockChain","permalink":"https://l0s1.github.io/categories/BlockChain/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://l0s1.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Security Events Learn","slug":"Security-Events-Learn","permalink":"https://l0s1.github.io/tags/Security-Events-Learn/"},{"name":"安全事件学习","slug":"安全事件学习","permalink":"https://l0s1.github.io/tags/%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"}]}