{"meta":{"title":"Nian's Blog","subtitle":"","description":"Blog","author":null,"url":"https://l0s1.github.io","root":"/"},"pages":[{"title":"tags","date":"2022-06-08T09:20:01.000Z","updated":"2022-06-09T02:56:45.983Z","comments":true,"path":"tags/index.html","permalink":"https://l0s1.github.io/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-06-08T09:22:55.000Z","updated":"2022-06-09T02:56:29.687Z","comments":true,"path":"categories/index.html","permalink":"https://l0s1.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"闪电贷攻击学习","slug":"闪电贷攻击学习","date":"2022-06-09T08:41:17.000Z","updated":"2022-06-09T08:42:09.628Z","comments":true,"path":"2022/06/09/闪电贷攻击学习/","link":"","permalink":"https://l0s1.github.io/2022/06/09/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"什么是闪电贷闪电贷最早是由 Marble 协议引入的概念，当时是为了让用户可以在以太坊借用 Ether 和 ERC-20 代币，后来由 Aave、dYdX 等进行了普及。 简单来说，闪电贷就是在一个区块交易中，同时完成借款和还款操作这两个操作，无需抵押任何资产，只需支付手续费即可。因为要求借款和还款操作都在一个区块中完成（以太坊平均每个区块时间大概是14秒，币安智能链每个区块时间大约3秒），所以时间非常短，普通人难以操作，一般是专业人员（科学家）使用。 用户在借到款之后，可以利用借到的资产进行其他操作，然后在交易结束的时候，用户只要把借到的款项及手续费及时归还就可以，否则该笔交易就会回滚，就像什么也没有发生过一样。 闪电贷的作用闪电贷作用大致有以下： 套利。比如在两个不同DEX（中心化交易平台）之间ETH价格是有差异的，在A平台 ETH: DAI&#x3D;1: 2700，在B平台上1：2750，那么，这个时候可以去AAVE里面借入2700DAI，在A平台买入1个ETH，在B平台以2750的价格卖出ETH，然后还掉2700DAI，净赚50DAI。 自我清算。比如你在去中心化平台抵押的一笔ETH即将到达清算点，在清算之后你要付一大笔清算费（一般是5-8%左右），这个时候你可以借一笔闪电贷，归还所贷资产，然后将平台抵押的ETH取出，用ETH换成相应的DAI或其他资产归还闪电贷，此时只需要付0.09%的闪电贷手续费而已（AAVE平台闪电贷手续费0.09%，每个平台手续费不一样）。 更换抵押物。比如你在借代平台上抵押的是ETH，你想把抵押物换成USDC，这个时候你可以用闪电贷借一笔DAI，用DAI换成USDC，然后抵押进去，随后将ETH取出，换成DAI，归还闪电贷所借DAI即可。 迁移资产或债务。比如我在A平台上面有抵押ETH借出BNB，这个时候我感觉A平台有一些风险，所以想把整个借代迁移到B平台上，我可以在AAVE用闪电贷借一笔DAI，把DAI换成BNB，在A平台归还之后取出ETH，然后将ETH抵押到B平台借出相同数量的BNB，然后将BNB换成DAI归还闪电贷，在不挪动原来借出来的BNB的基础上完成了不同平台资产和债务的转移。 当然还存在更多的应用场景。 闪电贷项目主流的几个闪电贷项目，主要为Aave，Uniswap，dYdX。 Aave。Aave 是一个去中心化的非托管流动性市场协议，用户可以作为存款人或借款人参与其中。存款人向市场提供流动性以赚取被动收入，而借款人能够以超额抵押（永久）或抵押不足（单块流动性）的方式借款。 其中Aave V3 为闪电贷提供了两种选择： flahsLoan。允许借款人在单次闪贷交易中获得多个准备金的流动性。 flahsLoanSimple。允许借款人为交易获取单一准备金的流动性。 ​ 流程大概为实现IFlashLoanSimpleReceiver.sol或者IFlashLoanReceiver.sol中 的executeOperation函数，该函数用来利用闪电贷，然后再调用flahsLoan函数 或者flahsLoanSimple函数，传入相应的参数即可。 ​ executeOperation函数在flashLoan函数成功执行后被内部调用。 ​ 其中Aave的手续费用为0.09%。 Uniswap。Uniswap 作为 DeFi 中最受欢迎的去中心化交易所之一，从V2版本开始支持闪电贷（Flash Swaps）功能，该功能通过调用UniswapV2pair 合约实例的 swap 方法带入额外 data 实现。手续费为0.3%。 dYdX。dYdX 是一个针对专业交易者的去中心化交易所，本身并没有闪电贷功能，但是可以通过对 SoloMargin 合约执行一系列操作来实现类似闪电贷功能。其主要原理是通过继承 DydxFlashloanBase 合约编写initiateFlashLoan 回调 callFunction 实现借贷、套利、还款等操作。手续费 2 Wei。 闪电贷攻击闪电贷本身的存在是没有漏洞的，但闪电贷可以在短时间内获取到大量资金，黑客将闪电贷和其他漏洞进行结合，进行价格操控、套利。其中其他漏洞一般是合约逻辑存在问题导致黑客可以进行价格操控，或者是存在重入漏洞。以下是学习的闪电贷攻击实例。 Grim Finance 被黑事件问题出在Grim Finance vault 的depositFor函数上： 123456789101112131415function depositFor(address token, uint _amount,address user ) public &#123; uint256 _pool = balance(); IERC20(token).safeTransferFrom(msg.sender, address(this), _amount); earn(); uint256 _after = balance(); _amount = _after.sub(_pool); // Additional check for deflationary tokens uint256 shares = 0; if (totalSupply() == 0) &#123; shares = _amount; &#125; else &#123; shares = (_amount.mul(totalSupply())).div(_pool); &#125; _mint(user, shares); &#125; 其中由用户传入的token参数未做过滤，导致第四行调用的safeTransferFrom函数可被用户控制，攻击者传入自己的部署的恶意合约的地址，并在恶意合约的safeTransferFrom函数中调用depositFor，以此造成重入攻击。 其中在调用safeTransferFrom前计算了一次balance，在调用后又计算了一次balance，其差值amount为用户传入的代币数，那么攻击者只需要在最后一次重入的时候传入真实代币，当最后一次重入完成，after变成了充值后的余额，那么前面重入的amount也将改变，攻击者实现了充值一次当充值N次的目的。 大概的伪代码如下： 1234567891011contract Attack &#123; uint times = 0; function safeTransferFrom(address token, uint _amount,address user) public &#123; if(times &lt; 4)&#123; times ++; GrimBoostVault.depositFor(address(this), 0, attackaddress); &#125; else&#123; GrimBoostVault.depositFor(SLPToken, 200, attackaddress); &#125; &#125;&#125; Wault Finance 被黑事件问题出在WUSDMaster合约中的staking函数： 123456789101112131415161718192021function stake(uint256 amount) external nonReentrant &#123; require(amount &lt;= maxStakeAmount, &#x27;amount too high&#x27;); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille &gt; 0) &#123; uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; &#125; uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, 0, swapPath, address(this), block.timestamp ); wusd.mint(msg.sender, amount); emit Stake(msg.sender, amount); &#125; 该质押函数一比一质押USDT获得WUSD，同时还会进行swap操作，调用wswapRouter的swapExactTokensForTokensSupportingFeeOnTransferTokens，将质押一部分的 USDT 换成 WEX，这样就会使得 WaultSwapPair (BSC_USDT-WEX) 池子的 WEX 数量减少，价值变高，在多次调用stake函数后，WEX价格上涨，攻击者再将之前通过redeem和利用USDT兑换的WEX在USDT-WEX池中卖出，换取更多的WEX，完成套利。 防御1、合理设计经济模型。 2、使用去中心化预言机获取价格。 3、未对关键函数建立完备的访问控制机制。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"闪电贷","slug":"闪电贷","permalink":"https://l0s1.github.io/tags/%E9%97%AA%E7%94%B5%E8%B4%B7/"}]}],"categories":[{"name":"区块链","slug":"区块链","permalink":"https://l0s1.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"闪电贷","slug":"闪电贷","permalink":"https://l0s1.github.io/tags/%E9%97%AA%E7%94%B5%E8%B4%B7/"}]}