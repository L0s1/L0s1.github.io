<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ElasticSwap攻击事件分析</title>
      <link href="/2022/12/19/ElasticSwap%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2022/12/19/ElasticSwap%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>2022年12月14日，ElasticSwap 项目遭到黑客攻击，在以太坊上的 AMPL-USDC 池子被盗，黑客获利445个 ETH。发生该事件的根本原因是合约中添加流动性和移除流动性两个操作使用的是两种不同数据源。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>攻击交易哈希：</p><p><a href="https://etherscan.io/tx/0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f">https://etherscan.io/tx/0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f</a></p><p>首先攻击者调用 approve 进行授权，然后在 Uniswap V2 的 WETH-AMPL、USDC-USDT 池子调用闪电贷借出  AMPL 和 USDC:</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191805085.png" alt="image-20221219180551047"></p><p>然后第二次回调 uniswapV2Call 时候开始进攻攻击。</p><p>首先向 AMPL-USDC-ELATICSWAP 池子中添加两次流动性，第一次添加只转入了 AMPL，第二次添加转入了 AMPL 和 USDC ：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191807575.png" alt="image-20221219180711548"></p><p>然后攻击者调用 transfer 方法向池子中转入 USDC，增加 baseTokenReserveQty 的值，然后再移除流动性：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191808838.png" alt="image-20221219180857807"></p><p>这里攻击者 AMPL 以及 USDC 都没有回本，尤其是 AMPL，所以攻击者先将部分的 USDC 换成了 AMPL，使得能够归还闪电贷，然后再进行添加&#x2F;移除流动性操作，继续套利：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191810785.png" alt="image-20221219181023753"></p><p>在进行了以上的操作后攻击者已经成功获利，然后攻击者开始归还闪电贷，在二层回调归还 USDC，一层回调归还 AMPL：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191812259.png" alt="image-20221219181250211"></p><p>最后攻击者将获得的 AMPL 以及 USDC 全部换成 ETH，然后转移：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191813297.png" alt="image-20221219181330257"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>由上面的事件分析可以看到异常点位于添加&#x2F;移除流动性时，首先查看 Exchange 合约(类似Uinswap 的 Pair 合约)的 addLiquidity 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function addLiquidity(</span><br><span class="line">        uint256 _baseTokenQtyDesired,</span><br><span class="line">        uint256 _quoteTokenQtyDesired,</span><br><span class="line">        uint256 _baseTokenQtyMin,</span><br><span class="line">        uint256 _quoteTokenQtyMin,</span><br><span class="line">        address _liquidityTokenRecipient,</span><br><span class="line">        uint256 _expirationTimestamp</span><br><span class="line">    ) external nonReentrant() isNotExpired(_expirationTimestamp) &#123;</span><br><span class="line">        uint256 totalSupply = this.totalSupply();</span><br><span class="line">        MathLib.TokenQtys memory tokenQtys =</span><br><span class="line">            MathLib.calculateAddLiquidityQuantities(</span><br><span class="line">                _baseTokenQtyDesired,</span><br><span class="line">                _quoteTokenQtyDesired,</span><br><span class="line">                _baseTokenQtyMin,</span><br><span class="line">                _quoteTokenQtyMin,</span><br><span class="line">                IERC20(baseToken).balanceOf(address(this)),</span><br><span class="line">                totalSupply,</span><br><span class="line">                internalBalances</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">         _mint(_liquidityTokenRecipient, tokenQtys.liquidityTokenQty); // mint liquidity tokens to recipient</span><br></pre></td></tr></table></figure><p>可以看到关键点在 MathLib.calculateAddLiquidityQuantities 这个函数，找到这个函数的关键代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">function calculateAddLiquidityQuantities(</span><br><span class="line">        uint256 _baseTokenQtyDesired,</span><br><span class="line">        uint256 _quoteTokenQtyDesired,</span><br><span class="line">        uint256 _baseTokenQtyMin,</span><br><span class="line">        uint256 _quoteTokenQtyMin,</span><br><span class="line">        uint256 _baseTokenReserveQty,</span><br><span class="line">        uint256 _totalSupplyOfLiquidityTokens,</span><br><span class="line">        InternalBalances storage _internalBalances</span><br><span class="line">    ) public returns (TokenQtys memory tokenQtys) &#123;</span><br><span class="line">    if (</span><br><span class="line">                    quoteTokenQtyFromDecay &lt; _quoteTokenQtyDesired &amp;&amp;</span><br><span class="line">                    baseTokenQtyFromDecay &lt; _baseTokenQtyDesired</span><br><span class="line">                ) &#123;</span><br><span class="line">                    // the user still has qty that they desire to contribute to the exchange for liquidity</span><br><span class="line">                    (</span><br><span class="line">                        tokenQtys.baseTokenQty,</span><br><span class="line">                        tokenQtys.quoteTokenQty,</span><br><span class="line">                        tokenQtys.liquidityTokenQty</span><br><span class="line">                    ) = calculateAddTokenPairLiquidityQuantities(</span><br><span class="line">                        _baseTokenQtyDesired - baseTokenQtyFromDecay, // safe from underflow quoted on above IF</span><br><span class="line">                        _quoteTokenQtyDesired - quoteTokenQtyFromDecay, // safe from underflow quoted on above IF</span><br><span class="line">                        0, // we will check minimums below</span><br><span class="line">                        0, // we will check minimums below</span><br><span class="line">                        _totalSupplyOfLiquidityTokens +</span><br><span class="line">                            liquidityTokenQtyFromDecay,</span><br><span class="line">                        _internalBalances // NOTE: these balances have already been updated when we did the decay math.</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                tokenQtys.baseTokenQty += baseTokenQtyFromDecay;</span><br><span class="line">                tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay;</span><br><span class="line">                tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay;</span><br><span class="line"></span><br><span class="line">                require(</span><br><span class="line">                    tokenQtys.baseTokenQty &gt;= _baseTokenQtyMin,</span><br><span class="line">                    &quot;MathLib: INSUFFICIENT_BASE_QTY&quot;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                require(</span><br><span class="line">                    tokenQtys.quoteTokenQty &gt;= _quoteTokenQtyMin,</span><br><span class="line">                    &quot;MathLib: INSUFFICIENT_QUOTE_QTY&quot;</span><br><span class="line">                );</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // the user is just doing a simple double asset entry / providing both base and quote.</span><br><span class="line">                (</span><br><span class="line">                    tokenQtys.baseTokenQty,</span><br><span class="line">                    tokenQtys.quoteTokenQty,</span><br><span class="line">                    tokenQtys.liquidityTokenQty</span><br><span class="line">                ) = calculateAddTokenPairLiquidityQuantities(</span><br><span class="line">                    _baseTokenQtyDesired,</span><br><span class="line">                    _quoteTokenQtyDesired,</span><br><span class="line">                    _baseTokenQtyMin,</span><br><span class="line">                    _quoteTokenQtyMin,</span><br><span class="line">                    _totalSupplyOfLiquidityTokens,</span><br><span class="line">                    _internalBalances</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>可以看到会调用 calculateAddTokenPairLiquidityQuantities 计算 tokenQtys 中的值。跟进该函数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">function calculateAddTokenPairLiquidityQuantities(</span><br><span class="line">        uint256 _baseTokenQtyDesired,</span><br><span class="line">        uint256 _quoteTokenQtyDesired,</span><br><span class="line">        uint256 _baseTokenQtyMin,</span><br><span class="line">        uint256 _quoteTokenQtyMin,</span><br><span class="line">        uint256 _totalSupplyOfLiquidityTokens,</span><br><span class="line">        InternalBalances storage _internalBalances</span><br><span class="line">    )</span><br><span class="line">        public</span><br><span class="line">        returns (</span><br><span class="line">            uint256 baseTokenQty,</span><br><span class="line">            uint256 quoteTokenQty,</span><br><span class="line">            uint256 liquidityTokenQty</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 requiredQuoteTokenQty =</span><br><span class="line">            calculateQty(</span><br><span class="line">                _baseTokenQtyDesired,</span><br><span class="line">                _internalBalances.baseTokenReserveQty,</span><br><span class="line">                _internalBalances.quoteTokenReserveQty</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        if (requiredQuoteTokenQty &lt;= _quoteTokenQtyDesired) &#123;</span><br><span class="line">            // user has to provide less than their desired amount</span><br><span class="line">            require(</span><br><span class="line">                requiredQuoteTokenQty &gt;= _quoteTokenQtyMin,</span><br><span class="line">                &quot;MathLib: INSUFFICIENT_QUOTE_QTY&quot;</span><br><span class="line">            );</span><br><span class="line">            baseTokenQty = _baseTokenQtyDesired;</span><br><span class="line">            quoteTokenQty = requiredQuoteTokenQty;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // we need to check the opposite way.</span><br><span class="line">            uint256 requiredBaseTokenQty =</span><br><span class="line">                calculateQty(</span><br><span class="line">                    _quoteTokenQtyDesired,</span><br><span class="line">                    _internalBalances.quoteTokenReserveQty,</span><br><span class="line">                    _internalBalances.baseTokenReserveQty</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">            require(</span><br><span class="line">                requiredBaseTokenQty &gt;= _baseTokenQtyMin,</span><br><span class="line">                &quot;MathLib: INSUFFICIENT_BASE_QTY&quot;</span><br><span class="line">            );</span><br><span class="line">            baseTokenQty = requiredBaseTokenQty;</span><br><span class="line">            quoteTokenQty = _quoteTokenQtyDesired;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(</span><br><span class="line">            _totalSupplyOfLiquidityTokens,</span><br><span class="line">            quoteTokenQty,</span><br><span class="line">            _internalBalances.quoteTokenReserveQty</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        _internalBalances.baseTokenReserveQty += baseTokenQty;</span><br><span class="line">        _internalBalances.quoteTokenReserveQty += quoteTokenQty;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>计算 liquidityTokenQty 使用的函数 calculateLiquidityTokenQtyForDoubleAssetEntry，跟进该函数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function calculateLiquidityTokenQtyForDoubleAssetEntry(</span><br><span class="line">        uint256 _totalSupplyOfLiquidityTokens,</span><br><span class="line">        uint256 _quoteTokenQty,</span><br><span class="line">        uint256 _quoteTokenReserveBalance</span><br><span class="line">    ) public pure returns (uint256 liquidityTokenQty) &#123;</span><br><span class="line">        liquidityTokenQty =</span><br><span class="line">            (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /</span><br><span class="line">            _quoteTokenReserveBalance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里可以发现计算 liquidityTokenQty 使用的 <code>_quoteTokenReserveBalance</code>，该值来自_internalBalances.quoteTokenReserveQty，因此添加流动性这个操作使用的 internalBalances 的数据。</p><p>再看移除流动性函数 removeLiquidity 的代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">function removeLiquidity(</span><br><span class="line">        uint256 _liquidityTokenQty,</span><br><span class="line">        uint256 _baseTokenQtyMin,</span><br><span class="line">        uint256 _quoteTokenQtyMin,</span><br><span class="line">        address _tokenRecipient,</span><br><span class="line">        uint256 _expirationTimestamp</span><br><span class="line">    ) external nonReentrant() isNotExpired(_expirationTimestamp) &#123;</span><br><span class="line">        require(this.totalSupply() != 0, &quot;Exchange: INSUFFICIENT_LIQUIDITY&quot;);</span><br><span class="line">        require(</span><br><span class="line">            _baseTokenQtyMin != 0 &amp;&amp; _quoteTokenQtyMin != 0,</span><br><span class="line">            &quot;Exchange: MINS_MUST_BE_GREATER_THAN_ZERO&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        uint256 baseTokenReserveQty =</span><br><span class="line">            IERC20(baseToken).balanceOf(address(this));</span><br><span class="line">        uint256 quoteTokenReserveQty =</span><br><span class="line">            IERC20(quoteToken).balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">        uint256 totalSupplyOfLiquidityTokens = this.totalSupply();</span><br><span class="line">        // calculate any DAO fees here.</span><br><span class="line">        uint256 liquidityTokenFeeQty =</span><br><span class="line">            MathLib.calculateLiquidityTokenFees(</span><br><span class="line">                totalSupplyOfLiquidityTokens,</span><br><span class="line">                internalBalances</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        // we need to factor this quantity in to any total supply before redemption</span><br><span class="line">        totalSupplyOfLiquidityTokens += liquidityTokenFeeQty;</span><br><span class="line"></span><br><span class="line">        uint256 baseTokenQtyToReturn =</span><br><span class="line">            (_liquidityTokenQty * baseTokenReserveQty) /</span><br><span class="line">                totalSupplyOfLiquidityTokens;</span><br><span class="line">        uint256 quoteTokenQtyToReturn =</span><br><span class="line">            (_liquidityTokenQty * quoteTokenReserveQty) /</span><br><span class="line">                totalSupplyOfLiquidityTokens;</span><br><span class="line"></span><br><span class="line">        require(</span><br><span class="line">            baseTokenQtyToReturn &gt;= _baseTokenQtyMin,</span><br><span class="line">            &quot;Exchange: INSUFFICIENT_BASE_QTY&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        require(</span><br><span class="line">            quoteTokenQtyToReturn &gt;= _quoteTokenQtyMin,</span><br><span class="line">            &quot;Exchange: INSUFFICIENT_QUOTE_QTY&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // this ensures that we are removing the equivalent amount of decay</span><br><span class="line">        // when this person exits.</span><br><span class="line">        &#123;</span><br><span class="line">            //scoping to avoid stack too deep errors</span><br><span class="line">            uint256 internalBaseTokenReserveQty =</span><br><span class="line">                internalBalances.baseTokenReserveQty;</span><br><span class="line">            uint256 baseTokenQtyToRemoveFromInternalAccounting =</span><br><span class="line">                (_liquidityTokenQty * internalBaseTokenReserveQty) /</span><br><span class="line">                    totalSupplyOfLiquidityTokens;</span><br><span class="line"></span><br><span class="line">            internalBalances.baseTokenReserveQty = internalBaseTokenReserveQty =</span><br><span class="line">                internalBaseTokenReserveQty -</span><br><span class="line">                baseTokenQtyToRemoveFromInternalAccounting;</span><br><span class="line"></span><br><span class="line">            // We should ensure no possible overflow here.</span><br><span class="line">            uint256 internalQuoteTokenReserveQty =</span><br><span class="line">                internalBalances.quoteTokenReserveQty;</span><br><span class="line">            if (quoteTokenQtyToReturn &gt; internalQuoteTokenReserveQty) &#123;</span><br><span class="line">                internalBalances</span><br><span class="line">                    .quoteTokenReserveQty = internalQuoteTokenReserveQty = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                internalBalances</span><br><span class="line">                    .quoteTokenReserveQty = internalQuoteTokenReserveQty =</span><br><span class="line">                    internalQuoteTokenReserveQty -</span><br><span class="line">                    quoteTokenQtyToReturn;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            internalBalances.kLast =</span><br><span class="line">                internalBaseTokenReserveQty *</span><br><span class="line">                internalQuoteTokenReserveQty;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (liquidityTokenFeeQty != 0) &#123;</span><br><span class="line">            _mint(</span><br><span class="line">                IExchangeFactory(exchangeFactoryAddress).feeAddress(),</span><br><span class="line">                liquidityTokenFeeQty</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _burn(msg.sender, _liquidityTokenQty);</span><br><span class="line">        IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);</span><br><span class="line">        IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);</span><br><span class="line">        emit RemoveLiquidity(</span><br><span class="line">            msg.sender,</span><br><span class="line">            baseTokenQtyToReturn,</span><br><span class="line">            quoteTokenQtyToReturn</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关键的部分代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint256 baseTokenReserveQty =</span><br><span class="line">    IERC20(baseToken).balanceOf(address(this));</span><br><span class="line">uint256 quoteTokenReserveQty =</span><br><span class="line">    IERC20(quoteToken).balanceOf(address(this));</span><br><span class="line">uint256 baseTokenQtyToReturn =</span><br><span class="line">    (_liquidityTokenQty * baseTokenReserveQty) /</span><br><span class="line">        totalSupplyOfLiquidityTokens;</span><br><span class="line">uint256 quoteTokenQtyToReturn =</span><br><span class="line">    (_liquidityTokenQty * quoteTokenReserveQty) /</span><br><span class="line">        totalSupplyOfLiquidityTokens;</span><br><span class="line">_burn(msg.sender, _liquidityTokenQty);</span><br><span class="line">IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);</span><br><span class="line">IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);</span><br></pre></td></tr></table></figure><p>可以看到池子储量代币量使用的 balanceOf(address(this)) 数据，用户移除流动性获得的代币为：用户的流动性 * 池子储量 &#x2F; 总的流动性。</p><p>添加流动性时使用的 internalBalabnces 数据，而移除流动性时使用的 balanceOf(address(this)) 数据。</p><p>因此添加流动性后，往池子内转入相应的代币，然后再移除流动性，此时计算的 quoteTokenReserveQty 则会变大，因此用户获得的代币也会相应变大。</p><p>正常移除流动性所得：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liquidity * Reserve / totalliquidity;</span><br></pre></td></tr></table></figure><p>往池子内转入代币后再移除流动性所得：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liquidity * (Reserve + Tansfer) / totalliquidity;</span><br></pre></td></tr></table></figure><p>那么多获得的数量为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liquidity * Tansfer / totalliquidity</span><br></pre></td></tr></table></figure><p>再减去转入的代币后计算出一次添加&#x2F;移除流动性的获利：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liquidity * Tansfer / totalliquidity - Transfer = （（liquidity / totalliquidity）-1）* Transfer</span><br></pre></td></tr></table></figure><p>由于<code>liquidity / totalliquidity</code> 是肯定小于1的，因此如果只是添加&#x2F;移除流动性一次的话是无法获利的，但是我们可以通过多次的添加&#x2F;移除流动性操作来完成获利，因为池子没有方法来平衡 internalBalances 和 balancesOf(address(this))，转入池子的代币会让这两个变量一直存在差值。所以我们只要保证 <code>(liquidity / totalliquidity) * N &gt; 1</code> 即可获利，N 为添加&#x2F;移除流动性操作的次数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>合约中添加流动性和移除流动性使用的数据源不同导致了这次的攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NimbusPlatform攻击事件分析</title>
      <link href="/2022/12/19/NimbusPlatform%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2022/12/19/NimbusPlatform%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>2022年12月24日，BSC 链上的 NimbusPlatform 项目遭到攻击，损失大约278个  BNB。遭受攻击的根本原因是其质押合约使用的预言机存在缺陷，可以被操控。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>攻击交易哈希：</p><p><a href="https://bscscan.com/tx/0x42f56d3e86fb47e1edffa59222b33b73e7407d4b5bb05e23b83cb1771790f6c1">https://bscscan.com/tx/0x42f56d3e86fb47e1edffa59222b33b73e7407d4b5bb05e23b83cb1771790f6c1</a></p><p>首先攻击者从三个池子中闪电贷出 WBNB 共计75477个，分别是 DODO、Biswap-WBNB-BUSD、 Biswap-USDT-WBNB，并全部将其兑换成 NBU_WBNB :</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191506846.png" alt="image-20221219150608781"></p><p>然后给 NimbusRouter 授权，调用 swapExactTokensForTokensSupportingFeeOnTransferTokens 将 NBU_WBNB 兑换成 NIMB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191517099.png" alt="image-20221219151728055"></p><p>然后调用 0xe166a1d4b551db58c80ad3de194a01ec20d9c47d 合约的 0xa66edba2 方法，该方法调用 StakingRewardFixedAPY.getReward，获取GNIMB，然后再调用 0xe166a1d4b551db58c80ad3de194a01ec20d9c47d 的 0x484e4699 方法，该方法调用 StakingRewardFixedAPY.withdraw，提出 GNIMB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191529024.png" alt="image-20221219152859985"></p><p>然后攻击者调用其他两个攻击合约的方法，利用相同的方法，从质押池中提取奖励 GNIMB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191532011.png" alt="image-20221219153204972"></p><p>到这里攻击者提取奖励阶段完成了，接下来就是将各个池子掏空。</p><p>首先在 Biswap-NBU_WBNB-NIMB 池子中将NIMB兑换成 NBU_WBNB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191602221.png" alt="image-20221219160206190"></p><p>然后攻击者多次调用 NimbusRouter.getAmountsOut 方法，寻找兑换 NBU_WBNB 最多的方式：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191606878.png" alt="image-20221219160606842"></p><p>接着在 Biswap-GNIMB-NIMB 池子中将部分 GNIMB 兑换成 NIMB，然后将兑换的 NIMB 在 Biswap-NBU_WBNB-NIMB 池子中兑换成 NBU_WBNB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191611995.png" alt="image-20221219161151952"></p><p>最后将剩下的 GNIMB 在Biswap-GNIMB-NBU_WBNB 池子中兑换成 NBU_WBNB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191613032.png" alt="image-20221219161348986"></p><p>最后将 NBU_WBNB 兑换成 BNB，再将 BNB 换成 WBNB，归还闪电贷，转移攻击获利：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191618075.png" alt="image-20221219161817037"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>通过上面的攻击步骤能发现异常点在攻击者提取奖励时，攻击者每次提取奖励都能够提取巨量的奖励，我们找到 StakingRewardFixedAPY 合约的 getReward 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getReward() public override nonReentrant whenNotPaused &#123;</span><br><span class="line">        uint256 reward = earned(msg.sender);</span><br><span class="line">        if (reward &gt; 0) &#123;</span><br><span class="line">            for (uint256 i = 0; i &lt; stakeNonces[msg.sender]; i++) &#123;</span><br><span class="line">                stakeNonceInfos[msg.sender][i].stakeTime = block.timestamp;</span><br><span class="line">            &#125;</span><br><span class="line">            rewardsPaymentToken.safeTransfer(msg.sender, reward);</span><br><span class="line">            emit RewardPaid(msg.sender, address(rewardsPaymentToken), reward);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>奖励的数量由 earned 方法计算，找到 earned 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function earned(address account) public view override returns (uint256 totalEarned) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; stakeNonces[account]; i++) &#123;</span><br><span class="line">            totalEarned += earnedByNonce(account, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>OK，继续套娃，找到 earnedByNonce 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function earnedByNonce(address account, uint256 nonce) public view returns (uint256) &#123;</span><br><span class="line">        uint256 amount = stakeNonceInfos[account][nonce].rewardsTokenAmount * </span><br><span class="line">            (block.timestamp - stakeNonceInfos[account][nonce].stakeTime) *</span><br><span class="line">             stakeNonceInfos[account][nonce].rewardRate / (100 * rewardDuration);</span><br><span class="line">        return getTokenAmountForToken(address(rewardsToken), address(rewardsPaymentToken), amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 amount 取决于质押的数量以及时间以及 rewardRate 变量，该变量在合约构造函数中初始化，因此 amount 攻击者无法操控，继续看 getTokenAmountForToken 方法，其中 tokenSrc 是 NIMB，tokenDest 是 GNIMB ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getTokenAmountForToken(address tokenSrc, address tokenDest, uint256 tokenAmount) public view returns (uint) &#123; </span><br><span class="line">        if (tokenSrc == tokenDest) return tokenAmount;</span><br><span class="line">        if (usePriceFeeds &amp;&amp; address(priceFeed) != address(0)) &#123;</span><br><span class="line">            (uint256 rate, uint256 precision) = priceFeed.queryRate(tokenSrc, tokenDest);</span><br><span class="line">            return tokenAmount * rate / precision;</span><br><span class="line">        &#125; </span><br><span class="line">        address[] memory path = new address[](2);</span><br><span class="line">        path[0] = tokenSrc;</span><br><span class="line">        path[1] = tokenDest;</span><br><span class="line">        return swapRouter.getAmountsOut(tokenAmount, path)[1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里如果不使用 priceFeed 则返回 getAmountsOut 的值，如果使用 priceFeed 则调用 priceFeed的 queryRate 方法，并返回 <code>tokenAmount * rate / precision</code> 的值，跟进 queryRate 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function queryRate(</span><br><span class="line">        address sourceToken,</span><br><span class="line">        address destToken)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 rate, uint256 precision)</span><br><span class="line">    &#123;</span><br><span class="line">        require(!globalPricingPaused, &quot;pricing is paused&quot;);</span><br><span class="line">        return _queryRate(</span><br><span class="line">            sourceToken,</span><br><span class="line">            destToken</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续套娃，查看 _queryRate 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function _queryRate(</span><br><span class="line">        address sourceToken,</span><br><span class="line">        address destToken)</span><br><span class="line">        internal</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 rate, uint256 precision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sourceToken != destToken) &#123;</span><br><span class="line">            uint256 sourceRate = _queryRateCall(sourceToken);</span><br><span class="line">            uint256 destRate = _queryRateCall(destToken);</span><br><span class="line"></span><br><span class="line">            rate = sourceRate</span><br><span class="line">                .mul(WEI_PRECISION)</span><br><span class="line">                .div(destRate);</span><br><span class="line"></span><br><span class="line">            precision = _getDecimalPrecision(sourceToken, destToken);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rate = WEI_PRECISION;</span><br><span class="line">            precision = WEI_PRECISION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的 rate 由 sourceRate、destRate相除所得，这俩又由 _queryRateCall 求出，查看该函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function _queryRateCall(</span><br><span class="line">        address token)</span><br><span class="line">        internal</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 rate)</span><br><span class="line">    &#123;</span><br><span class="line">        if (token != address(wbnbToken)) &#123;</span><br><span class="line">            IPriceFeedsExt _Feed = pricesFeeds[token];</span><br><span class="line">            require(address(_Feed) != address(0), &quot;unsupported price feed&quot;);</span><br><span class="line">            rate = uint256(_Feed.latestAnswer());</span><br><span class="line">            require(rate != 0 &amp;&amp; (rate &gt;&gt; 128) == 0, &quot;price error&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rate = WEI_PRECISION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到由 pricesFeeds[token].latestAnswer 求出，找到两种代币对应的 pricesFeeds[token]，然后查看其 latestAnswer 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function latestAnswer() external override view returns (uint256) &#123;</span><br><span class="line">        return swapRouter.getAmountsOut(10 ** decimals, swapPath)[swapPath.length - 1] * multiplier / MULTIPLIER_DEFAULT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到 latestAnswer 方法就是调用 swapRouter 的 getAmountsOut 方法，其中 swapPath 是用两种代币兑换 NBU_WBNB，即 1 个 NIMB 或者 GNIMMB 能兑换多少个 NBU_WBNB。</p><p>那么最终可以得出，PriceFeeds.queryRate方法的值为 Biswap-NBU_WBNB-NIMB 池子中 NIMB 的价格除以 Biswap-GNIMB-NBU_WBNB 池子中 GNIMB的价格。</p><p>攻击者最开始通过闪电贷借入了大量的 WBNB，将其兑换为 NBU_WBNB 并 swap 成 NIMB ，因此  Biswap-NBU_WBNB-NIMB 池子中 NIMB 的价格大幅度上涨，而 GNIMB 的价格不变，因此 queryRate 的返回值变大，攻击者获取质押奖励时也会变多。</p><p>到这里漏洞分析结束。</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>项目方在攻击事件发生后，重新部署了预言机合约，将链上预言机修改成了链下预言机，latestAnswer 方法的值由  owner 设置：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191740800.png" alt="image-20221219174024749"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>质押合约使用的预言机存在缺陷导致了此次漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GenomesDao攻击事件学习</title>
      <link href="/2022/08/08/GenomesDao%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/08/08/GenomesDao%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>UTC 时间2022年8月5日8时，MATIC 链上的项目 GenomesDAO 被攻击，其 LPSTAKING 合约以及 VeGnomeLock 合约中的资金被盗走。事件的主要原因是因为合约中的 <code>initialized</code> 函数可被无限制调用。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>攻击者 EOA 地址：</p><p>0x43EC1D163cc4C15B574F86d8203c3B0F3EbED7a3</p><p>攻击合约：</p><p>0x9aa63491bb927f024d37b0e6017137f7f03da3c6</p><p>0x8e10c9493501a828304d77630b6f862bbf50c052</p><p>0x4a7c088099f744d5c6c838c71502a04e0983f266</p><p>攻击交易哈希：</p><p>0x252a7e6f23ffb516c23df2a3b2e09b42d00a06fa4e9a5830e74fb35581f7632c</p><p>0x82cebaf092bc6a4c9235daeda6a9b504a873844c41dc31c51dbeebbab96a90bf</p><p>首先查看交易 0x252a7e6f23ffb516c23df2a3b2e09b42d00a06fa4e9a5830e74fb35581f7632c ，其首先通过代理合约调用了 <code>LPStakingOnPoly</code> 合约的 <code>initialized</code> 方法，更新了 <code>_stakingToken</code> 的值，修改为攻击者创建的攻击合约的地址：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091117586.png" alt="image-20220809111743544"></p><p>然后调用通过代理合约 <code>LPStakingOnPoly</code> 的 <code>stake</code> 方法，质押数量为 946677946000000000000。由于其 <code>_stakingToken</code> 的值已经被攻击者控制，因此会 stake 虚假的代币，并修改相应的 <code>_balances</code> 的值：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091133094.png" alt="image-202208091133094"></p><p>接下来攻击者再次调用 <code>LPStakingOnPoly</code> 合约的 <code>initialized</code> 方法，将 <code>_stakingToken</code> 的值修改为正常的 <code>SushiSwap LP Token</code> 的地址：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091137779.png" alt="image-20220809113731748"></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091137969.png" alt="image-20220809113751939"></p><p>然后攻击者通过代理合约调用 <code>LPStakingOnPoly</code> 合约的 <code>withdraw</code> 方法，由于 <code>_stakingToken</code> 的值已经变成正常的 <code>SushiSwap LP Token</code> 的地址，因此攻击者提取了 946677946000000000000 数量的 LP：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091143644.png" alt="image-20220809114314607"></p><p>接下来攻击者继续重复上面的步骤，先 <code>initialized</code> 修改为虚假的代币地址，然后再 <code>satke</code> ，接着再 <code>initialized</code> 为真实的代币地址，最后调用 <code>withdraw</code> 提取真实的代币。不同的地方在于修改的真实代币的地址不同。</p><p>改笔交易最后还对 <code>VeGnomeLock</code> 合约进行了攻击，因为使用了一样的 <code>initialized</code> 方法。具体步骤是先  <code>initialized</code> 修改 <code>_lockToken</code> 为虚假代币地址，然后调用 <code>lock</code> 进行锁仓，接着再 <code>initialized</code> 为真实的代币地址，最后调用 <code>emergencyUnlock</code> 方法解除锁仓，提取真实代币。</p><p>攻击者通过以上步骤提取的大量的真实代币：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091157609.png" alt="image-20220809115729565"></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091157044.png" alt="image-20220809115744008"></p><p>然后再看交易 0x82cebaf092bc6a4c9235daeda6a9b504a873844c41dc31c51dbeebbab96a90bf，攻击者将获取到的 <code>LP Token</code> 兑换成相应的代币，最后将 WETH 发送至攻击者的 EOA 地址：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091203033.png" alt="image-20220809120349999"></p><p>后续攻击者通过 anyswap 进行兑换及转移资产：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091215164.png" alt="image-20220809121532123"></p><h2 id="漏洞详解"><a href="#漏洞详解" class="headerlink" title="漏洞详解"></a>漏洞详解</h2><p>漏洞点位于 <code>initialized</code> 方法，该函数可见性为 <code>public</code> ，其位于父合约中，作用就是初始化质押代币的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function initialized(address _stakingToken, string memory _nameArg, string memory _symbolArg) public &#123; </span><br><span class="line">        stakingToken = IERC20(_stakingToken); </span><br><span class="line">        name = _nameArg;</span><br><span class="line">        symbol = _symbolArg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后子合约中存在 <code>initialize</code> 方法，该方法会调用父合约的  <code>initialized</code> 方法，进行初始化操作，且带有修饰器 <code>initializer</code> ，只能够调用一次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function initialize(</span><br><span class="line">        string memory _name,</span><br><span class="line">        string memory _symbol,</span><br><span class="line">        address _stakingToken,</span><br><span class="line">        address _rewardToken,</span><br><span class="line">        address _veToken</span><br><span class="line">    ) public initializer &#123;</span><br><span class="line">        __Ownable_init();</span><br><span class="line">        LPStakingOnPolyWrapper.initialized(</span><br><span class="line">            _stakingToken,</span><br><span class="line">            _name,</span><br><span class="line">            _symbol</span><br><span class="line">        );</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是其并未重写 <code>initialized</code> 方法，并且其可见性为 <code>public</code> ，因此任何人都可以调用该方法。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091225289.png" alt="image-20220809122554246"></p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>将父合约的 <code>initialized</code> 方法的可见性修改为 <code>internal</code> ，或者添加修饰器进行限定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此次攻击事件原理较为简单，在编写合约时务必考虑好各个方法的可见性，防止发生越权。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wormhole赏金漏洞学习</title>
      <link href="/2022/08/08/Wormhole%E8%B5%8F%E9%87%91%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/08/08/Wormhole%E8%B5%8F%E9%87%91%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Wormhole 是一个跨链桥，可以连接到多个链，如 solana、Ethereum、BSC 等。2022年2月24日，名为 satya0x 的白帽子负责任地披露了以太坊上 Wormhole 核心桥接合约的一个严重漏洞，该漏洞和可升级的代理合约有关。Wormhole 向 satya0x 支付了创纪录的 1000 万美元的漏洞赏金（太猛了家人们就是说）。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><p><code>delegatecall</code> 和 <code>call</code></p><p><code>delegatecall</code> 不会修改 <code>msg</code> 中的信息，且会将调用的合约在当前合约中运行（执行环境为当前合约），也就是 storage 使用的当前合约。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208081816926.png" alt="image-20220802131753090"></p><p><code>call</code> 会修改 <code>msg.sender</code> 为当前合约，但是执行环境在调用的目标合约。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208081817047.png" alt="image-20220802160252935"></p></li><li><p>透明代理模式 (TPP) 和通用可升级代理标准 (UUPS)</p><p>通过 <code>delegatecall</code> 的特性，我们可以实现可升级的合约。代理合约除了通过 <code>delegatecall</code> 调用实现合约，其本身也会实现一些方法，如 <code>upgradeTo</code>，如果实现合约中存在同名方法，那如何判断到底调哪个合约的方法呢？</p><p>其中透明代理模式（TPP）是一种解决方式，具体做法是当调用者是代理合约的管理员时，调用的是代理合约的方法；当调用者是其他的用户地址时，通过代理合约调用逻辑合约的方法。在该模式中，如果调用者是代理的管理员，则代理合约不会进行任何 <code>delegatecall </code>调用。</p><p>通用可升级代理标准则（UUPS）是一种新的方式，其和透明代理模式的区别在于，透明代理模式的升级逻辑在代理合约中，而 UUPS 则在实现合约中。</p></li></ul><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>Wormhole采用的代理模式为 UUPS，也就是升级逻辑也存在在实现合约中，项目方只通过代理合约调用了 <code>initialize</code> 方法，未在实现合约中调用该方法，而该方法默认所有人都可调用，因此漏洞攻击的路径如下：</p><ul><li><p>攻击者调用  <code>initialize</code> 方法，初始化 <code>initialGuardians</code> 以及 <code>chainId</code>、<code>governanceChainId</code> 、<code> governanceContract</code> 等参数，其中最重要的参数为 <code>initialGuardians</code>，将其设置为攻击地址。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208081817164.png" alt="image-20220802154631646"></p></li><li><p>攻击者部署 destructor 合约，在其 <code>initialize</code> 方法中实现 destructor。</p></li><li><p>然后调用 <code>submitContractUpgrade</code> 方法，传入的参数为 bytes，其中包含了 timestamp、nonce、chainId、governance.address、destructor.address、attackerSigner.address、guardianSetIndex等。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208081817147.png" alt="image-20220802155520902"></p></li><li><p>当校验传入的 vm， 通过以后，会调用 <code>upgradeImplementation</code> 升级合约。该函数中调用 <code>_upgradeTo</code> 方法去升级合约，同时还会通过 <code>delegatecall</code> 调用新的实现合约的 <code>initialize</code> 方法。由于新的实现合约的 <code>initialize</code> 中会进行 <code>destructor</code> 操作，因此该合约会被毁掉，而代理合约没有任何逻辑实现，只靠 <code>delegatecall</code> 调用该合约，因此代理合约会无法使用。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208081817005.png" alt="image-20220802155835903"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Wormhole 采用 UUPS 的代理模式，但未对实现合约进行初始化导致漏洞产生。</p><p>在使用 UUPS 代理模式时，需要注意实现合约初始化的问题，防止被黑客调用初始化方法获得管理员权限，从而恶意调用更新方法销毁实现合约，锁定代理合约所有资产。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://medium.com/immunefi/wormhole-uninitialized-proxy-bugfix-review-90250c41a43a">Wormhole Uninitialized Proxy Bugfix Review</a></p><p><a href="https://zhuanlan.zhihu.com/p/535263979">跨链桥：Web3黑客必争之地</a></p><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#transparent-vs-uups">Transparent vs UUPS Proxies</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Audius攻击事件学习</title>
      <link href="/2022/07/27/Audius%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/07/27/Audius%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>Web3 音乐平台 Audius 在 UTC 时间2022年7月23日11点遭到攻击，其社区金库中的1850万枚 AUDIO 代币被盗，黑客在 Uniswap 上将其换成 ETH 后，转入 Tornado 。此次攻击的主要原因是代理合约和实现合约之前存在插槽冲突，导致其 <code>initialize</code> 函数可以被重复调用。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>攻击者EOA地址：0xa0c7BD318D69424603CBf91e9969870F21B8ab4c</p><p>攻击合约地址：0xbdbB5945f252bc3466A319CDcC3EE8056bf2e569</p><p>攻击交易HASH：</p><p>0xfefd829e246002a8fd061eede7501bccb6e244a9aacea0ebceaecef5d877a984</p><p>0x3c09c6306b67737227edc24c663462d870e7c2bf39e9ab66877a980c900dd5d5</p><p>0x4227bca8ed4b8915c7eec0e14ad3748a88c4371d4176e16e8007249b9980dc9</p><p>首先攻击者部署攻击合约 0xbdbB5945f252bc3466A319CDcC3EE8056bf2e569，然后调用攻击合约的 <code>0x5bc7c6ac</code> 方法，交易哈希为 0xfefd829e246002a8fd061eede7501bccb6e244a9aacea0ebceaecef5d877a984，具体的调用的函数如下：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272153466.png" alt="image-20220727114156185"></p><p>可以看到攻击者首先通过代理合约调用了 <code>Governance</code> 合约的 <code>initialize </code>函数，进行了一系列初始化设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(_registryAddress = 0xbdbb5945f252bc3466a319cdcc3ee8056bf2e569,  _votingPeriod = 3,  _executionDelay = 0,  _votingQuorumPercent = 1,  _maxInProgressProposals = 4, _guardianAddress =  0xbdbb5945f252bc3466a319cdcc3ee8056bf2e569)</span><br></pre></td></tr></table></figure><p>在合约中找到 <code>initialize</code> 函数：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272153510.png" alt="image-20220727114930716"></p><p>发现其存在修饰器 <code>initializer</code>，找到该修饰器：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272154662.png" alt="image-20220727114843015"></p><p>第一次调用 <code>initialize</code> 时，<code>initialized</code> 以及 <code>initializing</code> 的值都为 false ，因此 require 中的条件满足，函数执行完后，<code>initialized</code> 的值变成了 true，<code>initializing</code> 的值为 false，因此被 <code>initializer </code>修饰的函数只能够调用一次。</p><p>那么攻击者是如何再次调用的呢？大概率是因为代理合约和实现合约之前的存储槽冲突。</p><p>首先看代理合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272154882.png" alt="image-20220727115940685"></p><p>该合约继承了 <code>UpgradeabilityProxy</code> 合约，查看该合约以及该合约继承的合约等，发现只有一个 <code> Implementation</code> 变量需要存储，但其插槽位于指定的位置，并非0槽：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272154561.png" alt="image-20220727120505749"></p><p>然后就是 <code>AudiusAdminUpgradeabilityProxy</code> 合约的 <code>proxyadmin</code> 变量，位于0槽。</p><p>再看实现合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155016.png" alt="image-20220727125204410"></p><p><code>Governance</code> 合约继承  <code>InitializableV2</code> 合约，<code>InitializableV2</code> 合约继承 <code>Initializable</code> 合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155223.png" alt="image-20220727125330574"></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155033.png" alt="image-20220727125400706"></p><p>因此 <code>Governance</code> 插槽0处存在 <code>initialized</code>、<code>initializing</code>、<code>isInitialized</code> 三个布尔变量，后续变量如果小于29字节也会在0槽。</p><p>因此两个合约的 storage 布局如下：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155210.png" alt="image-20220727131338142"></p><p>由于代理合约中存储实现合约的所有状态变量，因此在0槽会发生冲突：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155039.png" alt="image-20220727151904658"></p><p>当代理合约的创建后，构造函数初始化 <code>proxyAdmin</code>，因此 <code>initialized</code>、<code>initializing</code> 会被覆盖，导致其恒为 true，因此 <code>initializer</code> 修饰器失效，可以无限制调用 <code>initialize</code> 函数。</p><p>攻击合约调用完 <code>initialize</code> 函数后，调用 <code>evaluateProposalOutcome </code> 函数评估84提案，但并未成功执行该提案。</p><p>然后调用 <code>AUDIO</code> 合约的 <code>balanceOf</code> 函数查看代币余额。</p><p>接着调用 <code>submitProposal</code> 函数发起新的提案，提案内容为向攻击合约转币，数量为1850万：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(_targetContractRegistryKey = 3078000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">,  _callValue = 0,  _functionSignature = transfer(address,uint256),  _callData = 000000000000000000000000bdbb5945f252bc3466a319cdcc3ee8056bf2e569</span><br><span class="line">0000000000000000000000000000000000000000000f5b2f71812d138f71f6f5,  _name = Hello,  _description = World)</span><br></pre></td></tr></table></figure><p>接着调用 <code>Staking</code> 的 <code>initialize </code> 函数，将攻击合约地址设置为 <code>tokenAddress</code>、<code>governanceAddress</code>。</p><p>调用 <code>DelegateManagerV2</code> 的 <code>initialize </code> 函数，将攻击合约地址设置为 <code>tokenAddress</code>、<code>governanceAddress</code>。</p><p>调用 <code>DelegateManagerV2</code> 的 <code>setServiceProviderFactoryAddress</code> 函数，将攻击合约地址设置为 <code>spFactory</code>。</p><p>调用 <code>DelegateManagerV2</code> 的 <code>delegateStake</code> 函数，给攻击合约地址大量投票。</p><p>接下来攻击者调用攻击合约的 <code>0xcc66ce79</code> 函数，交易哈希为0x3c09c6306b67737227edc24c663462d870e7c2bf39e9ab66877a980c900dd5d5，相关的调用栈如下：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155332.png" alt="image-20220727144916730"></p><p>攻击合约调用 <code>Governance</code> 合约的 <code>submitVote</code> 函数，向85号提案投票。</p><p>最后攻击者调用攻击合约的 <code>0x543db4c4</code> 函数，交易哈希为0x4227bca8ed4b8915c7eec0e14ad3748a88c4371d4176e716e8007249b9980dc9，相关调用栈如下：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272156362.png" alt="image-20220727150004645"></p><p>攻击合约调用 <code>Governance</code> 合约的 <code>evaluateProposalOutcome</code> 函数，评估85号提案，并成功执行，向攻击合约地址转了1850万枚 AUDIO 代币。</p><p>至此攻击结束，攻击者将这1850万枚代币在 Uniswap 上换成 ETH，然后转入混币器 Tornado.Cash。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>官方发声明已经修复，查看代码：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272156927.png" alt="image-20220727150438265"></p><p>发现在 <code>Initializable</code> 合约处新增了三个变量，<code>address private proxyAdmin</code> 以及两个填充变量 <code>uint256 private filler1</code>、<code>uint256 private filler2</code>，这样就不会存在插槽冲突了。同时在修饰器 <code>initializer</code> 中添加了判断条件 <code>msg.sender == proxyAdmin</code>，限定了调用者。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代理合约与实现合约的存储槽冲突是导致此次攻击事件的主要原因。个人学习了很久才分析明白，暴露了自己在 storage 方面知识的缺失，后续还需要多学习学习。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Revest Finance攻击事件学习</title>
      <link href="/2022/07/12/Revest-Finance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/07/12/Revest-Finance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>2022年3月27日，Revest Finance 被攻击，损失大约 2M$(352,835 RENA)，主要的攻击方式为重入攻击。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>Revest Finance 的合约 Revest 提供三种方式进行质押资产，mint 相应的 FNFT：</p><ul><li>mintTimeLock : 用户质押的数字资产在一段时间之后才能被解锁；</li><li>mintValueLock : 用户质押的数字资产只有在升值或者贬值到预设数值才能被解锁；</li><li>mintAddressLock : 用户质押的数字资产只能被预设的账户解锁。</li></ul><p>例如 <code>mintAddressLock</code>，用户需要传入参数为：trigger(解锁人)，arguments(可省略)，recipients(接受人)，quantities(FNFT 数量)，FNFTConfig(结构体，包含质押物 asset，每枚 FNFT 对应的质押物数量 depositAmount 以及其他信息)。</p><p>同时还提供<code>depositAdditionalToFNFT</code>方法，用于让用户为存在的FNFT质押更多的质押物。传入的参数为：fnftId(存在的 FNFT 的 ID)，amount(每枚 FNFT 对应的质押物数量)，quantity(FNFT 数量)。其中 quantity 可以小于或者等于 mint 的数量，当等于时，合约会 burn 掉之前的 FNFT，并生成新的 FNFT，修改其对应的质押物数量；当小于时，合约会 burn 掉增加质押物数量的 FNFT，生成新的 FNFT，并修改其对应的质押物数量，此时用户存在两种 ID 的 FNFT，一种是原来质押物数量的，一种是增加了质押物数量的。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>攻击交易哈希：0xe0b0c2672b760bef4e2851e91c69c8c0ad135c6987bbf1f43f5846d89e691428</p><p>攻击者通过 uniswap 闪电贷获取了2 RENA，然后调用<code>mintAddressLock</code>，铸造 ID 为1027的 FNFT：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121843073.png" alt="image-20220712184348037"></p><p>其中解锁人以及接受人都是攻击合约，铸造 FNFT 的数量为2，质押物为 RENA，数量为0。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121845268.png" alt="image-20220712184501229"></p><p>然后攻击者再次调用<code>mintAddressLock</code>，铸造新的 FNFT，其 ID 为1028：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121849691.png" alt="image-20220712184913643"></p><p>其中解锁人以及接受人都是攻击合约，铸造 FNFT 的数量为360000，质押物为 RENA，数量依然为0。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121849252.png" alt="image-20220712184935208"></p><p>然后攻击合约在收到此次铸造的 FNFT 后触发 <code>onERC1155Received</code>函数（攻击者通过条件判断让第一次调用<code>onERC1155Received</code>时不执行操作，第二次才执行），该函数调用 Revest 合约中的<code>depositAdditionalToFNFT</code>函数，此时攻击者传入的该函数的参数为：fnftId &#x3D; 1,027,  amount &#x3D; 1,000,000,000,000,000,000,  quantity &#x3D; 1 </p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121858323.png" alt="image-20220712185825289"></p><p>因此合约会 burn 掉 一个 ID 为1027，对应质押物为0 RENA 的 FNFT，生成一个 ID 为1028，对应质押物为1 RENA的 FNFT，至于为什么ID还是1028，因为其 handle 合约中的<code>mint</code> 函数这样写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function mint(address account, uint id, uint amount, bytes memory data)</span><br><span class="line">external </span><br><span class="line">override </span><br><span class="line">onlyRevestController </span><br><span class="line">&#123;</span><br><span class="line">        supply[id] += amount;</span><br><span class="line">        _mint(account, id, amount, data);</span><br><span class="line">        fnftsCreated += 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>depositAdditionalToFNFT</code>函数中会调用 vault 合约的<code>handleMultipleDeposits</code>函数更新对应的质押关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function handleMultipleDeposits(</span><br><span class="line">        uint fnftId,</span><br><span class="line">        uint newFNFTId,</span><br><span class="line">        uint amount</span><br><span class="line">    ) external override onlyRevestController &#123;</span><br><span class="line">        require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;);</span><br><span class="line">        IRevest.FNFTConfig storage config = fnfts[fnftId];</span><br><span class="line">        config.depositAmount = amount;</span><br><span class="line">        mapFNFTToToken(fnftId, config);</span><br><span class="line">        if(newFNFTId != 0) &#123;</span><br><span class="line">            mapFNFTToToken(newFNFTId, config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时传入的值为：fnftId&#x3D;1027，newFNFTId&#x3D;1028，amount&#x3D;1,000,000,000,000,000,000</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121910504.png" alt="image-20220712191053452"></p><p>因此最后 ID 为1028的 FNFT 对应的质押物被修改为1 RENA。之前攻击者铸造了360000枚 ID 为1028的 FNFT，再加上这新铸造的1枚，对应的质押物也就变成了360001个 RENA。</p><p>最后攻击者调用<code>withdrawNFNFT</code>函数，burn 掉 FNFT，提走 RENA，并偿还闪电贷：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121918924.png" alt="image-20220712191844882"></p><h2 id="额外的漏洞"><a href="#额外的漏洞" class="headerlink" title="额外的漏洞"></a>额外的漏洞</h2><p>此漏洞为 BlockSec团队发现，位于 vault 合约的<code>handleMultipleDeposits</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function handleMultipleDeposits(</span><br><span class="line">        uint fnftId,</span><br><span class="line">        uint newFNFTId,</span><br><span class="line">        uint amount</span><br><span class="line">    ) external override onlyRevestController &#123;</span><br><span class="line">        require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;);</span><br><span class="line">        IRevest.FNFTConfig storage config = fnfts[fnftId];</span><br><span class="line">        config.depositAmount = amount;</span><br><span class="line">        mapFNFTToToken(fnftId, config);</span><br><span class="line">        if(newFNFTId != 0) &#123;</span><br><span class="line">            mapFNFTToToken(newFNFTId, config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当想增加已存在的 FNTF 对应的质押物时，用户可以调用<code>depositAdditionalToFNFT</code>函数，正常逻辑是 burn 掉用户传入的数量，生成相应数量的新的 FNFT，并修改新生成的 FNFT 对应的质押关系。但是此处<code>handleMultipleDeposits</code>函数会将所有的 FNFT 的质押关系都修改，也即原来的 FNFT 和新生成的 FNFT 的质押关系都会被修改。我们可以铸造10枚 FNFT，对应质押数量为0 ，ID为1，然后调用<code>depositAdditionalToFNFT</code>，增加其中一枚的 FNFT 对应的质押数量为1，那么执行<code>handleMultipleDeposits</code>函数后，我会有9枚对应质押数量为1、ID 为1的 FNFT，1枚对应质押数量为1，ID 为2的 FNFT，算下来净获利9个币。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p><code>mint</code>以及<code>mintBatchRec</code>函数建议先修改变量状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController &#123;</span><br><span class="line">        supply[id] += amount;</span><br><span class="line">        fnftsCreated += 1;</span><br><span class="line">        _mint(account, id, amount, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function mintBatchRec(address[] calldata recipients, uint[] calldata quantities, uint id, uint newSupply, bytes memory data) external override onlyRevestController &#123;</span><br><span class="line">        supply[id] += newSupply;</span><br><span class="line">        fnftsCreated += 1;</span><br><span class="line">        for(uint i = 0; i &lt; quantities.length; i++) &#123;</span><br><span class="line">            _mint(recipients[i], id, quantities[i], data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>handleMultipleDeposits</code>函数在 <code>newFNFTId</code>为0时不修改<code>fnftId</code>对应的<code>config</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function handleMultipleDeposits(</span><br><span class="line">    uint fnftId,</span><br><span class="line">    uint newFNFTId,</span><br><span class="line">    uint amount</span><br><span class="line">) external override onlyRevestController &#123;</span><br><span class="line">    require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;);</span><br><span class="line">    IRevest.FNFTConfig memory config = fnfts[fnftId];</span><br><span class="line">    config.depositAmount = amount;</span><br><span class="line">    if(newFNFTId != 0) &#123;</span><br><span class="line">        mapFNFTToToken(newFNFTId, config);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mapFNFTToToken(fnftId, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此次事件攻击者通过 ERC1155 的回调结合<code>mint</code>函数和<code>handleMultipleDeposits</code>的缺陷，成功进行了攻击，攻击技巧比较巧妙，十分牛逼。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/NMdQUFZBPU5eQ_oR_JkcLg">More than Re-entrancy : Revest Finance 被攻击事件分析</a></p><p><a href="https://woods1060.github.io/2022/04/02/Revest_Finance%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/">Revest Finance漏洞–NFT的重入攻击？</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OP代币被盗事件学习</title>
      <link href="/2022/06/13/OP%E4%BB%A3%E5%B8%81%E8%A2%AB%E7%9B%97%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/13/OP%E4%BB%A3%E5%B8%81%E8%A2%AB%E7%9B%97%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>2022年6月9日，Optimism 和加密货币做市商  Wintermute 发布公告，2000万个 OP 代币被黑客盗取。OP 向 Wintermute 提供了2000万代币，委托其提供流动性服务，OP 在向 Wintermute 发送了1 OP 代币和100万 OP 两笔交且 Wintermute 确认无误后，又向其发送了1900万 OP 代币。但在发送完 OP代币后，Wintermute 发现其无法控制这些代币。因为其多签钱包只部署在以太坊主网上，未在 Optimism 网络部署，黑客通过抢先将该多签地址部署在 Optimism 网络上，成功控制代币。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="多签钱包"><a href="#多签钱包" class="headerlink" title="多签钱包"></a>多签钱包</h3><p>往区块链上发送一笔交易，需要使用钱包做一个签名，签名好后将交易发送出去，交易执行成功转装就成功，这是单签钱包。而多签钱包则是需要多个人去签名执行操作的钱包，使用时需要多个人签名发送交易后，转账操作才完成。多签钱包可以使用 m&#x2F;n 的模式，即 n 个人里有 m 个人签名即可完成操作。</p><p>常说的多签主要针对的是比特币和以太坊 ERC-20 标准代币。在比特币中有2种类型的地址，1开头的是 P2PKH，表示个人地址，3开头的是 P2SH，一般表示多签地址。普通的比特币地址是由公钥做哈希后得到的，而多重签名地址基于脚本哈希，所以能够实现复杂的交易逻辑，在原生上比特币就支持多签。而以太坊原生并不支持多签地址，多签钱包在以太坊中往往是一个智能合约。Ownbit 和 Gnosis 代表了当前主流的两种以太坊多签实现方式。其中 Wintermute 使用的 Gnosis 多签钱包。</p><h3 id="EIP155-标准"><a href="#EIP155-标准" class="headerlink" title="EIP155 标准"></a>EIP155 标准</h3><p>EIP155 标准用于防范重放攻击。</p><p>当区块高度大于 FORK_BLKNUM (2,675,000) 且 CHAIN_ID 可用时，在计算交易的哈希以进行签名时，不只是对六个 rlp 编码元素（nonce, gasprice, startgas, to, value, data）进行哈希处理，应对9个 rlp 编码元素（nonce, gasprice, startgas, to, value, data, chainid, 0, 0）进行哈希处理，所以签名后的 v 值为：{0,1} + CHAIN_ID * 2 + 35，而如果只对6个元素进行哈希处理，则签名后的 v 值为：{0,1} + 27。</p><p>当区块高度大于 FORK_BLKNUM (2,675,000) 且 v 值等于 CHAIN_ID * 2 + 35 或者 CHAIN_ID * 2 + 36 时，在计算交易的哈希以进行签名时，不只是对六个 rlp 编码元素进行哈希处理，应对9个 rlp 编码元素（nonce, gasprice, startgas, to, value, data, chainid, 0, 0）进行哈希处理。当前存在的使用 v 值等于27或者28签名方案保持有效，并继续在与以前相同的规则下运行。</p><p>简单点说的就是不加 CHAIN_ID 的签名后的 v 值在27-28之间，交易可以在不同的链上进行重放。</p><h3 id="合约地址生成方式"><a href="#合约地址生成方式" class="headerlink" title="合约地址生成方式"></a>合约地址生成方式</h3><p>智能合约生成合约地址有两种方式，分别是 CREATE 指令和 CREATE2 指令，其中使用 CREATE 指令创建的合约地址可以使用<code>keccak256(rlp.encode(deployingAddress, nonce))[12:]</code>计算出来，其中 nonce的值每发送一笔交易或者创建一个合约就会 +1。</p><p>使用 CREATE2 指令创建的合约的地址使用<code>keccak256(0xff ++ deployingAddr ++ salt ++ keccak256(init_code))[12:]</code>计算，其中 init_code 是被部署合约的字节码。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>首先是 Optimism 向 Wintermute 的多签钱包地址发送 OP 代币：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140044997.png" alt="image-20220614004415931"></p><p>由于此时 Wintermute 的多签钱包只在以太坊主网上部署，未在 Optimism 网络上部署，因此其对2000万 OP 代币无控制权。</p><p>黑客此时抢先将该多签钱包地址部署到 Optimism 网络上。</p><p>黑客攻击地址为：0x60b28637879b5a09d21b68040020ffbf7dba5107</p><p>其首先分别向两个地址 0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A、0x8BcFe4f1358E50A1db10025D731C8b3b17f04DBB转账0.2 eth、0.5 eth：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140140373.png" alt="image-20220614014044339"></p><p>其中 0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A 用来部署 Gnosis Safe 的 ProxyFactory 合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140141258.png" alt="image-20220614014131219"></p><p>0x8BcFe4f1358E50A1db10025D731C8b3b17f04DBB 则用来部署 0xe7145dd6287ae53326347f3a6694fcf2954bcd8a 合约，该合约用于多次调用 ProxyFactory 中的 <code>createProxy</code>函数：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140142685.png" alt="image-20220614014259649"></p><p>由于生成多签钱包地址的是 Gnosis Safe 的 ProxyFactory 合约，因此找到创建该合约的记录。</p><p>首先在 etherscan 搜索多签钱包地址0x4f3a120e72c76c22ae802d129f599bfdbc31cb81，然后找到其创建的记录：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140101334.png" alt="image-20220614010145311"></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140102673.png" alt="image-20220614010256645"></p><p>然后找到 Gnosis Safe 的 ProxyFactory 合约的创建记录：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140104688.png" alt="image-20220614010403652"></p><p>然后查看此时 v 值，不知道在 etherscan 如何查看，学习慢雾的方法，注册了一个 infura.io 账号，使用该命令查看详情：<code>curl -s -H &#39;content-type:application/json&#39; -d &#39;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getTransactionByHash&quot;,&quot;params&quot;:[&quot;0x75a42f240d229518979199f56cd7c82e4fc1f1a20ad9a4864c635354b4a34261&quot;],&quot;id&quot;:1&#125;&#39; https://mainnet.infura.io/v3/xxxx</code></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140106354.png" alt="image-20220614010649319"></p><p>可以看到此时的 v 值为 0x1c，换算为十进制为28，因此该 v 值不符合 EIP155标准，不带 CHAIN_ID，可以在其他链进行重放攻击，以得到相同地址的合约，攻击者在 Optimism 网络重放，得到地址与在以太坊主网相同的 ProxyFactory 合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140113772.png" alt="image-20220614011343743"></p><p>然后再看  Gnosis Safe 的 ProxyFactory 合约的源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contract ProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    event ProxyCreation(Proxy proxy);</span><br><span class="line"></span><br><span class="line">    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.</span><br><span class="line">    /// @param masterCopy Address of master copy.</span><br><span class="line">    /// @param data Payload for message call sent to new proxy contract.</span><br><span class="line">    function createProxy(address masterCopy, bytes memory data)</span><br><span class="line">        public</span><br><span class="line">        returns (Proxy proxy)</span><br><span class="line">    &#123;</span><br><span class="line">        proxy = new Proxy(masterCopy);</span><br><span class="line">        if (data.length &gt; 0)</span><br><span class="line">            // solium-disable-next-line security/no-inline-assembly</span><br><span class="line">            assembly &#123;</span><br><span class="line">                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) &#123; revert(0, 0) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        emit ProxyCreation(proxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //省略其他代码 N 行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到新建合约地址使用的<code>new Proxy(masterCopy)</code>，即使用的 CREATE 指令进行创建，合约地址是 msg.sender 以及 nonce 来计算的，由于此时工厂合约地址已经和以太坊主网相同，只需要 nonce 和在以太坊主网上生成多签钱包地址的 nonce 相同，则可完成部署，攻击者通过调用合约 0xe7145dd6287ae53326347f3a6694fcf2954bcd8a 来实现，该合约内部则多次调用 ProxyFactory 合约的<code>createProxy</code>函数，来增加 nonce 值达到该目的：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140130665.png" alt="image-20220614013033627"></p><p>最后成功将该多签钱包地址部署在 Optimism网络：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140132168.png" alt="image-20220614013208126"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>引发此次安全事件的原因：一是 Wintermute 未验证在侧链是否对其多签钱包地址具有控制权；二是 Solidity 旧版本的漏洞导致使用 CREATE 指令来创建合约地址；三是交易签名未带 CHAIN_ID，不符合 EIP155 标准导致交易可在其他链重放。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/MjvCChjEGuSTr9cELQlW_A">2000 万 OP 代币被盗关键：交易重放</a></li><li><a href="https://www.finacerun.com/index.php/home/news/detail/article_id/98429.html">重入攻击 + 管理漏洞：2000 万枚 OP 被盗事件分析</a></li><li><a href="http://www.hackdig.com/06/hack-684523.htm">交易重放+管理漏洞—2000万枚OP被盗事件分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/526490325">2000万OP因何被盗? 来看看链上细节</a></li><li><a href="https://eips.ethereum.org/EIPS/eip-155">EIP-155: Simple replay attack protection</a></li><li><a href="https://learnblockchain.cn/article/1902">深入剖析 Ownbit 和 Gnosis 多签</a></li><li><a href="https://learnblockchain.cn/article/4077">多签钱包的工作原理与使用方式</a></li><li><a href="https://m.elecfans.com/article/1098135.html">CREATE2指令在广义状态通道中的应用介绍</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闪电贷攻击学习</title>
      <link href="/2022/06/09/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/09/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是闪电贷"><a href="#什么是闪电贷" class="headerlink" title="什么是闪电贷"></a>什么是闪电贷</h2><p>闪电贷最早是由 Marble 协议引入的概念，当时是为了让用户可以在以太坊借用 Ether 和 ERC-20 代币，后来由 Aave、dYdX 等进行了普及。</p><p>简单来说，闪电贷就是在一个区块交易中，同时完成借款和还款操作这两个操作，无需抵押任何资产，只需支付手续费即可。因为要求借款和还款操作都在一个区块中完成（以太坊平均每个区块时间大概是14秒，币安智能链每个区块时间大约3秒），所以时间非常短，普通人难以操作，一般是专业人员（科学家）使用。</p><p>用户在借到款之后，可以利用借到的资产进行其他操作，然后在交易结束的时候，用户只要把借到的款项及手续费及时归还就可以，否则该笔交易就会回滚，就像什么也没有发生过一样。</p><h2 id="闪电贷的作用"><a href="#闪电贷的作用" class="headerlink" title="闪电贷的作用"></a>闪电贷的作用</h2><p>闪电贷作用大致有以下：</p><ul><li>套利。比如在两个不同DEX（中心化交易平台）之间ETH价格是有差异的，在A平台 ETH: DAI&#x3D;1: 2700，在B平台上1：2750，那么，这个时候可以去AAVE里面借入2700DAI，在A平台买入1个ETH，在B平台以2750的价格卖出ETH，然后还掉2700DAI，净赚50DAI。</li><li>自我清算。比如你在去中心化平台抵押的一笔ETH即将到达清算点，在清算之后你要付一大笔清算费（一般是5-8%左右），这个时候你可以借一笔闪电贷，归还所贷资产，然后将平台抵押的ETH取出，用ETH换成相应的DAI或其他资产归还闪电贷，此时只需要付0.09%的闪电贷手续费而已（AAVE平台闪电贷手续费0.09%，每个平台手续费不一样）。</li><li>更换抵押物。比如你在借代平台上抵押的是ETH，你想把抵押物换成USDC，这个时候你可以用闪电贷借一笔DAI，用DAI换成USDC，然后抵押进去，随后将ETH取出，换成DAI，归还闪电贷所借DAI即可。</li><li>迁移资产或债务。比如我在A平台上面有抵押ETH借出BNB，这个时候我感觉A平台有一些风险，所以想把整个借代迁移到B平台上，我可以在AAVE用闪电贷借一笔DAI，把DAI换成BNB，在A平台归还之后取出ETH，然后将ETH抵押到B平台借出相同数量的BNB，然后将BNB换成DAI归还闪电贷，在不挪动原来借出来的BNB的基础上完成了不同平台资产和债务的转移。</li></ul><p>当然还存在更多的应用场景。</p><h2 id="闪电贷项目"><a href="#闪电贷项目" class="headerlink" title="闪电贷项目"></a>闪电贷项目</h2><p>主流的几个闪电贷项目，主要为Aave，Uniswap，dYdX。</p><ul><li><p>Aave。Aave 是一个去中心化的非托管流动性市场协议，用户可以作为存款人或借款人参与其中。存款人向市场提供流动性以赚取被动收入，而借款人能够以超额抵押（永久）或抵押不足（单块流动性）的方式借款。</p><p>其中Aave V3 为闪电贷提供了两种选择：</p><ul><li>flahsLoan。允许借款人在单次闪贷交易中获得多个准备金的流动性。</li><li>flahsLoanSimple。允许借款人为交易获取单一准备金的流动性。</li></ul></li></ul><p>​流程大概为实现 IFlashLoanSimpleReceiver.sol 或者 IFlashLoanReceiver.sol 中的 executeOperation 函数，该函数用来利用闪电贷，然后再调用flahsLoan函数或者 flahsLoanSimple 函数，传入相应的参数即可。executeOperation函数在flashLoan函数成功执行后被内部调用。其中Aave的手续费用为0.09%。</p><ul><li>Uniswap。Uniswap 作为 DeFi 中最受欢迎的去中心化交易所之一，从V2版本开始支持闪电贷（Flash Swaps）功能，该功能通过调用UniswapV2pair 合约实例的 swap 方法带入额外 data 实现。手续费为0.3%。</li><li>dYdX。dYdX 是一个针对专业交易者的去中心化交易所，本身并没有闪电贷功能，但是可以通过对 SoloMargin 合约执行一系列操作来实现类似闪电贷功能。其主要原理是通过继承 DydxFlashloanBase 合约编写initiateFlashLoan 回调 callFunction 实现借贷、套利、还款等操作。手续费 2 Wei。</li></ul><h2 id="闪电贷攻击"><a href="#闪电贷攻击" class="headerlink" title="闪电贷攻击"></a>闪电贷攻击</h2><p>闪电贷本身的存在是没有漏洞的，但闪电贷可以在短时间内获取到大量资金，黑客将闪电贷和其他漏洞进行结合，进行价格操控、套利。其中其他漏洞一般是合约逻辑存在问题导致黑客可以进行价格操控，或者是存在重入漏洞。以下是学习的闪电贷攻击实例。</p><h3 id="Grim-Finance-被黑事件"><a href="#Grim-Finance-被黑事件" class="headerlink" title="Grim Finance 被黑事件"></a>Grim Finance 被黑事件</h3><p>问题出在Grim Finance vault 的depositFor函数上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function depositFor(address token, uint _amount,address user ) public &#123;</span><br><span class="line"></span><br><span class="line">        uint256 _pool = balance();</span><br><span class="line">        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">        earn();</span><br><span class="line">        uint256 _after = balance();</span><br><span class="line">        _amount = _after.sub(_pool); // Additional check for deflationary tokens</span><br><span class="line">        uint256 shares = 0;</span><br><span class="line">        if (totalSupply() == 0) &#123;</span><br><span class="line">            shares = _amount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shares = (_amount.mul(totalSupply())).div(_pool);</span><br><span class="line">        &#125;</span><br><span class="line">        _mint(user, shares);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中由用户传入的token参数未做过滤，导致第四行调用的safeTransferFrom函数可被用户控制，攻击者传入自己的部署的恶意合约的地址，并在恶意合约的safeTransferFrom函数中调用depositFor，以此造成重入攻击。</p><p>其中在调用safeTransferFrom前计算了一次balance，在调用后又计算了一次balance，其差值amount为用户传入的代币数，那么攻击者只需要在最后一次重入的时候传入真实代币，当最后一次重入完成，after变成了充值后的余额，那么前面重入的amount也将改变，攻击者实现了充值一次当充值N次的目的。</p><p>大概的攻击合约伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    uint times = 0;</span><br><span class="line">    function safeTransferFrom(address token, uint _amount,address user) public &#123;</span><br><span class="line">        if(times &lt; 4)&#123;</span><br><span class="line">            times ++;</span><br><span class="line">            GrimBoostVault.depositFor(address(this), 0, attackaddress);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            GrimBoostVault.depositFor(SLPToken, 200, attackaddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wault-Finance-被黑事件"><a href="#Wault-Finance-被黑事件" class="headerlink" title="Wault Finance 被黑事件"></a>Wault Finance 被黑事件</h3><p>问题出在WUSDMaster合约中的staking函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function stake(uint256 amount) external nonReentrant &#123;</span><br><span class="line">        require(amount &lt;= maxStakeAmount, &#x27;amount too high&#x27;);</span><br><span class="line">        usdt.safeTransferFrom(msg.sender, address(this), amount);</span><br><span class="line">        if(feePermille &gt; 0) &#123;</span><br><span class="line">            uint256 feeAmount = amount * feePermille / 1000;</span><br><span class="line">            usdt.safeTransfer(treasury, feeAmount);</span><br><span class="line">            amount = amount - feeAmount;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 wexAmount = amount * wexPermille / 1000;</span><br><span class="line">        usdt.approve(address(wswapRouter), wexAmount);</span><br><span class="line">        wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            wexAmount,</span><br><span class="line">            0,</span><br><span class="line">            swapPath,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">        wusd.mint(msg.sender, amount);</span><br><span class="line">        </span><br><span class="line">        emit Stake(msg.sender, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该质押函数一比一质押USDT获得WUSD，同时还会进行swap操作，调用wswapRouter的swapExactTokensForTokensSupportingFeeOnTransferTokens，将质押一部分的 USDT 换成 WEX，这样就会使得 WaultSwapPair (BSC_USDT-WEX) 池子的 WEX 数量减少，价值变高，在多次调用stake函数后，WEX价格上涨，攻击者再将之前通过redeem和利用USDT兑换的WEX在USDT-WEX池中卖出，换取更多的WEX，完成套利。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>1、合理设计经济模型。</p><p>2、使用去中心化预言机获取价格。</p><p>3、对关键函数建立完备的访问控制机制。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://picture.iczhiku.com/weixin/message1623120320734.html">科普 | 无抵押借巨资的闪电贷是什么？缘何频频成为DeFi暴雷帮凶？</a></p></li><li><p><a href="https://www.sohu.com/a/489783580_100217347">揭开闪电贷的神秘面纱</a></p></li><li><p><a href="https://docs.aave.com/developers/guides/flash-loans">Flash Loans</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/s-1TCisIGfUIaVNNUgej0g">这波很 “严峻” – Grim Finance 被黑细节分析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/n_qF6BXp0tGriKz9WzlsvA">外部调用的不可控因素之 Grim Finance 被黑分析</a></p></li><li><p><a href="https://learnblockchain.cn/article/3311">又一经典的闪电贷套利 —— Wault.Finance 被黑事件分析</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
