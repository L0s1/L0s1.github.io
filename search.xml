<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Reentrancy</title>
      <link href="/2023/02/03/Reentrancy/"/>
      <url>/2023/02/03/Reentrancy/</url>
      
        <content type="html"><![CDATA[<p>重入漏洞是智能合约中最常见的漏洞，也是危害最大的漏洞。每年因为链上发生的重入攻击，损失了大量的资金。</p><h2 id="重入漏洞的本质"><a href="#重入漏洞的本质" class="headerlink" title="重入漏洞的本质"></a>重入漏洞的本质</h2><p>我认为的重入的本质：状态变量的改变后于外部恶意调用。</p><h2 id="重入点"><a href="#重入点" class="headerlink" title="重入点"></a>重入点</h2><p>Solidity 智能合约中存入重入点的地方很多，但并不是存在重入点就存在重入漏洞。常见的一些重入点：</p><ul><li>使用 call 发送 Ether；</li><li>ERC721 中的 _checkOnERC721Received() ;</li><li>ERC1155 中的 _doSafeTransferAcceptanceCheck() ;</li><li>ERC677中的 transferAndCall() ;</li><li>ERC777 中的 _callTokensToSend(), _callTokensReceived() ;</li></ul><h2 id="重入类型"><a href="#重入类型" class="headerlink" title="重入类型"></a>重入类型</h2><p>重入类型一般有下面三种：</p><ul><li>单 函数重入：重入发生在一个合约的一个函数 ; </li><li>多函数重入：重入发生了一个合约的多个函数 ; </li><li>多合约重入：重入发生在多个合约 ;</li></ul><h2 id="单函数重入"><a href="#单函数重入" class="headerlink" title="单函数重入"></a>单函数重入</h2><p>这种重入是最简单的重入，一个简单的例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract ReentrancyA &#123;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 _amount) external &#123;</span><br><span class="line">        require(_amount &lt;= balances[msg.sender]);</span><br><span class="line">        (bool success, ) = payable(msg.sender).call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success);</span><br><span class="line">        balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>withdraw 函数中 balances 的改变在外部调用之后，因此可以编写攻击合约调用受害合约的 withdraw 函数，然后受害合约向攻击合约发送 Ether ，会触发攻击合约的 fallback 函数，攻击合约在 fallback 函数中继续调用受害合约的 withdraw 函数，因为 balances 一直未修改，因此函数第一行的余额校验会一直通过，最后重复以上步骤直到受害合约内的 Ether 被全部提取。</p><h2 id="多函数重入"><a href="#多函数重入" class="headerlink" title="多函数重入"></a>多函数重入</h2><p>这里的多函数重入指一个合约内的函数。多函数重入发生的情况一般是合约存在可被攻击者控制的函数(状态变量)，而其他函数会使用该函数中的状态变量，这种情况下会存在多函数的重入。</p><p>一个简单的例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract ReentrancyB is ERC721 &#123;</span><br><span class="line">    mapping (address =&gt; bool) whiteList;</span><br><span class="line">    uint256 tokenId;</span><br><span class="line"></span><br><span class="line">    function mint() public &#123;</span><br><span class="line">      require(whiteList[msg.sender] = true);</span><br><span class="line">      tokenId++;</span><br><span class="line">      _safeMint(msg.sender, tokenid);</span><br><span class="line">      whiteList[msg.sender] = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claim() public &#123;</span><br><span class="line">      uint256 count = balanceOf(msg.sender);</span><br><span class="line">      payable(msg.sender).call&#123;value: count * Ether&#125;(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多合约重入"><a href="#多合约重入" class="headerlink" title="多合约重入"></a>多合约重入</h2><p>多合约重入一般是一个合约中的某个函数(状态变量)可被攻击者控制，而其他的合约会使用该函数中的影响的状态变量，这种情况下会存在多合约重入。</p><p>一个简单的例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line"></span><br><span class="line">mapping (address =&gt; uint256) balancesA;</span><br><span class="line">uint256 totalSupply;</span><br><span class="line"></span><br><span class="line">funtion claim(uint256 _amount) lock &#123;</span><br><span class="line">require(balancesA[msg.sender] &gt;= _amount);</span><br><span class="line">balancesA[msg.sender] -= _amount;</span><br><span class="line">payalbe(msg.sender).call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class="line">totalSupply -= _amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function lastPrice() external view returns (uint256)&#123;</span><br><span class="line">return totalSupply / address(this).balance;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">mapping (address =&gt; uint256) balancesB;</span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line">funtion withdraw(uint256 _amount) external &#123;</span><br><span class="line">require(balancesB[msg.sender] &gt;= _amount);</span><br><span class="line">balancesB[msg.sender] -= _amount;</span><br><span class="line">uint256 price = a.lastPrice();</span><br><span class="line">uint256 amount = _amount * price;</span><br><span class="line">payable(msg.sender).call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例-Curve-Read-Only-Reentrancy"><a href="#案例-Curve-Read-Only-Reentrancy" class="headerlink" title="案例 - Curve Read-Only Reentrancy"></a>案例 - Curve Read-Only Reentrancy</h2><p>2022年10月，ChainSecurity 团队在 DevCon 上披露了 Curve 中存在的一种新型的重入漏洞：只读重入漏洞。攻击者可以通过该漏洞操控虚拟价格，为恶意套利创造条件。</p><p>首先 Curve 中存在一个函数用来获取虚拟价格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@external</span><br><span class="line">@view</span><br><span class="line">def get_virtual_price() -&gt; uint256:</span><br><span class="line">    return 10**18 * self.get_xcp(self.D) / CurveToken(self.token).totalSupply()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 D 是所有基础资产的余额，虚拟价格由 D 除以 LP 代币的总发行量来得到。当 D 和 totalSupply 的值同步不及时的时候会发生虚拟价格失真的情况。其中一种发生在合约的 remove_liquidity 函数中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@external</span><br><span class="line">@nonreentrant(&#x27;lock&#x27;)</span><br><span class="line">def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS],</span><br><span class="line">                     use_eth: bool = False, receiver: address = msg.sender):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    This withdrawal method is very safe, does no complex math</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    lp_token: address = self.token</span><br><span class="line">    total_supply: uint256 = CurveToken(lp_token).totalSupply()</span><br><span class="line">    CurveToken(lp_token).burnFrom(msg.sender, _amount)</span><br><span class="line">    balances: uint256[N_COINS] = self.balances</span><br><span class="line">    amount: uint256 = _amount - 1  # Make rounding errors favoring other LPs a tiny bit</span><br><span class="line"></span><br><span class="line">    for i in range(N_COINS):</span><br><span class="line">        d_balance: uint256 = balances[i] * amount / total_supply</span><br><span class="line">        assert d_balance &gt;= min_amounts[i]</span><br><span class="line">        self.balances[i] = balances[i] - d_balance</span><br><span class="line">        balances[i] = d_balance  # now it&#x27;s the amounts going out</span><br><span class="line">        coin: address = self.coins[i]</span><br><span class="line">        if use_eth and coin == WETH20:</span><br><span class="line">            raw_call(receiver, b&quot;&quot;, value=d_balance)</span><br><span class="line">        else:</span><br><span class="line">            if coin == WETH20:</span><br><span class="line">                WETH(WETH20).deposit(value=d_balance)</span><br><span class="line">            response: Bytes[32] = raw_call(</span><br><span class="line">                coin,</span><br><span class="line">                _abi_encode(receiver, d_balance, method_id=method_id(&quot;transfer(address,uint256)&quot;)),</span><br><span class="line">                max_outsize=32,</span><br><span class="line">            )</span><br><span class="line">            if len(response) != 0:</span><br><span class="line">                assert convert(response, bool)</span><br><span class="line"></span><br><span class="line">    D: uint256 = self.D</span><br><span class="line">    self.D = D - D * amount / total_supply</span><br><span class="line"></span><br><span class="line">    log RemoveLiquidity(msg.sender, balances, total_supply - _amount)</span><br></pre></td></tr></table></figure><p>可以看到移除流动性函数首先会燃烧掉传入数量的 LP 代币(#10)，此时 LP 代币的总供应量减少，然后判断 use_eth 标识以及代币类型，然后将以太转给接收者，最后修改 D 的值。</p><p>如果接收者是智能合约，则会触发其 fallback 函数，如果此时在该函数中调用 get_virtual_price 函数，则会发现此时的虚拟价格会上升，因为 LP 代币的总量变小了，但是 D 的值此时还未修改。如果添加大量的流动性，再移除大量流动性，触发 fallback ，则此时的虚拟价格会剧烈飙升。而在本合约中关键函数都添加了重入锁无法利用，但有其他的项目引入了 Curve，并使用了 get_virtual_price 函数，导致其项目遭到了黑客的攻击。</p><p>其中一个例子是 Market.xyz。</p><p>攻击者使用闪电贷借出大量 WMATIC :</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202302061859436.png" alt="image-20230206185906378"></p><p>然后在回调函数中先添加流动性：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202302061900902.png" alt="image-20230206190037867"></p><p>然后再移除流动性，并在攻击合约的 fallback 函数中调用 Market 池子的 borrwo 函数进行借贷，借出大量的包装代币：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202302061903682.png" alt="image-20230206190319639"></p><p>其取价函数中调用了 Curve 的 get_virtual_price 函数：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202302061905319.png" alt="image-20230206190530264"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li>编写合约代码遵循“CEI”模式；</li><li>针对 Read-Only Reentrancy，可以在 关键的 view 函数也加上重入锁，或者将锁的状态公开，使得外部合约也能够获取到锁的状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可升级合约</title>
      <link href="/2023/02/02/%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6/"/>
      <url>/2023/02/02/%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>在以太坊上，合约部署后是无法修改其代码的。如果部署后发现代码有漏洞，或者想更新版本，想直接修改部署好的合约是不可能的。好在有一个操作码 delegatecall，借助这个操作码，我们可以曲线救国，实现可升级合约这一方案。下面我们讲述一下可升级合约的几种模式以及在使用可升级合约时的注意事项。</p><h2 id="Delegatecall"><a href="#Delegatecall" class="headerlink" title="Delegatecall"></a>Delegatecall</h2><p><em>delegatecall</em> 操作码用于外部调用其他合约的方法，但是执行环境是在当前合约当中，调用者不会发生变化，且状态变量是存储在当前合约当中。因此我们可以利用这种特性，设计出最简单的可升级合约，即一个代理合约，实现了升级逻辑以及在 fallback 方法中实现 delegatecall 调用逻辑，一个逻辑合约，实现真正的项目的逻辑。<br><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202302021644522.png" alt="Pasted image 20230201115001"></p><h2 id="Transparent-Proxies"><a href="#Transparent-Proxies" class="headerlink" title="Transparent Proxies"></a>Transparent Proxies</h2><p>上述实现了一个最为简单的可升级合约，但其实我们可以发现它存在了一些问题。<br>第一个问题是 <em>选择器冲突</em>，即我们在 proxy 合约会实现升级相关的逻辑，我们在 logic 合约会实现项目逻辑，当两者都实现了一个相同声明的函数，则会发生选择器冲突，当然不同也可能会发生冲突，只是概率较小。发生冲突时我们只能够调用 proxy 合约实现的函数，而无法调用 logic 合约实现的函数。<br>第二个问题是 <em>插槽冲突</em>，在 proxy 合约中存在升级逻辑，很明显这些升级相关的函数只能够由管理员来调用，因此 proxy 合约中需要有两个存储槽，一个用来存储管理员地址，一个用来存储 logic 合约地址，如果这些存储槽位置处理不当，则会和 logic 合约产生冲突，覆盖掉 logic 合约相同存储槽的状态变量，导致合约出现意料之外的情况。<br>为了解决选择器冲突这个问题，设计出了 Transparent proxies 模式，即透明代理模式。<br><em>透明代理模式</em> 会区分 proxy 合约特权账户和普通用户，在升级相关的逻辑处会判断是否为特权账户，是的话则调用 proxy 合约的升级逻辑，否则进入到 fallback 函数中；而在 fallback 函数中则会校验调用者是否为普通用户，是的话继续逻辑，否则会被 revert。也即该模式针对合约升级账户和普通用户进行了区分，解决了选择器冲突这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">modifier ifAdmin() &#123;</span><br><span class="line">        if (msg.sender == _getAdmin()) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _fallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">function changeAdmin(address newAdmin) external virtual ifAdmin &#123;</span><br><span class="line">        _changeAdmin(newAdmin);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">function upgradeTo(address newImplementation) external ifAdmin &#123;</span><br><span class="line">        _upgradeToAndCall(newImplementation, bytes(&quot;&quot;), false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">function _beforeFallback() internal virtual override &#123;</span><br><span class="line">        require(msg.sender != _getAdmin(), &quot;TransparentUpgradeableProxy: admin cannot fallback to proxy target&quot;);</span><br><span class="line">        super._beforeFallback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而针对插槽冲突这个问题，在 OpenZeppelin 实现的透明代理合约中，通过使用 <em>非结构化存储</em> 来解决这个问题。即 proxy 合约中的状态变量存储在特定位置的槽中，类似于 mapping，而不是存储在第零槽或者第一槽这种顺序存储，这样就不会跟 logic 合约的状态变量冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"></span><br><span class="line">* @dev Storage slot with the address of the current implementation.</span><br><span class="line"></span><br><span class="line">* This is the keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1, and is</span><br><span class="line"></span><br><span class="line">* validated in the constructor.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line">* @dev Storage slot with the admin of the contract.</span><br><span class="line"></span><br><span class="line">* This is the keccak-256 hash of &quot;eip1967.proxy.admin&quot; subtracted by 1, and is</span><br><span class="line"></span><br><span class="line">* validated in the constructor.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;</span><br></pre></td></tr></table></figure><h2 id="Universal-Upgradeable-Proxies"><a href="#Universal-Upgradeable-Proxies" class="headerlink" title="Universal Upgradeable Proxies"></a>Universal Upgradeable Proxies</h2><p>透明代理模式虽然解决了选择器冲突这一问题，但是缺点也非常明显，那就是每次调用都会去判断调用者的身份，会增加 gas 的消耗。另外一种常见的可升级合约的模式为 Universal upgradeable proxies，即通用可升级代理模式。<br><em>通用可升级代理模式</em> 与透明代理模式最大的区别在于合约升级的逻辑在逻辑合约中而不是在代理合约中，即 proxy 合约唯一的作用就是简单的通过 delegatecall 调用 logic 合约。因此使用 UUPS 模式的合约不会存在选择器冲突这个问题。<br><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202302021644269.png" alt="Pasted image 20230201114709"></p><p>但 UUPS 模式也有其缺点。升级相关的逻辑在逻辑合约中，容易和功能逻辑混淆，权限分配上容易混乱。如果逻辑合约如果忘记初始化容易出现被恶意利用的问题。与 TPPS 模式相比，UUPS 模式的使用更具有挑战性。</p><h2 id="Beacon-Pattern-Proxies"><a href="#Beacon-Pattern-Proxies" class="headerlink" title="Beacon Pattern Proxies"></a>Beacon Pattern Proxies</h2><p>有时候我们会遇到需要通过工厂合约部署很多相同合约的情况，如果这些合约也使用可升级合约，那么或许使用 Beacon pattern proxies 是一个好的方案。<br><em>信标代理模式</em> 满足了多个代理合约都使用一个相同的逻辑合约的场景。它在架构上比 TPPS 模式多出了一个 Beacon 合约，该合约存储了逻辑合约的地址，以及修改改地址的函数。然后代理合约每次需要从 Beacon 合约中取出逻辑合约的地址，然后对该地址进行 delegatecall 调用。<br><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202302021644004.png" alt="Pasted image 20230201115416"></p><p>信标代理模式和透明代理模式相比，其不存在插槽冲突的问题。因为 Proxy 合约中无需存储 Logic 合约的地址，也不需要编写升级的逻辑，Proxy 合约只需要保存 Beacon 合约的地址，该地址不会变化，因此地址变量可以通过 immutable 修饰，并在初始化时赋值，不占用存储槽。当需要升级时只需要在 Beacon 合约中修改 Logic 合约的地址，即可实现多个代理合约同时升级。<br>一个简单的信标代理模式的可升级合约的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract Proxy &#123;</span><br><span class="line">    address immutable beacon;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        address implementation = beacon.implementation();</span><br><span class="line">        return implementation.delegatecall.value(msg.value)(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Beacon is Ownable &#123;</span><br><span class="line">    address public implementation;</span><br><span class="line"></span><br><span class="line">    function upgrade(address newImplementation) public onlyOwner &#123;</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Diamonds-Multi-Facet-Proxy"><a href="#Diamonds-Multi-Facet-Proxy" class="headerlink" title="Diamonds, Multi-Facet Proxy"></a>Diamonds, Multi-Facet Proxy</h2><p>既然存在多个代理合约对一个逻辑合约的情况，那么也会存在一个代理合约对多个逻辑合约的情况。<br><em>钻石标准</em> 则可用于一个代理合约对多个逻辑合约的场景。当业务逻辑复杂的时候，代码的大小可能会超出以太坊规定的合约最大的限制(24K)，这个时候钻石标准可以解决这个问题。钻石标准将逻辑合约分为不同的切面，每一个或多个功能为一个切面，这样一个复杂的大小超过限制的逻辑合约被分成了很多个小的切面合约。例如可以将一个复杂的 Defi 分成预言机切面、权限切面、721切面等。其实现原理就是在代理合约中添加一个 mapping，由函数签名指向切面地址，这样每次调用 fallback 函数时都会根据传入的签名去寻找到切面的地址，然后执行对应的函数。<br><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202302021645663.png" alt="Pasted image 20230201151645"><br> 钻石标准需要实现相应的对切面进行修改的函数，也即所谓的升级逻辑，当需要升级时，只需要修改对应的 mapping 中的值就行。<br> 由于所有的切面合约的数据都保存在 proxy 合约当中，因此对存储槽的分配十分重要。提案发起人提出了三种方案来解决插槽冲突，一种是利用非结构化存储，将切面的数据放在一个结构体中，然后将结构体存储在特定的插槽中；第二种是继承，即 proxy 和 logic 都继承相同的合约来达到存储槽一致；第三种方案是将结构体使用 internal 修饰，没太理解这样为什么没有冲突。<br> 一般的中小型的项目不大可能用上钻石标准，切钻石标准真正实现起来较为复杂，尤其是对于数据的存储，如何保证不会存在插槽冲突，又如何去判定不同的切面中的变量是否需要共享，需要将业务切割成多少个切面，等等这些问题都使得钻石标准的实现难度大大增加。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p> 编写可升级合约虽然看起来十分简单，但是也需要注意以下几点，避免出现漏洞。</p><h3 id="插槽冲突"><a href="#插槽冲突" class="headerlink" title="插槽冲突"></a>插槽冲突</h3><p> 可升级合约中最常见的漏洞。如果使用开源的库，如 OpenZeppelin，务必谨慎添加状态变量。自己编写的话更要警惕。使用非结构化存储可以很好地解决该问题。</p><h3 id="选择器冲突"><a href="#选择器冲突" class="headerlink" title="选择器冲突"></a>选择器冲突</h3><p>  这个问题一般很少遇到，如果使用 OpenZeppelin 的透明代理或者通用代理不会存在该问题。如果是自己编写部署前检查一下函数的签名。</p><h3 id="初始化问题"><a href="#初始化问题" class="headerlink" title="初始化问题"></a>初始化问题</h3><p>  可升级合约中逻辑合约无法使用构造函数进行初始化，因此逻辑合约需要编写一个初始化函数来进行初始化变量，且需要添加上相应的修饰器保证该函数只能够被调用一次。</p><h3 id="升级账户私钥丢失"><a href="#升级账户私钥丢失" class="headerlink" title="升级账户私钥丢失"></a>升级账户私钥丢失</h3><p>  这是很多项目被攻击的原因，因为管理不当或者操作失误，导致了管理升级的特权账户私钥丢失了，攻击者直接将合约升级成恶意的合约，盗走资产。建议安全保管升级账户私钥，同时建议升级账户使用多签钱包方案。</p><h3 id="UUPS-模式逻辑合约未初始化"><a href="#UUPS-模式逻辑合约未初始化" class="headerlink" title="UUPS 模式逻辑合约未初始化"></a>UUPS 模式逻辑合约未初始化</h3><p>  在 UUPS 模式中，升级的逻辑在逻辑合约中，因此带有 upgradeAndCall 这样的方法，往往需要特权账户才能够调用，但是很多项目方只是调用初始化方法初始化了代理合约，而没有初始化逻辑合约，攻击者调用逻辑合约的初始化方法，将自己变成逻辑合约的特权账户，然后调用 upgradeAndCall 方法，将逻辑合约升级并且调用恶意合约的方法，一般是进行 selfdestruct，这样逻辑合约就会被销毁。代理合约只是存储了逻辑合约的地址，而无法修改，所以相当于没办法进行任何操作，资金会全部锁死在代理合约中。 使用 OpenZeppelin 的 UUPS 合约不会存在该问题，因为其升级逻辑限定了只能由 Proxy 合约进行调用。</p><h3 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a>继承问题</h3><p>  由于可升级合约无法使用构造函数进行初始化，所以继承的也不能是通过构造函数初始化的合约，需要添加初始化函数，或者继承可升级的版本。如 OpenZeppelin 中 使用可升级合约就需要继承其 contract-upgrade 里面的合约。</p><h3 id="权限控制不当"><a href="#权限控制不当" class="headerlink" title="权限控制不当"></a>权限控制不当</h3><p>  项目方如果没有做好权限分配，将升级特权账户和业务特权账户混淆，容易出现问题。如果是透明代理则无法调用业务的特权函数。在 UUPS 模式中更加容易混淆权限，因为升级逻辑和业务逻辑都在逻辑合约中，建议区分两种权限。<br>  第二种是合约编写时未做升级权限控制。如 Openzeppelin 的 UUPS 模式默认是任何人都可以去升级，我们需要去重写其 _authorizeUpgrade 函数，添加鉴权模块，使用时这一点很容易忘记。</p><h3 id="升级合约随意修改状态变量"><a href="#升级合约随意修改状态变量" class="headerlink" title="升级合约随意修改状态变量"></a>升级合约随意修改状态变量</h3><p>  升级合约时添加了新的业务逻辑，这个时候需要添加或者修改之前的变量，一个稳妥的做法是在原来的状态变量后顺序新增，而不是插入或者删除原来的状态变量。粗暴的修改之前的状态变量可能会造成插槽冲突、覆盖，业务逻辑将会被破坏。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Analysis of GDS Token Attack</title>
      <link href="/2023/01/04/The-Analysis-of-GDS-Token-Attack/"/>
      <url>/2023/01/04/The-Analysis-of-GDS-Token-Attack/</url>
      
        <content type="html"><![CDATA[<h2 id="Event-Overview"><a href="#Event-Overview" class="headerlink" title="Event Overview"></a>Event Overview</h2><p>The $GDS was attacked at 12:21 UTC on January 3, 2023, and the loss is about 180K USDT. The root cause is a flaw in the liquidity reward logic. Attacker adds liquidity through flashloans, and then collects rewards through multiple contracts.</p><h2 id="Attack-Analysis"><a href="#Attack-Analysis" class="headerlink" title="Attack Analysis"></a>Attack Analysis</h2><p>This is the transaction hash of the attack：</p><p><a href="https://bscscan.com/tx/0x2bb704e0d158594f7373ec6e53dc9da6c6639f269207da8dab883fc3b5bf6694">https://bscscan.com/tx/0x2bb704e0d158594f7373ec6e53dc9da6c6639f269207da8dab883fc3b5bf6694</a></p><p>First, attacker lent a large amount of USDT through two flashloans:</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202301041821331.png" alt="image-20230104182131263"></p><p>Then he swapped  600k USDT to $GDS,  and added liquidity to PancakeSwap pool:</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202301041844348.png" alt="image-20230104184432303"></p><p>He transferred LP token to a new attack contract, and then called its withdraw function. This function called GDS.transfer function to transfer $GDS  to dead address, next attack contract received reward and swapped all $GDS to USDT on PancakeSwap:</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202301051454264.png" alt="image-20230105145423059"></p><p>The attacker then repeated the operations so many times:</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202301051458169.png" alt="image-20230105145806126"></p><p>At the end of arbitrage operation, the attacker removed the liquidity and repaid the flashloans, and transferred USDT from attack contract to attack’s EOA：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202301051508783.png" alt="image-20230105150850736">                                                                                                                                                                                                                                                                                                  </p><p>Through the above operations, the attacker made a profit of 39K USDT and 10M $GDS.</p><h2 id="Vulnerability-Analysis"><a href="#Vulnerability-Analysis" class="headerlink" title="Vulnerability Analysis"></a>Vulnerability Analysis</h2><p>Through the above attack analysis, we can find that the anomaly is located in the transfer  to the dead address, so let’s find the transfer function:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address to, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">        address owner = _msgSender();</span><br><span class="line">        _transfer(owner, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Okay, let’s see the internal funciton _transfer:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function _transfer(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal virtual &#123;</span><br><span class="line">       </span><br><span class="line">        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line">        require(amount &gt;0, &quot;ERC20: transfer to the zero amount&quot;);</span><br><span class="line"></span><br><span class="line">        _beforeTokenTransfer(from, to, amount);</span><br><span class="line"></span><br><span class="line">//indicates if fee should be deducted from transfer</span><br><span class="line">bool _takeFee = takeFee;</span><br><span class="line"></span><br><span class="line">//if any account belongs to isExcludedTxFee account then remove the fee</span><br><span class="line">if (isExcludedTxFee[from] || isExcludedTxFee[to]) &#123;</span><br><span class="line">    _takeFee = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(_takeFee)&#123;</span><br><span class="line">            if(to == dead)&#123;</span><br><span class="line">                _transferStandard(from, to, amount);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(uniswapV2Pairs[from] || uniswapV2Pairs[to])&#123;</span><br><span class="line">                    _transferFee(from, to, amount);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    _destoryTransfer(from,to,amount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    _transferStandard(from, to, amount);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        _afterTokenTransfer(from, to, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>In this function, we should check the implementation of the _beforeTokenTransfer、 _transferStandard、 _afterTokenTransfer. Finally find that the exception is located in _afterTokenTransfer:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function _afterTokenTransfer(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal virtual &#123;</span><br><span class="line">        _refreshDestroyMiningAccount(from,to,amount);</span><br><span class="line">        _activateAccount(from,to,amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Continue to follow up the _refreshDestroyMiningAccount:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function _refreshDestroyMiningAccount(address _from,address _to,uint256 _amount)internal &#123;</span><br><span class="line">        if(_to == dead)&#123;</span><br><span class="line">            _settlementDestoryMining(_from);</span><br><span class="line">            if(isOpenLpMining)&#123;</span><br><span class="line">                _settlementLpMining(_from);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            destroyMiningAccounts[_from] += _amount;</span><br><span class="line">            if(lastBlock[_from] == 0)&#123;</span><br><span class="line">                lastBlock[_from] = block.number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(uniswapV2Pairs[_from] || uniswapV2Pairs[_to])&#123;</span><br><span class="line">            if(isOpenLpMining)&#123;</span><br><span class="line">                _settlementLpMining(_from);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>When destination address is dead address, and the isOpenLpMining is true, function will enter the logic of _settlementLpMining:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function _settlementLpMining(address _from)internal &#123;</span><br><span class="line">        uint256 _lpTokenBalance = IERC20(gdsUsdtPair).balanceOf(_from);</span><br><span class="line">        uint256 _lpTokenTotalSupply = IERC20(gdsUsdtPair).totalSupply();</span><br><span class="line">        if(lastEpoch[_from] &gt;0 &amp;&amp; currentEpoch &gt; lastEpoch[_from] &amp;&amp; _lpTokenBalance&gt;0)&#123;</span><br><span class="line">           uint256 _totalRewardAmount= 0;</span><br><span class="line">           for (uint i = lastEpoch[_from]; i &lt; currentEpoch; i++) &#123;</span><br><span class="line">              _totalRewardAmount += everyEpochLpReward[i];</span><br><span class="line">              _totalRewardAmount += everyDayLpMiningAmount;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           uint256 _lpRewardAmount =  _totalRewardAmount*_lpTokenBalance/_lpTokenTotalSupply;</span><br><span class="line">           _internalTransfer(lpPoolContract,_from,_lpRewardAmount,4);</span><br><span class="line"></span><br><span class="line">           lastEpoch[_from] = currentEpoch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(lastEpoch[_from] == 0 &amp;&amp; _lpTokenBalance &gt;0)&#123;</span><br><span class="line">            lastEpoch[_from] = currentEpoch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(_lpTokenBalance == 0)&#123;</span><br><span class="line">            lastEpoch[_from] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>We can find this function will transfer $GDS from lpPoolContract to caller. The amount is _lpRewardAmount, which is determined by the three parameters _totalRewardAmount, _lpTokenBalance, _lpTokenTotalSupply. The patameter _totalRewardAmount is a constant, _lpTokenBalance is the caller’s balance of lp token,  _lpTokenTotalSupply is the total supply of the lp token. So the larger the _lpTokenBalance, the more rewards attacker will get. The attacker obtained large amounts of lp token by adding liquidity through  flashloans, and transferred these tokens to different attack contracts to repeatedly obtain rewards.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>The root cause of this attack is the single factor in calculating rewards. Therefore, we recommend that multiple factors should be considered when calculating rewards to avoid be manipulated by attackers through flashloans and other methods. </p>]]></content>
      
      
      <categories>
          
          <category> BlockChain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security Events Learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Defrost Finance攻击事件分析</title>
      <link href="/2022/12/29/Defrost-Finance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2022/12/29/Defrost-Finance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>Defrost Finance 是位于 AVAX 链上的 Defi 项目，经过了 Certik 的审计，且被 AVAX 链官方推广过。2022年12月23日，Defrost Finance V2 遭到闪电贷攻击，损失17K的资金。紧接着在12月25日，Defrost Finance V1 又遭受恶意攻击，攻击者将预言机修改为恶意地址，铸造了1亿枚 H2O代币，同时恶意清算了大量的仓位，项目损失了12M的资金。短时间内遭受两次攻击，且第二次攻击属于特权攻击，加上受害者无法联系到项目方，很难让人不去相信一切都是项目方监守自盗。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>我们只看23号的攻击，攻击者使用闪电贷针对的V2版本的攻击。</p><p>攻击交易哈希：</p><p><a href="https://snowtrace.io/tx/0xc6fb8217e45870a93c25e2098f54f6e3b24674a3083c30664867de474bf0212d">https://snowtrace.io/tx/0xc6fb8217e45870a93c25e2098f54f6e3b24674a3083c30664867de474bf0212d</a></p><p>首先攻击者调用 Defrost Finance V2 的 LendingSwitchUSDC 合约的 maxFlashLoan 方法以及 flashFee 方法，查看池子最多能贷出的 USDC 以及 贷出最大 USDC 需要的手续费，然后向攻击合约转入了手续费数量的 USDC：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212291437707.png" alt="image-20221229143718622"></p><p>首先攻击者从 Trader Joe (AVAX链上的Uniswap) 的 WAVAX-USDC 池子中闪电贷出了 194263.946117个 USDC，然后在 Joecall 回调函数中调用 Defrost Finance V2 的 LendingSwitchUSDC 合约的 flashloan 方法，继续贷出 194263.946117个 USDC：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212291437643.png" alt="image-20221229143737610"></p><p>接下来在二层回调 onFlashLoan 方法中调用  LendingSwitchUSDC 合约的 deposit 方法，存入 194263.946117个 USDC，并铸造了1844317.410414个 LSWUSDC。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212291447318.png" alt="image-20221229144754273"></p><p>然后向 LendingSwitchUSDC 合约转入194283.372511个 USDC，归还闪电贷，LendingSwitchUSDC 合约里会将其存入 AAVE，到这里 LendingSwitchUSDC 合约的 flashloan 方法结束。</p><p>然后继续调用 LendingSwitchUSDC 合约的 redeem 方法，提取出 368503793484个 USDC，最后归还 Trander Joe 的闪电贷，共194866.164349个USDC：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212291454114.png" alt="image-20221229145433071"></p><p>到这里针对 V2 的闪电贷攻击流程就结束了。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>针对 V2 的攻击异常点在于攻击者调用 LendingSwitchUSDC 合约的 flashLoan 方法，在回调函数中调用 deposit 方法，存入了194263.946117个 USDC，但是在 flashLoan 方法结束后调用 redeem 方法取出了368503. 793484个 USDC。</p><p>查看 redeem 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function redeem(uint256 shares,address receiver,address owner) external returns (uint256) &#123;</span><br><span class="line">        uint256 _value = convertToAssets(shares);</span><br><span class="line">        _withdraw(_value,shares,receiver,owner);</span><br><span class="line">        emit Withdraw(msg.sender,receiver,_value,shares);</span><br><span class="line">        return _value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要点在 _value 的计算上，查看 convertToAssets ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function convertToAssets(uint256 _shareNum) public view returns(uint256)&#123;</span><br><span class="line">        return _shareNum.mul(getTotalAssets())/totalSupply();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 getTotalAssets 方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getTotalAssets() internal virtual override(superSwitchErc20,superTokenInterface) view returns (uint256)&#123;</span><br><span class="line">        return getAvailableBalance().add(totalAssetAmount());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 getAvailableBalance 是当前 AAVE 包装代币的余额，而 totalAssetAmount 计算出来是一个固定的值，可以不用理会。</p><p>即 _value &#x3D; amount * (getAvailableBalance  + totalAssetAmount ) &#x2F; totalSupply</p><p>正常情况下 redeemAmount 会等于 depositAmount。</p><p>查看合约的闪电贷方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function flashLoan(</span><br><span class="line">        IERC3156FlashBorrower receiver,</span><br><span class="line">        address token,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external virtual returns (bool) &#123;</span><br><span class="line">        require(token == address(asset),&quot;flash borrow token Error!&quot;);</span><br><span class="line">        uint256 fee = flashFee(token, amount);</span><br><span class="line">        onWithdraw(address(receiver),amount);</span><br><span class="line">        require(</span><br><span class="line">            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,</span><br><span class="line">            &quot;invalid return value&quot;</span><br><span class="line">        );</span><br><span class="line">        onDeposit(address(receiver),amount + fee,0);</span><br><span class="line">        emit FlashLoan(msg.sender,address(receiver),token,amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到逻辑是先去 AAVE 提款给 receiver， 然后调用 receiver.onFlashLoan 方法，最后再将还款存入到 AAVE。</p><p>攻击者在闪电贷的情况下调用 deposit 方法，取钱时 getAvailableBalance 为 0 ，闪电贷结束时，getAvailableBalance 的值为攻击者 deposit 的数量加上闪电贷还款存入 AAVE 的数量，和普通的 deposit 相比，</p><p>getAvailableBalance 的值 多了 flashloanAmount + fee。因此攻击者 redeem 时能够获得更多的 USDC。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Defi 中使用 token.balanceOf(address(this)) 这个方法有一定的风险，需要谨慎对待，另外在重要方法中加入重入锁也能够增加安全性。在各类 Defi 项目层出不穷的情况下，判定项目是否有 rug pull 的风险十分重要。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSwap攻击事件分析</title>
      <link href="/2022/12/19/ElasticSwap%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2022/12/19/ElasticSwap%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>2022年12月14日，ElasticSwap 项目遭到黑客攻击，在以太坊上的 AMPL-USDC 池子被盗，黑客获利445个 ETH。发生该事件的根本原因是合约中添加流动性和移除流动性两个操作使用的是两种不同数据源。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>攻击交易哈希：</p><p><a href="https://etherscan.io/tx/0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f">https://etherscan.io/tx/0xb36486f032a450782d5d2fac118ea90a6d3b08cac3409d949c59b43bcd6dbb8f</a></p><p>首先攻击者调用 approve 进行授权，然后在 Uniswap V2 的 WETH-AMPL、USDC-USDT 池子调用闪电贷借出  AMPL 和 USDC:</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191805085.png" alt="image-20221219180551047"></p><p>然后第二次回调 uniswapV2Call 时候开始进攻攻击。</p><p>首先向 AMPL-USDC-ELATICSWAP 池子中添加两次流动性，第一次添加只转入了 AMPL，第二次添加转入了 AMPL 和 USDC ：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191807575.png" alt="image-20221219180711548"></p><p>然后攻击者调用 transfer 方法向池子中转入 USDC，增加 baseTokenReserveQty 的值，然后再移除流动性：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191808838.png" alt="image-20221219180857807"></p><p>这里攻击者 AMPL 以及 USDC 都没有回本，尤其是 AMPL，所以攻击者先将部分的 USDC 换成了 AMPL，使得能够归还闪电贷，然后再进行添加&#x2F;移除流动性操作，继续套利：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191810785.png" alt="image-20221219181023753"></p><p>在进行了以上的操作后攻击者已经成功获利，然后攻击者开始归还闪电贷，在二层回调归还 USDC，一层回调归还 AMPL：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191812259.png" alt="image-20221219181250211"></p><p>最后攻击者将获得的 AMPL 以及 USDC 全部换成 ETH，然后转移：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191813297.png" alt="image-20221219181330257"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>由上面的事件分析可以看到异常点位于添加&#x2F;移除流动性时，首先查看 Exchange 合约(类似Uinswap 的 Pair 合约)的 addLiquidity 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function addLiquidity(</span><br><span class="line">        uint256 _baseTokenQtyDesired,</span><br><span class="line">        uint256 _quoteTokenQtyDesired,</span><br><span class="line">        uint256 _baseTokenQtyMin,</span><br><span class="line">        uint256 _quoteTokenQtyMin,</span><br><span class="line">        address _liquidityTokenRecipient,</span><br><span class="line">        uint256 _expirationTimestamp</span><br><span class="line">    ) external nonReentrant() isNotExpired(_expirationTimestamp) &#123;</span><br><span class="line">        uint256 totalSupply = this.totalSupply();</span><br><span class="line">        MathLib.TokenQtys memory tokenQtys =</span><br><span class="line">            MathLib.calculateAddLiquidityQuantities(</span><br><span class="line">                _baseTokenQtyDesired,</span><br><span class="line">                _quoteTokenQtyDesired,</span><br><span class="line">                _baseTokenQtyMin,</span><br><span class="line">                _quoteTokenQtyMin,</span><br><span class="line">                IERC20(baseToken).balanceOf(address(this)),</span><br><span class="line">                totalSupply,</span><br><span class="line">                internalBalances</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">         _mint(_liquidityTokenRecipient, tokenQtys.liquidityTokenQty); // mint liquidity tokens to recipient</span><br></pre></td></tr></table></figure><p>可以看到关键点在 MathLib.calculateAddLiquidityQuantities 这个函数，找到这个函数的关键代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">function calculateAddLiquidityQuantities(</span><br><span class="line">        uint256 _baseTokenQtyDesired,</span><br><span class="line">        uint256 _quoteTokenQtyDesired,</span><br><span class="line">        uint256 _baseTokenQtyMin,</span><br><span class="line">        uint256 _quoteTokenQtyMin,</span><br><span class="line">        uint256 _baseTokenReserveQty,</span><br><span class="line">        uint256 _totalSupplyOfLiquidityTokens,</span><br><span class="line">        InternalBalances storage _internalBalances</span><br><span class="line">    ) public returns (TokenQtys memory tokenQtys) &#123;</span><br><span class="line">    if (</span><br><span class="line">                    quoteTokenQtyFromDecay &lt; _quoteTokenQtyDesired &amp;&amp;</span><br><span class="line">                    baseTokenQtyFromDecay &lt; _baseTokenQtyDesired</span><br><span class="line">                ) &#123;</span><br><span class="line">                    // the user still has qty that they desire to contribute to the exchange for liquidity</span><br><span class="line">                    (</span><br><span class="line">                        tokenQtys.baseTokenQty,</span><br><span class="line">                        tokenQtys.quoteTokenQty,</span><br><span class="line">                        tokenQtys.liquidityTokenQty</span><br><span class="line">                    ) = calculateAddTokenPairLiquidityQuantities(</span><br><span class="line">                        _baseTokenQtyDesired - baseTokenQtyFromDecay, // safe from underflow quoted on above IF</span><br><span class="line">                        _quoteTokenQtyDesired - quoteTokenQtyFromDecay, // safe from underflow quoted on above IF</span><br><span class="line">                        0, // we will check minimums below</span><br><span class="line">                        0, // we will check minimums below</span><br><span class="line">                        _totalSupplyOfLiquidityTokens +</span><br><span class="line">                            liquidityTokenQtyFromDecay,</span><br><span class="line">                        _internalBalances // NOTE: these balances have already been updated when we did the decay math.</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                tokenQtys.baseTokenQty += baseTokenQtyFromDecay;</span><br><span class="line">                tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay;</span><br><span class="line">                tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay;</span><br><span class="line"></span><br><span class="line">                require(</span><br><span class="line">                    tokenQtys.baseTokenQty &gt;= _baseTokenQtyMin,</span><br><span class="line">                    &quot;MathLib: INSUFFICIENT_BASE_QTY&quot;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                require(</span><br><span class="line">                    tokenQtys.quoteTokenQty &gt;= _quoteTokenQtyMin,</span><br><span class="line">                    &quot;MathLib: INSUFFICIENT_QUOTE_QTY&quot;</span><br><span class="line">                );</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // the user is just doing a simple double asset entry / providing both base and quote.</span><br><span class="line">                (</span><br><span class="line">                    tokenQtys.baseTokenQty,</span><br><span class="line">                    tokenQtys.quoteTokenQty,</span><br><span class="line">                    tokenQtys.liquidityTokenQty</span><br><span class="line">                ) = calculateAddTokenPairLiquidityQuantities(</span><br><span class="line">                    _baseTokenQtyDesired,</span><br><span class="line">                    _quoteTokenQtyDesired,</span><br><span class="line">                    _baseTokenQtyMin,</span><br><span class="line">                    _quoteTokenQtyMin,</span><br><span class="line">                    _totalSupplyOfLiquidityTokens,</span><br><span class="line">                    _internalBalances</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>可以看到会调用 calculateAddTokenPairLiquidityQuantities 计算 tokenQtys 中的值。跟进该函数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">function calculateAddTokenPairLiquidityQuantities(</span><br><span class="line">        uint256 _baseTokenQtyDesired,</span><br><span class="line">        uint256 _quoteTokenQtyDesired,</span><br><span class="line">        uint256 _baseTokenQtyMin,</span><br><span class="line">        uint256 _quoteTokenQtyMin,</span><br><span class="line">        uint256 _totalSupplyOfLiquidityTokens,</span><br><span class="line">        InternalBalances storage _internalBalances</span><br><span class="line">    )</span><br><span class="line">        public</span><br><span class="line">        returns (</span><br><span class="line">            uint256 baseTokenQty,</span><br><span class="line">            uint256 quoteTokenQty,</span><br><span class="line">            uint256 liquidityTokenQty</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        uint256 requiredQuoteTokenQty =</span><br><span class="line">            calculateQty(</span><br><span class="line">                _baseTokenQtyDesired,</span><br><span class="line">                _internalBalances.baseTokenReserveQty,</span><br><span class="line">                _internalBalances.quoteTokenReserveQty</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        if (requiredQuoteTokenQty &lt;= _quoteTokenQtyDesired) &#123;</span><br><span class="line">            // user has to provide less than their desired amount</span><br><span class="line">            require(</span><br><span class="line">                requiredQuoteTokenQty &gt;= _quoteTokenQtyMin,</span><br><span class="line">                &quot;MathLib: INSUFFICIENT_QUOTE_QTY&quot;</span><br><span class="line">            );</span><br><span class="line">            baseTokenQty = _baseTokenQtyDesired;</span><br><span class="line">            quoteTokenQty = requiredQuoteTokenQty;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // we need to check the opposite way.</span><br><span class="line">            uint256 requiredBaseTokenQty =</span><br><span class="line">                calculateQty(</span><br><span class="line">                    _quoteTokenQtyDesired,</span><br><span class="line">                    _internalBalances.quoteTokenReserveQty,</span><br><span class="line">                    _internalBalances.baseTokenReserveQty</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">            require(</span><br><span class="line">                requiredBaseTokenQty &gt;= _baseTokenQtyMin,</span><br><span class="line">                &quot;MathLib: INSUFFICIENT_BASE_QTY&quot;</span><br><span class="line">            );</span><br><span class="line">            baseTokenQty = requiredBaseTokenQty;</span><br><span class="line">            quoteTokenQty = _quoteTokenQtyDesired;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(</span><br><span class="line">            _totalSupplyOfLiquidityTokens,</span><br><span class="line">            quoteTokenQty,</span><br><span class="line">            _internalBalances.quoteTokenReserveQty</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        _internalBalances.baseTokenReserveQty += baseTokenQty;</span><br><span class="line">        _internalBalances.quoteTokenReserveQty += quoteTokenQty;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>计算 liquidityTokenQty 使用的函数 calculateLiquidityTokenQtyForDoubleAssetEntry，跟进该函数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function calculateLiquidityTokenQtyForDoubleAssetEntry(</span><br><span class="line">        uint256 _totalSupplyOfLiquidityTokens,</span><br><span class="line">        uint256 _quoteTokenQty,</span><br><span class="line">        uint256 _quoteTokenReserveBalance</span><br><span class="line">    ) public pure returns (uint256 liquidityTokenQty) &#123;</span><br><span class="line">        liquidityTokenQty =</span><br><span class="line">            (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /</span><br><span class="line">            _quoteTokenReserveBalance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里可以发现计算 liquidityTokenQty 使用的 <code>_quoteTokenReserveBalance</code>，该值来自_internalBalances.quoteTokenReserveQty，因此添加流动性这个操作使用的 internalBalances 的数据。</p><p>再看移除流动性函数 removeLiquidity 的代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">function removeLiquidity(</span><br><span class="line">        uint256 _liquidityTokenQty,</span><br><span class="line">        uint256 _baseTokenQtyMin,</span><br><span class="line">        uint256 _quoteTokenQtyMin,</span><br><span class="line">        address _tokenRecipient,</span><br><span class="line">        uint256 _expirationTimestamp</span><br><span class="line">    ) external nonReentrant() isNotExpired(_expirationTimestamp) &#123;</span><br><span class="line">        require(this.totalSupply() != 0, &quot;Exchange: INSUFFICIENT_LIQUIDITY&quot;);</span><br><span class="line">        require(</span><br><span class="line">            _baseTokenQtyMin != 0 &amp;&amp; _quoteTokenQtyMin != 0,</span><br><span class="line">            &quot;Exchange: MINS_MUST_BE_GREATER_THAN_ZERO&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        uint256 baseTokenReserveQty =</span><br><span class="line">            IERC20(baseToken).balanceOf(address(this));</span><br><span class="line">        uint256 quoteTokenReserveQty =</span><br><span class="line">            IERC20(quoteToken).balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">        uint256 totalSupplyOfLiquidityTokens = this.totalSupply();</span><br><span class="line">        // calculate any DAO fees here.</span><br><span class="line">        uint256 liquidityTokenFeeQty =</span><br><span class="line">            MathLib.calculateLiquidityTokenFees(</span><br><span class="line">                totalSupplyOfLiquidityTokens,</span><br><span class="line">                internalBalances</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        // we need to factor this quantity in to any total supply before redemption</span><br><span class="line">        totalSupplyOfLiquidityTokens += liquidityTokenFeeQty;</span><br><span class="line"></span><br><span class="line">        uint256 baseTokenQtyToReturn =</span><br><span class="line">            (_liquidityTokenQty * baseTokenReserveQty) /</span><br><span class="line">                totalSupplyOfLiquidityTokens;</span><br><span class="line">        uint256 quoteTokenQtyToReturn =</span><br><span class="line">            (_liquidityTokenQty * quoteTokenReserveQty) /</span><br><span class="line">                totalSupplyOfLiquidityTokens;</span><br><span class="line"></span><br><span class="line">        require(</span><br><span class="line">            baseTokenQtyToReturn &gt;= _baseTokenQtyMin,</span><br><span class="line">            &quot;Exchange: INSUFFICIENT_BASE_QTY&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        require(</span><br><span class="line">            quoteTokenQtyToReturn &gt;= _quoteTokenQtyMin,</span><br><span class="line">            &quot;Exchange: INSUFFICIENT_QUOTE_QTY&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // this ensures that we are removing the equivalent amount of decay</span><br><span class="line">        // when this person exits.</span><br><span class="line">        &#123;</span><br><span class="line">            //scoping to avoid stack too deep errors</span><br><span class="line">            uint256 internalBaseTokenReserveQty =</span><br><span class="line">                internalBalances.baseTokenReserveQty;</span><br><span class="line">            uint256 baseTokenQtyToRemoveFromInternalAccounting =</span><br><span class="line">                (_liquidityTokenQty * internalBaseTokenReserveQty) /</span><br><span class="line">                    totalSupplyOfLiquidityTokens;</span><br><span class="line"></span><br><span class="line">            internalBalances.baseTokenReserveQty = internalBaseTokenReserveQty =</span><br><span class="line">                internalBaseTokenReserveQty -</span><br><span class="line">                baseTokenQtyToRemoveFromInternalAccounting;</span><br><span class="line"></span><br><span class="line">            // We should ensure no possible overflow here.</span><br><span class="line">            uint256 internalQuoteTokenReserveQty =</span><br><span class="line">                internalBalances.quoteTokenReserveQty;</span><br><span class="line">            if (quoteTokenQtyToReturn &gt; internalQuoteTokenReserveQty) &#123;</span><br><span class="line">                internalBalances</span><br><span class="line">                    .quoteTokenReserveQty = internalQuoteTokenReserveQty = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                internalBalances</span><br><span class="line">                    .quoteTokenReserveQty = internalQuoteTokenReserveQty =</span><br><span class="line">                    internalQuoteTokenReserveQty -</span><br><span class="line">                    quoteTokenQtyToReturn;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            internalBalances.kLast =</span><br><span class="line">                internalBaseTokenReserveQty *</span><br><span class="line">                internalQuoteTokenReserveQty;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (liquidityTokenFeeQty != 0) &#123;</span><br><span class="line">            _mint(</span><br><span class="line">                IExchangeFactory(exchangeFactoryAddress).feeAddress(),</span><br><span class="line">                liquidityTokenFeeQty</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _burn(msg.sender, _liquidityTokenQty);</span><br><span class="line">        IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);</span><br><span class="line">        IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);</span><br><span class="line">        emit RemoveLiquidity(</span><br><span class="line">            msg.sender,</span><br><span class="line">            baseTokenQtyToReturn,</span><br><span class="line">            quoteTokenQtyToReturn</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关键的部分代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint256 baseTokenReserveQty =</span><br><span class="line">    IERC20(baseToken).balanceOf(address(this));</span><br><span class="line">uint256 quoteTokenReserveQty =</span><br><span class="line">    IERC20(quoteToken).balanceOf(address(this));</span><br><span class="line">uint256 baseTokenQtyToReturn =</span><br><span class="line">    (_liquidityTokenQty * baseTokenReserveQty) /</span><br><span class="line">        totalSupplyOfLiquidityTokens;</span><br><span class="line">uint256 quoteTokenQtyToReturn =</span><br><span class="line">    (_liquidityTokenQty * quoteTokenReserveQty) /</span><br><span class="line">        totalSupplyOfLiquidityTokens;</span><br><span class="line">_burn(msg.sender, _liquidityTokenQty);</span><br><span class="line">IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);</span><br><span class="line">IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);</span><br></pre></td></tr></table></figure><p>可以看到池子储量代币量使用的 balanceOf(address(this)) 数据，用户移除流动性获得的代币为：用户的流动性 * 池子储量 &#x2F; 总的流动性。</p><p>添加流动性时使用的 internalBalabnces 数据，而移除流动性时使用的 balanceOf(address(this)) 数据。</p><p>因此添加流动性后，往池子内转入相应的代币，然后再移除流动性，此时计算的 quoteTokenReserveQty 则会变大，因此用户获得的代币也会相应变大。</p><p>正常移除流动性所得：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liquidity * Reserve / totalliquidity;</span><br></pre></td></tr></table></figure><p>往池子内转入代币后再移除流动性所得：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liquidity * (Reserve + Tansfer) / totalliquidity;</span><br></pre></td></tr></table></figure><p>那么多获得的数量为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liquidity * Tansfer / totalliquidity</span><br></pre></td></tr></table></figure><p>再减去转入的代币后计算出一次添加&#x2F;移除流动性的获利：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liquidity * Tansfer / totalliquidity - Transfer = （（liquidity / totalliquidity）-1）* Transfer</span><br></pre></td></tr></table></figure><p>由于<code>liquidity / totalliquidity</code> 是肯定小于1的，因此如果只是添加&#x2F;移除流动性一次的话是无法获利的，但是我们可以通过多次的添加&#x2F;移除流动性操作来完成获利，因为池子没有方法来平衡 internalBalances 和 balancesOf(address(this))，转入池子的代币会让这两个变量一直存在差值。所以我们只要保证 <code>(liquidity / totalliquidity) * N &gt; 1</code> 即可获利，N 为添加&#x2F;移除流动性操作的次数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>合约中添加流动性和移除流动性使用的数据源不同导致了这次的攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NimbusPlatform攻击事件分析</title>
      <link href="/2022/12/19/NimbusPlatform%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2022/12/19/NimbusPlatform%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>2022年12月24日，BSC 链上的 NimbusPlatform 项目遭到攻击，损失大约278个  BNB。遭受攻击的根本原因是其质押合约使用的预言机存在缺陷，可以被操控。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>攻击交易哈希：</p><p><a href="https://bscscan.com/tx/0x42f56d3e86fb47e1edffa59222b33b73e7407d4b5bb05e23b83cb1771790f6c1">https://bscscan.com/tx/0x42f56d3e86fb47e1edffa59222b33b73e7407d4b5bb05e23b83cb1771790f6c1</a></p><p>首先攻击者从三个池子中闪电贷出 WBNB 共计75477个，分别是 DODO、Biswap-WBNB-BUSD、 Biswap-USDT-WBNB，并全部将其兑换成 NBU_WBNB :</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191506846.png" alt="image-20221219150608781"></p><p>然后给 NimbusRouter 授权，调用 swapExactTokensForTokensSupportingFeeOnTransferTokens 将 NBU_WBNB 兑换成 NIMB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191517099.png" alt="image-20221219151728055"></p><p>然后调用 0xe166a1d4b551db58c80ad3de194a01ec20d9c47d 合约的 0xa66edba2 方法，该方法调用 StakingRewardFixedAPY.getReward，获取GNIMB，然后再调用 0xe166a1d4b551db58c80ad3de194a01ec20d9c47d 的 0x484e4699 方法，该方法调用 StakingRewardFixedAPY.withdraw，提出 GNIMB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191529024.png" alt="image-20221219152859985"></p><p>然后攻击者调用其他两个攻击合约的方法，利用相同的方法，从质押池中提取奖励 GNIMB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191532011.png" alt="image-20221219153204972"></p><p>到这里攻击者提取奖励阶段完成了，接下来就是将各个池子掏空。</p><p>首先在 Biswap-NBU_WBNB-NIMB 池子中将NIMB兑换成 NBU_WBNB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191602221.png" alt="image-20221219160206190"></p><p>然后攻击者多次调用 NimbusRouter.getAmountsOut 方法，寻找兑换 NBU_WBNB 最多的方式：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191606878.png" alt="image-20221219160606842"></p><p>接着在 Biswap-GNIMB-NIMB 池子中将部分 GNIMB 兑换成 NIMB，然后将兑换的 NIMB 在 Biswap-NBU_WBNB-NIMB 池子中兑换成 NBU_WBNB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191611995.png" alt="image-20221219161151952"></p><p>最后将剩下的 GNIMB 在Biswap-GNIMB-NBU_WBNB 池子中兑换成 NBU_WBNB：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191613032.png" alt="image-20221219161348986"></p><p>最后将 NBU_WBNB 兑换成 BNB，再将 BNB 换成 WBNB，归还闪电贷，转移攻击获利：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191618075.png" alt="image-20221219161817037"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>通过上面的攻击步骤能发现异常点在攻击者提取奖励时，攻击者每次提取奖励都能够提取巨量的奖励，我们找到 StakingRewardFixedAPY 合约的 getReward 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getReward() public override nonReentrant whenNotPaused &#123;</span><br><span class="line">        uint256 reward = earned(msg.sender);</span><br><span class="line">        if (reward &gt; 0) &#123;</span><br><span class="line">            for (uint256 i = 0; i &lt; stakeNonces[msg.sender]; i++) &#123;</span><br><span class="line">                stakeNonceInfos[msg.sender][i].stakeTime = block.timestamp;</span><br><span class="line">            &#125;</span><br><span class="line">            rewardsPaymentToken.safeTransfer(msg.sender, reward);</span><br><span class="line">            emit RewardPaid(msg.sender, address(rewardsPaymentToken), reward);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>奖励的数量由 earned 方法计算，找到 earned 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function earned(address account) public view override returns (uint256 totalEarned) &#123;</span><br><span class="line">        for (uint256 i = 0; i &lt; stakeNonces[account]; i++) &#123;</span><br><span class="line">            totalEarned += earnedByNonce(account, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>OK，继续套娃，找到 earnedByNonce 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function earnedByNonce(address account, uint256 nonce) public view returns (uint256) &#123;</span><br><span class="line">        uint256 amount = stakeNonceInfos[account][nonce].rewardsTokenAmount * </span><br><span class="line">            (block.timestamp - stakeNonceInfos[account][nonce].stakeTime) *</span><br><span class="line">             stakeNonceInfos[account][nonce].rewardRate / (100 * rewardDuration);</span><br><span class="line">        return getTokenAmountForToken(address(rewardsToken), address(rewardsPaymentToken), amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 amount 取决于质押的数量以及时间以及 rewardRate 变量，该变量在合约构造函数中初始化，因此 amount 攻击者无法操控，继续看 getTokenAmountForToken 方法，其中 tokenSrc 是 NIMB，tokenDest 是 GNIMB ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getTokenAmountForToken(address tokenSrc, address tokenDest, uint256 tokenAmount) public view returns (uint) &#123; </span><br><span class="line">        if (tokenSrc == tokenDest) return tokenAmount;</span><br><span class="line">        if (usePriceFeeds &amp;&amp; address(priceFeed) != address(0)) &#123;</span><br><span class="line">            (uint256 rate, uint256 precision) = priceFeed.queryRate(tokenSrc, tokenDest);</span><br><span class="line">            return tokenAmount * rate / precision;</span><br><span class="line">        &#125; </span><br><span class="line">        address[] memory path = new address[](2);</span><br><span class="line">        path[0] = tokenSrc;</span><br><span class="line">        path[1] = tokenDest;</span><br><span class="line">        return swapRouter.getAmountsOut(tokenAmount, path)[1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里如果不使用 priceFeed 则返回 getAmountsOut 的值，如果使用 priceFeed 则调用 priceFeed的 queryRate 方法，并返回 <code>tokenAmount * rate / precision</code> 的值，跟进 queryRate 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function queryRate(</span><br><span class="line">        address sourceToken,</span><br><span class="line">        address destToken)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 rate, uint256 precision)</span><br><span class="line">    &#123;</span><br><span class="line">        require(!globalPricingPaused, &quot;pricing is paused&quot;);</span><br><span class="line">        return _queryRate(</span><br><span class="line">            sourceToken,</span><br><span class="line">            destToken</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续套娃，查看 _queryRate 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function _queryRate(</span><br><span class="line">        address sourceToken,</span><br><span class="line">        address destToken)</span><br><span class="line">        internal</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 rate, uint256 precision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sourceToken != destToken) &#123;</span><br><span class="line">            uint256 sourceRate = _queryRateCall(sourceToken);</span><br><span class="line">            uint256 destRate = _queryRateCall(destToken);</span><br><span class="line"></span><br><span class="line">            rate = sourceRate</span><br><span class="line">                .mul(WEI_PRECISION)</span><br><span class="line">                .div(destRate);</span><br><span class="line"></span><br><span class="line">            precision = _getDecimalPrecision(sourceToken, destToken);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rate = WEI_PRECISION;</span><br><span class="line">            precision = WEI_PRECISION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的 rate 由 sourceRate、destRate相除所得，这俩又由 _queryRateCall 求出，查看该函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function _queryRateCall(</span><br><span class="line">        address token)</span><br><span class="line">        internal</span><br><span class="line">        view</span><br><span class="line">        returns (uint256 rate)</span><br><span class="line">    &#123;</span><br><span class="line">        if (token != address(wbnbToken)) &#123;</span><br><span class="line">            IPriceFeedsExt _Feed = pricesFeeds[token];</span><br><span class="line">            require(address(_Feed) != address(0), &quot;unsupported price feed&quot;);</span><br><span class="line">            rate = uint256(_Feed.latestAnswer());</span><br><span class="line">            require(rate != 0 &amp;&amp; (rate &gt;&gt; 128) == 0, &quot;price error&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rate = WEI_PRECISION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到由 pricesFeeds[token].latestAnswer 求出，找到两种代币对应的 pricesFeeds[token]，然后查看其 latestAnswer 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function latestAnswer() external override view returns (uint256) &#123;</span><br><span class="line">        return swapRouter.getAmountsOut(10 ** decimals, swapPath)[swapPath.length - 1] * multiplier / MULTIPLIER_DEFAULT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到 latestAnswer 方法就是调用 swapRouter 的 getAmountsOut 方法，其中 swapPath 是用两种代币兑换 NBU_WBNB，即 1 个 NIMB 或者 GNIMMB 能兑换多少个 NBU_WBNB。</p><p>那么最终可以得出，PriceFeeds.queryRate方法的值为 Biswap-NBU_WBNB-NIMB 池子中 NIMB 的价格除以 Biswap-GNIMB-NBU_WBNB 池子中 GNIMB的价格。</p><p>攻击者最开始通过闪电贷借入了大量的 WBNB，将其兑换为 NBU_WBNB 并 swap 成 NIMB ，因此  Biswap-NBU_WBNB-NIMB 池子中 NIMB 的价格大幅度上涨，而 GNIMB 的价格不变，因此 queryRate 的返回值变大，攻击者获取质押奖励时也会变多。</p><p>到这里漏洞分析结束。</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>项目方在攻击事件发生后，重新部署了预言机合约，将链上预言机修改成了链下预言机，latestAnswer 方法的值由  owner 设置：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202212191740800.png" alt="image-20221219174024749"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>质押合约使用的预言机存在缺陷导致了此次漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GenomesDao攻击事件学习</title>
      <link href="/2022/08/08/GenomesDao%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/08/08/GenomesDao%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>UTC 时间2022年8月5日8时，MATIC 链上的项目 GenomesDAO 被攻击，其 LPSTAKING 合约以及 VeGnomeLock 合约中的资金被盗走。事件的主要原因是因为合约中的 <code>initialized</code> 函数可被无限制调用。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>攻击者 EOA 地址：</p><p>0x43EC1D163cc4C15B574F86d8203c3B0F3EbED7a3</p><p>攻击合约：</p><p>0x9aa63491bb927f024d37b0e6017137f7f03da3c6</p><p>0x8e10c9493501a828304d77630b6f862bbf50c052</p><p>0x4a7c088099f744d5c6c838c71502a04e0983f266</p><p>攻击交易哈希：</p><p>0x252a7e6f23ffb516c23df2a3b2e09b42d00a06fa4e9a5830e74fb35581f7632c</p><p>0x82cebaf092bc6a4c9235daeda6a9b504a873844c41dc31c51dbeebbab96a90bf</p><p>首先查看交易 0x252a7e6f23ffb516c23df2a3b2e09b42d00a06fa4e9a5830e74fb35581f7632c ，其首先通过代理合约调用了 <code>LPStakingOnPoly</code> 合约的 <code>initialized</code> 方法，更新了 <code>_stakingToken</code> 的值，修改为攻击者创建的攻击合约的地址：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091117586.png" alt="image-20220809111743544"></p><p>然后调用通过代理合约 <code>LPStakingOnPoly</code> 的 <code>stake</code> 方法，质押数量为 946677946000000000000。由于其 <code>_stakingToken</code> 的值已经被攻击者控制，因此会 stake 虚假的代币，并修改相应的 <code>_balances</code> 的值：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091133094.png" alt="image-202208091133094"></p><p>接下来攻击者再次调用 <code>LPStakingOnPoly</code> 合约的 <code>initialized</code> 方法，将 <code>_stakingToken</code> 的值修改为正常的 <code>SushiSwap LP Token</code> 的地址：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091137779.png" alt="image-20220809113731748"></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091137969.png" alt="image-20220809113751939"></p><p>然后攻击者通过代理合约调用 <code>LPStakingOnPoly</code> 合约的 <code>withdraw</code> 方法，由于 <code>_stakingToken</code> 的值已经变成正常的 <code>SushiSwap LP Token</code> 的地址，因此攻击者提取了 946677946000000000000 数量的 LP：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091143644.png" alt="image-20220809114314607"></p><p>接下来攻击者继续重复上面的步骤，先 <code>initialized</code> 修改为虚假的代币地址，然后再 <code>satke</code> ，接着再 <code>initialized</code> 为真实的代币地址，最后调用 <code>withdraw</code> 提取真实的代币。不同的地方在于修改的真实代币的地址不同。</p><p>改笔交易最后还对 <code>VeGnomeLock</code> 合约进行了攻击，因为使用了一样的 <code>initialized</code> 方法。具体步骤是先  <code>initialized</code> 修改 <code>_lockToken</code> 为虚假代币地址，然后调用 <code>lock</code> 进行锁仓，接着再 <code>initialized</code> 为真实的代币地址，最后调用 <code>emergencyUnlock</code> 方法解除锁仓，提取真实代币。</p><p>攻击者通过以上步骤提取的大量的真实代币：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091157609.png" alt="image-20220809115729565"></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091157044.png" alt="image-20220809115744008"></p><p>然后再看交易 0x82cebaf092bc6a4c9235daeda6a9b504a873844c41dc31c51dbeebbab96a90bf，攻击者将获取到的 <code>LP Token</code> 兑换成相应的代币，最后将 WETH 发送至攻击者的 EOA 地址：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091203033.png" alt="image-20220809120349999"></p><p>后续攻击者通过 anyswap 进行兑换及转移资产：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091215164.png" alt="image-20220809121532123"></p><h2 id="漏洞详解"><a href="#漏洞详解" class="headerlink" title="漏洞详解"></a>漏洞详解</h2><p>漏洞点位于 <code>initialized</code> 方法，该函数可见性为 <code>public</code> ，其位于父合约中，作用就是初始化质押代币的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function initialized(address _stakingToken, string memory _nameArg, string memory _symbolArg) public &#123; </span><br><span class="line">        stakingToken = IERC20(_stakingToken); </span><br><span class="line">        name = _nameArg;</span><br><span class="line">        symbol = _symbolArg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后子合约中存在 <code>initialize</code> 方法，该方法会调用父合约的  <code>initialized</code> 方法，进行初始化操作，且带有修饰器 <code>initializer</code> ，只能够调用一次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function initialize(</span><br><span class="line">        string memory _name,</span><br><span class="line">        string memory _symbol,</span><br><span class="line">        address _stakingToken,</span><br><span class="line">        address _rewardToken,</span><br><span class="line">        address _veToken</span><br><span class="line">    ) public initializer &#123;</span><br><span class="line">        __Ownable_init();</span><br><span class="line">        LPStakingOnPolyWrapper.initialized(</span><br><span class="line">            _stakingToken,</span><br><span class="line">            _name,</span><br><span class="line">            _symbol</span><br><span class="line">        );</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是其并未重写 <code>initialized</code> 方法，并且其可见性为 <code>public</code> ，因此任何人都可以调用该方法。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208091225289.png" alt="image-20220809122554246"></p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>将父合约的 <code>initialized</code> 方法的可见性修改为 <code>internal</code> ，或者添加修饰器进行限定。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此次攻击事件原理较为简单，在编写合约时务必考虑好各个方法的可见性，防止发生越权。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wormhole赏金漏洞学习</title>
      <link href="/2022/08/08/Wormhole%E8%B5%8F%E9%87%91%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/08/08/Wormhole%E8%B5%8F%E9%87%91%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Wormhole 是一个跨链桥，可以连接到多个链，如 solana、Ethereum、BSC 等。2022年2月24日，名为 satya0x 的白帽子负责任地披露了以太坊上 Wormhole 核心桥接合约的一个严重漏洞，该漏洞和可升级的代理合约有关。Wormhole 向 satya0x 支付了创纪录的 1000 万美元的漏洞赏金（太猛了家人们就是说）。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><p><code>delegatecall</code> 和 <code>call</code></p><p><code>delegatecall</code> 不会修改 <code>msg</code> 中的信息，且会将调用的合约在当前合约中运行（执行环境为当前合约），也就是 storage 使用的当前合约。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208081816926.png" alt="image-20220802131753090"></p><p><code>call</code> 会修改 <code>msg.sender</code> 为当前合约，但是执行环境在调用的目标合约。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208081817047.png" alt="image-20220802160252935"></p></li><li><p>透明代理模式 (TPP) 和通用可升级代理标准 (UUPS)</p><p>通过 <code>delegatecall</code> 的特性，我们可以实现可升级的合约。代理合约除了通过 <code>delegatecall</code> 调用实现合约，其本身也会实现一些方法，如 <code>upgradeTo</code>，如果实现合约中存在同名方法，那如何判断到底调哪个合约的方法呢？</p><p>其中透明代理模式（TPP）是一种解决方式，具体做法是当调用者是代理合约的管理员时，调用的是代理合约的方法；当调用者是其他的用户地址时，通过代理合约调用逻辑合约的方法。在该模式中，如果调用者是代理的管理员，则代理合约不会进行任何 <code>delegatecall </code>调用。</p><p>通用可升级代理标准则（UUPS）是一种新的方式，其和透明代理模式的区别在于，透明代理模式的升级逻辑在代理合约中，而 UUPS 则在实现合约中。</p></li></ul><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>Wormhole采用的代理模式为 UUPS，也就是升级逻辑也存在在实现合约中，项目方只通过代理合约调用了 <code>initialize</code> 方法，未在实现合约中调用该方法，而该方法默认所有人都可调用，因此漏洞攻击的路径如下：</p><ul><li><p>攻击者调用  <code>initialize</code> 方法，初始化 <code>initialGuardians</code> 以及 <code>chainId</code>、<code>governanceChainId</code> 、<code> governanceContract</code> 等参数，其中最重要的参数为 <code>initialGuardians</code>，将其设置为攻击地址。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208081817164.png" alt="image-20220802154631646"></p></li><li><p>攻击者部署 destructor 合约，在其 <code>initialize</code> 方法中实现 destructor。</p></li><li><p>然后调用 <code>submitContractUpgrade</code> 方法，传入的参数为 bytes，其中包含了 timestamp、nonce、chainId、governance.address、destructor.address、attackerSigner.address、guardianSetIndex等。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208081817147.png" alt="image-20220802155520902"></p></li><li><p>当校验传入的 vm， 通过以后，会调用 <code>upgradeImplementation</code> 升级合约。该函数中调用 <code>_upgradeTo</code> 方法去升级合约，同时还会通过 <code>delegatecall</code> 调用新的实现合约的 <code>initialize</code> 方法。由于新的实现合约的 <code>initialize</code> 中会进行 <code>destructor</code> 操作，因此该合约会被毁掉，而代理合约没有任何逻辑实现，只靠 <code>delegatecall</code> 调用该合约，因此代理合约会无法使用。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202208081817005.png" alt="image-20220802155835903"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Wormhole 采用 UUPS 的代理模式，但未对实现合约进行初始化导致漏洞产生。</p><p>在使用 UUPS 代理模式时，需要注意实现合约初始化的问题，防止被黑客调用初始化方法获得管理员权限，从而恶意调用更新方法销毁实现合约，锁定代理合约所有资产。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://medium.com/immunefi/wormhole-uninitialized-proxy-bugfix-review-90250c41a43a">Wormhole Uninitialized Proxy Bugfix Review</a></p><p><a href="https://zhuanlan.zhihu.com/p/535263979">跨链桥：Web3黑客必争之地</a></p><p><a href="https://docs.openzeppelin.com/contracts/4.x/api/proxy#transparent-vs-uups">Transparent vs UUPS Proxies</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Audius攻击事件学习</title>
      <link href="/2022/07/27/Audius%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/07/27/Audius%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>Web3 音乐平台 Audius 在 UTC 时间2022年7月23日11点遭到攻击，其社区金库中的1850万枚 AUDIO 代币被盗，黑客在 Uniswap 上将其换成 ETH 后，转入 Tornado 。此次攻击的主要原因是代理合约和实现合约之前存在插槽冲突，导致其 <code>initialize</code> 函数可以被重复调用。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>攻击者EOA地址：0xa0c7BD318D69424603CBf91e9969870F21B8ab4c</p><p>攻击合约地址：0xbdbB5945f252bc3466A319CDcC3EE8056bf2e569</p><p>攻击交易HASH：</p><p>0xfefd829e246002a8fd061eede7501bccb6e244a9aacea0ebceaecef5d877a984</p><p>0x3c09c6306b67737227edc24c663462d870e7c2bf39e9ab66877a980c900dd5d5</p><p>0x4227bca8ed4b8915c7eec0e14ad3748a88c4371d4176e16e8007249b9980dc9</p><p>首先攻击者部署攻击合约 0xbdbB5945f252bc3466A319CDcC3EE8056bf2e569，然后调用攻击合约的 <code>0x5bc7c6ac</code> 方法，交易哈希为 0xfefd829e246002a8fd061eede7501bccb6e244a9aacea0ebceaecef5d877a984，具体的调用的函数如下：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272153466.png" alt="image-20220727114156185"></p><p>可以看到攻击者首先通过代理合约调用了 <code>Governance</code> 合约的 <code>initialize </code>函数，进行了一系列初始化设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(_registryAddress = 0xbdbb5945f252bc3466a319cdcc3ee8056bf2e569,  _votingPeriod = 3,  _executionDelay = 0,  _votingQuorumPercent = 1,  _maxInProgressProposals = 4, _guardianAddress =  0xbdbb5945f252bc3466a319cdcc3ee8056bf2e569)</span><br></pre></td></tr></table></figure><p>在合约中找到 <code>initialize</code> 函数：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272153510.png" alt="image-20220727114930716"></p><p>发现其存在修饰器 <code>initializer</code>，找到该修饰器：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272154662.png" alt="image-20220727114843015"></p><p>第一次调用 <code>initialize</code> 时，<code>initialized</code> 以及 <code>initializing</code> 的值都为 false ，因此 require 中的条件满足，函数执行完后，<code>initialized</code> 的值变成了 true，<code>initializing</code> 的值为 false，因此被 <code>initializer </code>修饰的函数只能够调用一次。</p><p>那么攻击者是如何再次调用的呢？大概率是因为代理合约和实现合约之前的存储槽冲突。</p><p>首先看代理合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272154882.png" alt="image-20220727115940685"></p><p>该合约继承了 <code>UpgradeabilityProxy</code> 合约，查看该合约以及该合约继承的合约等，发现只有一个 <code> Implementation</code> 变量需要存储，但其插槽位于指定的位置，并非0槽：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272154561.png" alt="image-20220727120505749"></p><p>然后就是 <code>AudiusAdminUpgradeabilityProxy</code> 合约的 <code>proxyadmin</code> 变量，位于0槽。</p><p>再看实现合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155016.png" alt="image-20220727125204410"></p><p><code>Governance</code> 合约继承  <code>InitializableV2</code> 合约，<code>InitializableV2</code> 合约继承 <code>Initializable</code> 合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155223.png" alt="image-20220727125330574"></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155033.png" alt="image-20220727125400706"></p><p>因此 <code>Governance</code> 插槽0处存在 <code>initialized</code>、<code>initializing</code>、<code>isInitialized</code> 三个布尔变量，后续变量如果小于29字节也会在0槽。</p><p>因此两个合约的 storage 布局如下：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155210.png" alt="image-20220727131338142"></p><p>由于代理合约中存储实现合约的所有状态变量，因此在0槽会发生冲突：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155039.png" alt="image-20220727151904658"></p><p>当代理合约的创建后，构造函数初始化 <code>proxyAdmin</code>，因此 <code>initialized</code>、<code>initializing</code> 会被覆盖，导致其恒为 true，因此 <code>initializer</code> 修饰器失效，可以无限制调用 <code>initialize</code> 函数。</p><p>攻击合约调用完 <code>initialize</code> 函数后，调用 <code>evaluateProposalOutcome </code> 函数评估84提案，但并未成功执行该提案。</p><p>然后调用 <code>AUDIO</code> 合约的 <code>balanceOf</code> 函数查看代币余额。</p><p>接着调用 <code>submitProposal</code> 函数发起新的提案，提案内容为向攻击合约转币，数量为1850万：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(_targetContractRegistryKey = 3078000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">,  _callValue = 0,  _functionSignature = transfer(address,uint256),  _callData = 000000000000000000000000bdbb5945f252bc3466a319cdcc3ee8056bf2e569</span><br><span class="line">0000000000000000000000000000000000000000000f5b2f71812d138f71f6f5,  _name = Hello,  _description = World)</span><br></pre></td></tr></table></figure><p>接着调用 <code>Staking</code> 的 <code>initialize </code> 函数，将攻击合约地址设置为 <code>tokenAddress</code>、<code>governanceAddress</code>。</p><p>调用 <code>DelegateManagerV2</code> 的 <code>initialize </code> 函数，将攻击合约地址设置为 <code>tokenAddress</code>、<code>governanceAddress</code>。</p><p>调用 <code>DelegateManagerV2</code> 的 <code>setServiceProviderFactoryAddress</code> 函数，将攻击合约地址设置为 <code>spFactory</code>。</p><p>调用 <code>DelegateManagerV2</code> 的 <code>delegateStake</code> 函数，给攻击合约地址大量投票。</p><p>接下来攻击者调用攻击合约的 <code>0xcc66ce79</code> 函数，交易哈希为0x3c09c6306b67737227edc24c663462d870e7c2bf39e9ab66877a980c900dd5d5，相关的调用栈如下：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272155332.png" alt="image-20220727144916730"></p><p>攻击合约调用 <code>Governance</code> 合约的 <code>submitVote</code> 函数，向85号提案投票。</p><p>最后攻击者调用攻击合约的 <code>0x543db4c4</code> 函数，交易哈希为0x4227bca8ed4b8915c7eec0e14ad3748a88c4371d4176e716e8007249b9980dc9，相关调用栈如下：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272156362.png" alt="image-20220727150004645"></p><p>攻击合约调用 <code>Governance</code> 合约的 <code>evaluateProposalOutcome</code> 函数，评估85号提案，并成功执行，向攻击合约地址转了1850万枚 AUDIO 代币。</p><p>至此攻击结束，攻击者将这1850万枚代币在 Uniswap 上换成 ETH，然后转入混币器 Tornado.Cash。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>官方发声明已经修复，查看代码：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207272156927.png" alt="image-20220727150438265"></p><p>发现在 <code>Initializable</code> 合约处新增了三个变量，<code>address private proxyAdmin</code> 以及两个填充变量 <code>uint256 private filler1</code>、<code>uint256 private filler2</code>，这样就不会存在插槽冲突了。同时在修饰器 <code>initializer</code> 中添加了判断条件 <code>msg.sender == proxyAdmin</code>，限定了调用者。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代理合约与实现合约的存储槽冲突是导致此次攻击事件的主要原因。个人学习了很久才分析明白，暴露了自己在 storage 方面知识的缺失，后续还需要多学习学习。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Revest Finance攻击事件学习</title>
      <link href="/2022/07/12/Revest-Finance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/07/12/Revest-Finance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>2022年3月27日，Revest Finance 被攻击，损失大约 2M$(352,835 RENA)，主要的攻击方式为重入攻击。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>Revest Finance 的合约 Revest 提供三种方式进行质押资产，mint 相应的 FNFT：</p><ul><li>mintTimeLock : 用户质押的数字资产在一段时间之后才能被解锁；</li><li>mintValueLock : 用户质押的数字资产只有在升值或者贬值到预设数值才能被解锁；</li><li>mintAddressLock : 用户质押的数字资产只能被预设的账户解锁。</li></ul><p>例如 <code>mintAddressLock</code>，用户需要传入参数为：trigger(解锁人)，arguments(可省略)，recipients(接受人)，quantities(FNFT 数量)，FNFTConfig(结构体，包含质押物 asset，每枚 FNFT 对应的质押物数量 depositAmount 以及其他信息)。</p><p>同时还提供<code>depositAdditionalToFNFT</code>方法，用于让用户为存在的FNFT质押更多的质押物。传入的参数为：fnftId(存在的 FNFT 的 ID)，amount(每枚 FNFT 对应的质押物数量)，quantity(FNFT 数量)。其中 quantity 可以小于或者等于 mint 的数量，当等于时，合约会 burn 掉之前的 FNFT，并生成新的 FNFT，修改其对应的质押物数量；当小于时，合约会 burn 掉增加质押物数量的 FNFT，生成新的 FNFT，并修改其对应的质押物数量，此时用户存在两种 ID 的 FNFT，一种是原来质押物数量的，一种是增加了质押物数量的。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>攻击交易哈希：0xe0b0c2672b760bef4e2851e91c69c8c0ad135c6987bbf1f43f5846d89e691428</p><p>攻击者通过 uniswap 闪电贷获取了2 RENA，然后调用<code>mintAddressLock</code>，铸造 ID 为1027的 FNFT：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121843073.png" alt="image-20220712184348037"></p><p>其中解锁人以及接受人都是攻击合约，铸造 FNFT 的数量为2，质押物为 RENA，数量为0。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121845268.png" alt="image-20220712184501229"></p><p>然后攻击者再次调用<code>mintAddressLock</code>，铸造新的 FNFT，其 ID 为1028：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121849691.png" alt="image-20220712184913643"></p><p>其中解锁人以及接受人都是攻击合约，铸造 FNFT 的数量为360000，质押物为 RENA，数量依然为0。</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121849252.png" alt="image-20220712184935208"></p><p>然后攻击合约在收到此次铸造的 FNFT 后触发 <code>onERC1155Received</code>函数（攻击者通过条件判断让第一次调用<code>onERC1155Received</code>时不执行操作，第二次才执行），该函数调用 Revest 合约中的<code>depositAdditionalToFNFT</code>函数，此时攻击者传入的该函数的参数为：fnftId &#x3D; 1,027,  amount &#x3D; 1,000,000,000,000,000,000,  quantity &#x3D; 1 </p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121858323.png" alt="image-20220712185825289"></p><p>因此合约会 burn 掉 一个 ID 为1027，对应质押物为0 RENA 的 FNFT，生成一个 ID 为1028，对应质押物为1 RENA的 FNFT，至于为什么ID还是1028，因为其 handle 合约中的<code>mint</code> 函数这样写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function mint(address account, uint id, uint amount, bytes memory data)</span><br><span class="line">external </span><br><span class="line">override </span><br><span class="line">onlyRevestController </span><br><span class="line">&#123;</span><br><span class="line">        supply[id] += amount;</span><br><span class="line">        _mint(account, id, amount, data);</span><br><span class="line">        fnftsCreated += 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>depositAdditionalToFNFT</code>函数中会调用 vault 合约的<code>handleMultipleDeposits</code>函数更新对应的质押关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function handleMultipleDeposits(</span><br><span class="line">        uint fnftId,</span><br><span class="line">        uint newFNFTId,</span><br><span class="line">        uint amount</span><br><span class="line">    ) external override onlyRevestController &#123;</span><br><span class="line">        require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;);</span><br><span class="line">        IRevest.FNFTConfig storage config = fnfts[fnftId];</span><br><span class="line">        config.depositAmount = amount;</span><br><span class="line">        mapFNFTToToken(fnftId, config);</span><br><span class="line">        if(newFNFTId != 0) &#123;</span><br><span class="line">            mapFNFTToToken(newFNFTId, config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时传入的值为：fnftId&#x3D;1027，newFNFTId&#x3D;1028，amount&#x3D;1,000,000,000,000,000,000</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121910504.png" alt="image-20220712191053452"></p><p>因此最后 ID 为1028的 FNFT 对应的质押物被修改为1 RENA。之前攻击者铸造了360000枚 ID 为1028的 FNFT，再加上这新铸造的1枚，对应的质押物也就变成了360001个 RENA。</p><p>最后攻击者调用<code>withdrawNFNFT</code>函数，burn 掉 FNFT，提走 RENA，并偿还闪电贷：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202207121918924.png" alt="image-20220712191844882"></p><h2 id="额外的漏洞"><a href="#额外的漏洞" class="headerlink" title="额外的漏洞"></a>额外的漏洞</h2><p>此漏洞为 BlockSec团队发现，位于 vault 合约的<code>handleMultipleDeposits</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function handleMultipleDeposits(</span><br><span class="line">        uint fnftId,</span><br><span class="line">        uint newFNFTId,</span><br><span class="line">        uint amount</span><br><span class="line">    ) external override onlyRevestController &#123;</span><br><span class="line">        require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;);</span><br><span class="line">        IRevest.FNFTConfig storage config = fnfts[fnftId];</span><br><span class="line">        config.depositAmount = amount;</span><br><span class="line">        mapFNFTToToken(fnftId, config);</span><br><span class="line">        if(newFNFTId != 0) &#123;</span><br><span class="line">            mapFNFTToToken(newFNFTId, config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当想增加已存在的 FNTF 对应的质押物时，用户可以调用<code>depositAdditionalToFNFT</code>函数，正常逻辑是 burn 掉用户传入的数量，生成相应数量的新的 FNFT，并修改新生成的 FNFT 对应的质押关系。但是此处<code>handleMultipleDeposits</code>函数会将所有的 FNFT 的质押关系都修改，也即原来的 FNFT 和新生成的 FNFT 的质押关系都会被修改。我们可以铸造10枚 FNFT，对应质押数量为0 ，ID为1，然后调用<code>depositAdditionalToFNFT</code>，增加其中一枚的 FNFT 对应的质押数量为1，那么执行<code>handleMultipleDeposits</code>函数后，我会有9枚对应质押数量为1、ID 为1的 FNFT，1枚对应质押数量为1，ID 为2的 FNFT，算下来净获利9个币。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p><code>mint</code>以及<code>mintBatchRec</code>函数建议先修改变量状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController &#123;</span><br><span class="line">        supply[id] += amount;</span><br><span class="line">        fnftsCreated += 1;</span><br><span class="line">        _mint(account, id, amount, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function mintBatchRec(address[] calldata recipients, uint[] calldata quantities, uint id, uint newSupply, bytes memory data) external override onlyRevestController &#123;</span><br><span class="line">        supply[id] += newSupply;</span><br><span class="line">        fnftsCreated += 1;</span><br><span class="line">        for(uint i = 0; i &lt; quantities.length; i++) &#123;</span><br><span class="line">            _mint(recipients[i], id, quantities[i], data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>handleMultipleDeposits</code>函数在 <code>newFNFTId</code>为0时不修改<code>fnftId</code>对应的<code>config</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function handleMultipleDeposits(</span><br><span class="line">    uint fnftId,</span><br><span class="line">    uint newFNFTId,</span><br><span class="line">    uint amount</span><br><span class="line">) external override onlyRevestController &#123;</span><br><span class="line">    require(amount &gt;= fnfts[fnftId].depositAmount, &#x27;E003&#x27;);</span><br><span class="line">    IRevest.FNFTConfig memory config = fnfts[fnftId];</span><br><span class="line">    config.depositAmount = amount;</span><br><span class="line">    if(newFNFTId != 0) &#123;</span><br><span class="line">        mapFNFTToToken(newFNFTId, config);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mapFNFTToToken(fnftId, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此次事件攻击者通过 ERC1155 的回调结合<code>mint</code>函数和<code>handleMultipleDeposits</code>的缺陷，成功进行了攻击，攻击技巧比较巧妙，十分牛逼。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/NMdQUFZBPU5eQ_oR_JkcLg">More than Re-entrancy : Revest Finance 被攻击事件分析</a></p><p><a href="https://woods1060.github.io/2022/04/02/Revest_Finance%E9%87%8D%E5%85%A5%E6%BC%8F%E6%B4%9E/">Revest Finance漏洞–NFT的重入攻击？</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OP代币被盗事件学习</title>
      <link href="/2022/06/13/OP%E4%BB%A3%E5%B8%81%E8%A2%AB%E7%9B%97%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/13/OP%E4%BB%A3%E5%B8%81%E8%A2%AB%E7%9B%97%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>2022年6月9日，Optimism 和加密货币做市商  Wintermute 发布公告，2000万个 OP 代币被黑客盗取。OP 向 Wintermute 提供了2000万代币，委托其提供流动性服务，OP 在向 Wintermute 发送了1 OP 代币和100万 OP 两笔交且 Wintermute 确认无误后，又向其发送了1900万 OP 代币。但在发送完 OP代币后，Wintermute 发现其无法控制这些代币。因为其多签钱包只部署在以太坊主网上，未在 Optimism 网络部署，黑客通过抢先将该多签地址部署在 Optimism 网络上，成功控制代币。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="多签钱包"><a href="#多签钱包" class="headerlink" title="多签钱包"></a>多签钱包</h3><p>往区块链上发送一笔交易，需要使用钱包做一个签名，签名好后将交易发送出去，交易执行成功转装就成功，这是单签钱包。而多签钱包则是需要多个人去签名执行操作的钱包，使用时需要多个人签名发送交易后，转账操作才完成。多签钱包可以使用 m&#x2F;n 的模式，即 n 个人里有 m 个人签名即可完成操作。</p><p>常说的多签主要针对的是比特币和以太坊 ERC-20 标准代币。在比特币中有2种类型的地址，1开头的是 P2PKH，表示个人地址，3开头的是 P2SH，一般表示多签地址。普通的比特币地址是由公钥做哈希后得到的，而多重签名地址基于脚本哈希，所以能够实现复杂的交易逻辑，在原生上比特币就支持多签。而以太坊原生并不支持多签地址，多签钱包在以太坊中往往是一个智能合约。Ownbit 和 Gnosis 代表了当前主流的两种以太坊多签实现方式。其中 Wintermute 使用的 Gnosis 多签钱包。</p><h3 id="EIP155-标准"><a href="#EIP155-标准" class="headerlink" title="EIP155 标准"></a>EIP155 标准</h3><p>EIP155 标准用于防范重放攻击。</p><p>当区块高度大于 FORK_BLKNUM (2,675,000) 且 CHAIN_ID 可用时，在计算交易的哈希以进行签名时，不只是对六个 rlp 编码元素（nonce, gasprice, startgas, to, value, data）进行哈希处理，应对9个 rlp 编码元素（nonce, gasprice, startgas, to, value, data, chainid, 0, 0）进行哈希处理，所以签名后的 v 值为：{0,1} + CHAIN_ID * 2 + 35，而如果只对6个元素进行哈希处理，则签名后的 v 值为：{0,1} + 27。</p><p>当区块高度大于 FORK_BLKNUM (2,675,000) 且 v 值等于 CHAIN_ID * 2 + 35 或者 CHAIN_ID * 2 + 36 时，在计算交易的哈希以进行签名时，不只是对六个 rlp 编码元素进行哈希处理，应对9个 rlp 编码元素（nonce, gasprice, startgas, to, value, data, chainid, 0, 0）进行哈希处理。当前存在的使用 v 值等于27或者28签名方案保持有效，并继续在与以前相同的规则下运行。</p><p>简单点说的就是不加 CHAIN_ID 的签名后的 v 值在27-28之间，交易可以在不同的链上进行重放。</p><h3 id="合约地址生成方式"><a href="#合约地址生成方式" class="headerlink" title="合约地址生成方式"></a>合约地址生成方式</h3><p>智能合约生成合约地址有两种方式，分别是 CREATE 指令和 CREATE2 指令，其中使用 CREATE 指令创建的合约地址可以使用<code>keccak256(rlp.encode(deployingAddress, nonce))[12:]</code>计算出来，其中 nonce的值每发送一笔交易或者创建一个合约就会 +1。</p><p>使用 CREATE2 指令创建的合约的地址使用<code>keccak256(0xff ++ deployingAddr ++ salt ++ keccak256(init_code))[12:]</code>计算，其中 init_code 是被部署合约的字节码。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>首先是 Optimism 向 Wintermute 的多签钱包地址发送 OP 代币：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140044997.png" alt="image-20220614004415931"></p><p>由于此时 Wintermute 的多签钱包只在以太坊主网上部署，未在 Optimism 网络上部署，因此其对2000万 OP 代币无控制权。</p><p>黑客此时抢先将该多签钱包地址部署到 Optimism 网络上。</p><p>黑客攻击地址为：0x60b28637879b5a09d21b68040020ffbf7dba5107</p><p>其首先分别向两个地址 0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A、0x8BcFe4f1358E50A1db10025D731C8b3b17f04DBB转账0.2 eth、0.5 eth：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140140373.png" alt="image-20220614014044339"></p><p>其中 0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A 用来部署 Gnosis Safe 的 ProxyFactory 合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140141258.png" alt="image-20220614014131219"></p><p>0x8BcFe4f1358E50A1db10025D731C8b3b17f04DBB 则用来部署 0xe7145dd6287ae53326347f3a6694fcf2954bcd8a 合约，该合约用于多次调用 ProxyFactory 中的 <code>createProxy</code>函数：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140142685.png" alt="image-20220614014259649"></p><p>由于生成多签钱包地址的是 Gnosis Safe 的 ProxyFactory 合约，因此找到创建该合约的记录。</p><p>首先在 etherscan 搜索多签钱包地址0x4f3a120e72c76c22ae802d129f599bfdbc31cb81，然后找到其创建的记录：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140101334.png" alt="image-20220614010145311"></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140102673.png" alt="image-20220614010256645"></p><p>然后找到 Gnosis Safe 的 ProxyFactory 合约的创建记录：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140104688.png" alt="image-20220614010403652"></p><p>然后查看此时 v 值，不知道在 etherscan 如何查看，学习慢雾的方法，注册了一个 infura.io 账号，使用该命令查看详情：<code>curl -s -H &#39;content-type:application/json&#39; -d &#39;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getTransactionByHash&quot;,&quot;params&quot;:[&quot;0x75a42f240d229518979199f56cd7c82e4fc1f1a20ad9a4864c635354b4a34261&quot;],&quot;id&quot;:1&#125;&#39; https://mainnet.infura.io/v3/xxxx</code></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140106354.png" alt="image-20220614010649319"></p><p>可以看到此时的 v 值为 0x1c，换算为十进制为28，因此该 v 值不符合 EIP155标准，不带 CHAIN_ID，可以在其他链进行重放攻击，以得到相同地址的合约，攻击者在 Optimism 网络重放，得到地址与在以太坊主网相同的 ProxyFactory 合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140113772.png" alt="image-20220614011343743"></p><p>然后再看  Gnosis Safe 的 ProxyFactory 合约的源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contract ProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    event ProxyCreation(Proxy proxy);</span><br><span class="line"></span><br><span class="line">    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.</span><br><span class="line">    /// @param masterCopy Address of master copy.</span><br><span class="line">    /// @param data Payload for message call sent to new proxy contract.</span><br><span class="line">    function createProxy(address masterCopy, bytes memory data)</span><br><span class="line">        public</span><br><span class="line">        returns (Proxy proxy)</span><br><span class="line">    &#123;</span><br><span class="line">        proxy = new Proxy(masterCopy);</span><br><span class="line">        if (data.length &gt; 0)</span><br><span class="line">            // solium-disable-next-line security/no-inline-assembly</span><br><span class="line">            assembly &#123;</span><br><span class="line">                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) &#123; revert(0, 0) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        emit ProxyCreation(proxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //省略其他代码 N 行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到新建合约地址使用的<code>new Proxy(masterCopy)</code>，即使用的 CREATE 指令进行创建，合约地址是 msg.sender 以及 nonce 来计算的，由于此时工厂合约地址已经和以太坊主网相同，只需要 nonce 和在以太坊主网上生成多签钱包地址的 nonce 相同，则可完成部署，攻击者通过调用合约 0xe7145dd6287ae53326347f3a6694fcf2954bcd8a 来实现，该合约内部则多次调用 ProxyFactory 合约的<code>createProxy</code>函数，来增加 nonce 值达到该目的：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140130665.png" alt="image-20220614013033627"></p><p>最后成功将该多签钱包地址部署在 Optimism网络：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140132168.png" alt="image-20220614013208126"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>引发此次安全事件的原因：一是 Wintermute 未验证在侧链是否对其多签钱包地址具有控制权；二是 Solidity 旧版本的漏洞导致使用 CREATE 指令来创建合约地址；三是交易签名未带 CHAIN_ID，不符合 EIP155 标准导致交易可在其他链重放。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/MjvCChjEGuSTr9cELQlW_A">2000 万 OP 代币被盗关键：交易重放</a></li><li><a href="https://www.finacerun.com/index.php/home/news/detail/article_id/98429.html">重入攻击 + 管理漏洞：2000 万枚 OP 被盗事件分析</a></li><li><a href="http://www.hackdig.com/06/hack-684523.htm">交易重放+管理漏洞—2000万枚OP被盗事件分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/526490325">2000万OP因何被盗? 来看看链上细节</a></li><li><a href="https://eips.ethereum.org/EIPS/eip-155">EIP-155: Simple replay attack protection</a></li><li><a href="https://learnblockchain.cn/article/1902">深入剖析 Ownbit 和 Gnosis 多签</a></li><li><a href="https://learnblockchain.cn/article/4077">多签钱包的工作原理与使用方式</a></li><li><a href="https://m.elecfans.com/article/1098135.html">CREATE2指令在广义状态通道中的应用介绍</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闪电贷攻击学习</title>
      <link href="/2022/06/09/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/09/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是闪电贷"><a href="#什么是闪电贷" class="headerlink" title="什么是闪电贷"></a>什么是闪电贷</h2><p>闪电贷最早是由 Marble 协议引入的概念，当时是为了让用户可以在以太坊借用 Ether 和 ERC-20 代币，后来由 Aave、dYdX 等进行了普及。</p><p>简单来说，闪电贷就是在一个区块交易中，同时完成借款和还款操作这两个操作，无需抵押任何资产，只需支付手续费即可。因为要求借款和还款操作都在一个区块中完成（以太坊平均每个区块时间大概是14秒，币安智能链每个区块时间大约3秒），所以时间非常短，普通人难以操作，一般是专业人员（科学家）使用。</p><p>用户在借到款之后，可以利用借到的资产进行其他操作，然后在交易结束的时候，用户只要把借到的款项及手续费及时归还就可以，否则该笔交易就会回滚，就像什么也没有发生过一样。</p><h2 id="闪电贷的作用"><a href="#闪电贷的作用" class="headerlink" title="闪电贷的作用"></a>闪电贷的作用</h2><p>闪电贷作用大致有以下：</p><ul><li>套利。比如在两个不同DEX（中心化交易平台）之间ETH价格是有差异的，在A平台 ETH: DAI&#x3D;1: 2700，在B平台上1：2750，那么，这个时候可以去AAVE里面借入2700DAI，在A平台买入1个ETH，在B平台以2750的价格卖出ETH，然后还掉2700DAI，净赚50DAI。</li><li>自我清算。比如你在去中心化平台抵押的一笔ETH即将到达清算点，在清算之后你要付一大笔清算费（一般是5-8%左右），这个时候你可以借一笔闪电贷，归还所贷资产，然后将平台抵押的ETH取出，用ETH换成相应的DAI或其他资产归还闪电贷，此时只需要付0.09%的闪电贷手续费而已（AAVE平台闪电贷手续费0.09%，每个平台手续费不一样）。</li><li>更换抵押物。比如你在借代平台上抵押的是ETH，你想把抵押物换成USDC，这个时候你可以用闪电贷借一笔DAI，用DAI换成USDC，然后抵押进去，随后将ETH取出，换成DAI，归还闪电贷所借DAI即可。</li><li>迁移资产或债务。比如我在A平台上面有抵押ETH借出BNB，这个时候我感觉A平台有一些风险，所以想把整个借代迁移到B平台上，我可以在AAVE用闪电贷借一笔DAI，把DAI换成BNB，在A平台归还之后取出ETH，然后将ETH抵押到B平台借出相同数量的BNB，然后将BNB换成DAI归还闪电贷，在不挪动原来借出来的BNB的基础上完成了不同平台资产和债务的转移。</li></ul><p>当然还存在更多的应用场景。</p><h2 id="闪电贷项目"><a href="#闪电贷项目" class="headerlink" title="闪电贷项目"></a>闪电贷项目</h2><p>主流的几个闪电贷项目，主要为Aave，Uniswap，dYdX。</p><ul><li><p>Aave。Aave 是一个去中心化的非托管流动性市场协议，用户可以作为存款人或借款人参与其中。存款人向市场提供流动性以赚取被动收入，而借款人能够以超额抵押（永久）或抵押不足（单块流动性）的方式借款。</p><p>其中Aave V3 为闪电贷提供了两种选择：</p><ul><li>flahsLoan。允许借款人在单次闪贷交易中获得多个准备金的流动性。</li><li>flahsLoanSimple。允许借款人为交易获取单一准备金的流动性。</li></ul></li></ul><p>​流程大概为实现 IFlashLoanSimpleReceiver.sol 或者 IFlashLoanReceiver.sol 中的 executeOperation 函数，该函数用来利用闪电贷，然后再调用flahsLoan函数或者 flahsLoanSimple 函数，传入相应的参数即可。executeOperation函数在flashLoan函数成功执行后被内部调用。其中Aave的手续费用为0.09%。</p><ul><li>Uniswap。Uniswap 作为 DeFi 中最受欢迎的去中心化交易所之一，从V2版本开始支持闪电贷（Flash Swaps）功能，该功能通过调用UniswapV2pair 合约实例的 swap 方法带入额外 data 实现。手续费为0.3%。</li><li>dYdX。dYdX 是一个针对专业交易者的去中心化交易所，本身并没有闪电贷功能，但是可以通过对 SoloMargin 合约执行一系列操作来实现类似闪电贷功能。其主要原理是通过继承 DydxFlashloanBase 合约编写initiateFlashLoan 回调 callFunction 实现借贷、套利、还款等操作。手续费 2 Wei。</li></ul><h2 id="闪电贷攻击"><a href="#闪电贷攻击" class="headerlink" title="闪电贷攻击"></a>闪电贷攻击</h2><p>闪电贷本身的存在是没有漏洞的，但闪电贷可以在短时间内获取到大量资金，黑客将闪电贷和其他漏洞进行结合，进行价格操控、套利。其中其他漏洞一般是合约逻辑存在问题导致黑客可以进行价格操控，或者是存在重入漏洞。以下是学习的闪电贷攻击实例。</p><h3 id="Grim-Finance-被黑事件"><a href="#Grim-Finance-被黑事件" class="headerlink" title="Grim Finance 被黑事件"></a>Grim Finance 被黑事件</h3><p>问题出在Grim Finance vault 的depositFor函数上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function depositFor(address token, uint _amount,address user ) public &#123;</span><br><span class="line"></span><br><span class="line">        uint256 _pool = balance();</span><br><span class="line">        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">        earn();</span><br><span class="line">        uint256 _after = balance();</span><br><span class="line">        _amount = _after.sub(_pool); // Additional check for deflationary tokens</span><br><span class="line">        uint256 shares = 0;</span><br><span class="line">        if (totalSupply() == 0) &#123;</span><br><span class="line">            shares = _amount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shares = (_amount.mul(totalSupply())).div(_pool);</span><br><span class="line">        &#125;</span><br><span class="line">        _mint(user, shares);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中由用户传入的token参数未做过滤，导致第四行调用的safeTransferFrom函数可被用户控制，攻击者传入自己的部署的恶意合约的地址，并在恶意合约的safeTransferFrom函数中调用depositFor，以此造成重入攻击。</p><p>其中在调用safeTransferFrom前计算了一次balance，在调用后又计算了一次balance，其差值amount为用户传入的代币数，那么攻击者只需要在最后一次重入的时候传入真实代币，当最后一次重入完成，after变成了充值后的余额，那么前面重入的amount也将改变，攻击者实现了充值一次当充值N次的目的。</p><p>大概的攻击合约伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    uint times = 0;</span><br><span class="line">    function safeTransferFrom(address token, uint _amount,address user) public &#123;</span><br><span class="line">        if(times &lt; 4)&#123;</span><br><span class="line">            times ++;</span><br><span class="line">            GrimBoostVault.depositFor(address(this), 0, attackaddress);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            GrimBoostVault.depositFor(SLPToken, 200, attackaddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wault-Finance-被黑事件"><a href="#Wault-Finance-被黑事件" class="headerlink" title="Wault Finance 被黑事件"></a>Wault Finance 被黑事件</h3><p>问题出在WUSDMaster合约中的staking函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function stake(uint256 amount) external nonReentrant &#123;</span><br><span class="line">        require(amount &lt;= maxStakeAmount, &#x27;amount too high&#x27;);</span><br><span class="line">        usdt.safeTransferFrom(msg.sender, address(this), amount);</span><br><span class="line">        if(feePermille &gt; 0) &#123;</span><br><span class="line">            uint256 feeAmount = amount * feePermille / 1000;</span><br><span class="line">            usdt.safeTransfer(treasury, feeAmount);</span><br><span class="line">            amount = amount - feeAmount;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 wexAmount = amount * wexPermille / 1000;</span><br><span class="line">        usdt.approve(address(wswapRouter), wexAmount);</span><br><span class="line">        wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            wexAmount,</span><br><span class="line">            0,</span><br><span class="line">            swapPath,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">        wusd.mint(msg.sender, amount);</span><br><span class="line">        </span><br><span class="line">        emit Stake(msg.sender, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该质押函数一比一质押USDT获得WUSD，同时还会进行swap操作，调用wswapRouter的swapExactTokensForTokensSupportingFeeOnTransferTokens，将质押一部分的 USDT 换成 WEX，这样就会使得 WaultSwapPair (BSC_USDT-WEX) 池子的 WEX 数量减少，价值变高，在多次调用stake函数后，WEX价格上涨，攻击者再将之前通过redeem和利用USDT兑换的WEX在USDT-WEX池中卖出，换取更多的WEX，完成套利。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>1、合理设计经济模型。</p><p>2、使用去中心化预言机获取价格。</p><p>3、对关键函数建立完备的访问控制机制。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://picture.iczhiku.com/weixin/message1623120320734.html">科普 | 无抵押借巨资的闪电贷是什么？缘何频频成为DeFi暴雷帮凶？</a></p></li><li><p><a href="https://www.sohu.com/a/489783580_100217347">揭开闪电贷的神秘面纱</a></p></li><li><p><a href="https://docs.aave.com/developers/guides/flash-loans">Flash Loans</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/s-1TCisIGfUIaVNNUgej0g">这波很 “严峻” – Grim Finance 被黑细节分析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/n_qF6BXp0tGriKz9WzlsvA">外部调用的不可控因素之 Grim Finance 被黑分析</a></p></li><li><p><a href="https://learnblockchain.cn/article/3311">又一经典的闪电贷套利 —— Wault.Finance 被黑事件分析</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
