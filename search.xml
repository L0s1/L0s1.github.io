<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OP代币被盗事件学习</title>
      <link href="/2022/06/13/OP%E4%BB%A3%E5%B8%81%E8%A2%AB%E7%9B%97%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/13/OP%E4%BB%A3%E5%B8%81%E8%A2%AB%E7%9B%97%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>2022年6月9日，Optimism 和加密货币做市商  Wintermute 发布公告，2000万个 OP 代币被黑客盗取。OP 向 Wintermute 提供了2000万代币，委托其提供流动性服务，OP 在向 Wintermute 发送了1 OP 代币和100万 OP 两笔交且 Wintermute 确认无误后，又向其发送了1900万 OP 代币。但在发送完 OP代币后，Wintermute 发现其无法控制这些代币。因为其多签钱包只部署在以太坊主网上，未在 Optimism 网络部署，黑客通过抢先将该多签地址部署在 Optimism 网络上，成功控制代币。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="多签钱包"><a href="#多签钱包" class="headerlink" title="多签钱包"></a>多签钱包</h3><p>往区块链上发送一笔交易，需要使用钱包做一个签名，签名好后将交易发送出去，交易执行成功转装就成功，这是单签钱包。而多签钱包则是需要多个人去签名执行操作的钱包，使用时需要多个人签名发送交易后，转账操作才完成。多签钱包可以使用 m&#x2F;n 的模式，即 n 个人里有 m 个人签名即可完成操作。</p><p>常说的多签主要针对的是比特币和以太坊 ERC-20 标准代币。在比特币中有2种类型的地址，1开头的是 P2PKH，表示个人地址，3开头的是 P2SH，一般表示多签地址。普通的比特币地址是由公钥做哈希后得到的，而多重签名地址基于脚本哈希，所以能够实现复杂的交易逻辑，在原生上比特币就支持多签。而以太坊原生并不支持多签地址，多签钱包在以太坊中往往是一个智能合约。Ownbit 和 Gnosis 代表了当前主流的两种以太坊多签实现方式。其中 Wintermute 使用的 Gnosis 多签钱包。</p><h3 id="EIP155-标准"><a href="#EIP155-标准" class="headerlink" title="EIP155 标准"></a>EIP155 标准</h3><p>EIP155 标准用于防范重放攻击。</p><p>当区块高度大于 FORK_BLKNUM (2,675,000) 且 CHAIN_ID 可用时，在计算交易的哈希以进行签名时，不只是对六个 rlp 编码元素（nonce, gasprice, startgas, to, value, data）进行哈希处理，应对9个 rlp 编码元素（nonce, gasprice, startgas, to, value, data, chainid, 0, 0）进行哈希处理，所以签名后的 v 值为：{0,1} + CHAIN_ID * 2 + 35，而如果只对6个元素进行哈希处理，则签名后的 v 值为：{0,1} + 27。</p><p>当区块高度大于 FORK_BLKNUM (2,675,000) 且 v 值等于 CHAIN_ID * 2 + 35 或者 CHAIN_ID * 2 + 36 时，在计算交易的哈希以进行签名时，不只是对六个 rlp 编码元素进行哈希处理，应对9个 rlp 编码元素（nonce, gasprice, startgas, to, value, data, chainid, 0, 0）进行哈希处理。当前存在的使用 v 值等于27或者28签名方案保持有效，并继续在与以前相同的规则下运行。</p><p>简单点说的就是不加 CHAIN_ID 的签名后的 v 值在27-28之间，交易可以在不同的链上进行重放。</p><h3 id="合约地址生成方式"><a href="#合约地址生成方式" class="headerlink" title="合约地址生成方式"></a>合约地址生成方式</h3><p>智能合约生成合约地址有两种方式，分别是 CREATE 指令和 CREATE2 指令，其中使用 CREATE 指令创建的合约地址可以使用<code>keccak256(rlp.encode(deployingAddress, nonce))[12:]</code>计算出来，其中 nonce的值每发送一笔交易或者创建一个合约就会 +1。</p><p>使用 CREATE2 指令创建的合约的地址使用<code>keccak256(0xff ++ deployingAddr ++ salt ++ keccak256(init_code))[12:]</code>计算，其中 init_code 是被部署合约的字节码。</p><h2 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h2><p>首先是 Optimism 向 Wintermute 的多签钱包地址发送 OP 代币：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140044997.png" alt="image-20220614004415931"></p><p>由于此时 Wintermute 的多签钱包只在以太坊主网上部署，未在 Optimism 网络上部署，因此其对2000万 OP 代币无控制权。</p><p>黑客此时抢先将该多签钱包地址部署到 Optimism 网络上。</p><p>黑客攻击地址为：0x60b28637879b5a09d21b68040020ffbf7dba5107</p><p>其首先分别向两个地址 0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A、0x8BcFe4f1358E50A1db10025D731C8b3b17f04DBB转账0.2 eth、0.5 eth：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140140373.png" alt="image-20220614014044339"></p><p>其中 0x1aa7451DD11b8cb16AC089ED7fE05eFa00100A6A 用来部署 Gnosis Safe 的 ProxyFactory 合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140141258.png" alt="image-20220614014131219"></p><p>0x8BcFe4f1358E50A1db10025D731C8b3b17f04DBB 则用来部署 0xe7145dd6287ae53326347f3a6694fcf2954bcd8a 合约，该合约用于多次调用 ProxyFactory 中的 <code>createProxy</code>函数：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140142685.png" alt="image-20220614014259649"></p><p>由于生成多签钱包地址的是 Gnosis Safe 的 ProxyFactory 合约，因此找到创建该合约的记录。</p><p>首先在 etherscan 搜索多签钱包地址0x4f3a120e72c76c22ae802d129f599bfdbc31cb81，然后找到其创建的记录：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140101334.png" alt="image-20220614010145311"></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140102673.png" alt="image-20220614010256645"></p><p>然后找到 Gnosis Safe 的 ProxyFactory 合约的创建记录：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140104688.png" alt="image-20220614010403652"></p><p>然后查看此时 v 值，不知道在 etherscan 如何查看，学习慢雾的方法，注册了一个 infura.io 账号，使用该命令查看详情：<code>curl -s -H &#39;content-type:application/json&#39; -d &#39;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getTransactionByHash&quot;,&quot;params&quot;:[&quot;0x75a42f240d229518979199f56cd7c82e4fc1f1a20ad9a4864c635354b4a34261&quot;],&quot;id&quot;:1&#125;&#39; https://mainnet.infura.io/v3/xxxx</code></p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140106354.png" alt="image-20220614010649319"></p><p>可以看到此时的 v 值为 0x1c，换算为十进制为28，因此该 v 值不符合 EIP155标准，不带 CHAIN_ID，可以在其他链进行重放攻击，以得到相同地址的合约，攻击者在 Optimism 网络重放，得到地址与在以太坊主网相同的 ProxyFactory 合约：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140113772.png" alt="image-20220614011343743"></p><p>然后再看  Gnosis Safe 的 ProxyFactory 合约的源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contract ProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    event ProxyCreation(Proxy proxy);</span><br><span class="line"></span><br><span class="line">    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.</span><br><span class="line">    /// @param masterCopy Address of master copy.</span><br><span class="line">    /// @param data Payload for message call sent to new proxy contract.</span><br><span class="line">    function createProxy(address masterCopy, bytes memory data)</span><br><span class="line">        public</span><br><span class="line">        returns (Proxy proxy)</span><br><span class="line">    &#123;</span><br><span class="line">        proxy = new Proxy(masterCopy);</span><br><span class="line">        if (data.length &gt; 0)</span><br><span class="line">            // solium-disable-next-line security/no-inline-assembly</span><br><span class="line">            assembly &#123;</span><br><span class="line">                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) &#123; revert(0, 0) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        emit ProxyCreation(proxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //省略其他代码 N 行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到新建合约地址使用的<code>new Proxy(masterCopy)</code>，即使用的 CREATE 指令进行创建，合约地址是 msg.sender 以及 nonce 来计算的，由于此时工厂合约地址已经和以太坊主网相同，只需要 nonce 和在以太坊主网上生成多签钱包地址的 nonce 相同，则可完成部署，攻击者通过调用合约 0xe7145dd6287ae53326347f3a6694fcf2954bcd8a 来实现，该合约内部则多次调用 ProxyFactory 合约的<code>createProxy</code>函数，来增加 nonce 值达到该目的：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140130665.png" alt="image-20220614013033627"></p><p>最后成功将该多签钱包地址部署在 Optimism网络：</p><p><img src="https://niansblog.oss-cn-shanghai.aliyuncs.com/img/202206140132168.png" alt="image-20220614013208126"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>引发此次安全事件的原因：一是 Wintermute 未验证在侧链是否对其多签钱包地址具有控制权；二是 Solidity 旧版本的漏洞导致使用 CREATE 指令来创建合约地址；三是交易签名未带 CHAIN_ID，不符合 EIP155 标准导致交易可在其他链重放。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/MjvCChjEGuSTr9cELQlW_A">2000 万 OP 代币被盗关键：交易重放</a></li><li><a href="https://www.finacerun.com/index.php/home/news/detail/article_id/98429.html">重入攻击 + 管理漏洞：2000 万枚 OP 被盗事件分析</a></li><li><a href="http://www.hackdig.com/06/hack-684523.htm">交易重放+管理漏洞—2000万枚OP被盗事件分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/526490325">2000万OP因何被盗? 来看看链上细节</a></li><li><a href="https://eips.ethereum.org/EIPS/eip-155">EIP-155: Simple replay attack protection</a></li><li><a href="https://learnblockchain.cn/article/1902">深入剖析 Ownbit 和 Gnosis 多签</a></li><li><a href="https://learnblockchain.cn/article/4077">多签钱包的工作原理与使用方式</a></li><li><a href="https://m.elecfans.com/article/1098135.html">CREATE2指令在广义状态通道中的应用介绍</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全事件学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闪电贷攻击学习</title>
      <link href="/2022/06/09/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/09/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是闪电贷"><a href="#什么是闪电贷" class="headerlink" title="什么是闪电贷"></a>什么是闪电贷</h2><p>闪电贷最早是由 Marble 协议引入的概念，当时是为了让用户可以在以太坊借用 Ether 和 ERC-20 代币，后来由 Aave、dYdX 等进行了普及。</p><p>简单来说，闪电贷就是在一个区块交易中，同时完成借款和还款操作这两个操作，无需抵押任何资产，只需支付手续费即可。因为要求借款和还款操作都在一个区块中完成（以太坊平均每个区块时间大概是14秒，币安智能链每个区块时间大约3秒），所以时间非常短，普通人难以操作，一般是专业人员（科学家）使用。</p><p>用户在借到款之后，可以利用借到的资产进行其他操作，然后在交易结束的时候，用户只要把借到的款项及手续费及时归还就可以，否则该笔交易就会回滚，就像什么也没有发生过一样。</p><h2 id="闪电贷的作用"><a href="#闪电贷的作用" class="headerlink" title="闪电贷的作用"></a>闪电贷的作用</h2><p>闪电贷作用大致有以下：</p><ul><li>套利。比如在两个不同DEX（中心化交易平台）之间ETH价格是有差异的，在A平台 ETH: DAI&#x3D;1: 2700，在B平台上1：2750，那么，这个时候可以去AAVE里面借入2700DAI，在A平台买入1个ETH，在B平台以2750的价格卖出ETH，然后还掉2700DAI，净赚50DAI。</li><li>自我清算。比如你在去中心化平台抵押的一笔ETH即将到达清算点，在清算之后你要付一大笔清算费（一般是5-8%左右），这个时候你可以借一笔闪电贷，归还所贷资产，然后将平台抵押的ETH取出，用ETH换成相应的DAI或其他资产归还闪电贷，此时只需要付0.09%的闪电贷手续费而已（AAVE平台闪电贷手续费0.09%，每个平台手续费不一样）。</li><li>更换抵押物。比如你在借代平台上抵押的是ETH，你想把抵押物换成USDC，这个时候你可以用闪电贷借一笔DAI，用DAI换成USDC，然后抵押进去，随后将ETH取出，换成DAI，归还闪电贷所借DAI即可。</li><li>迁移资产或债务。比如我在A平台上面有抵押ETH借出BNB，这个时候我感觉A平台有一些风险，所以想把整个借代迁移到B平台上，我可以在AAVE用闪电贷借一笔DAI，把DAI换成BNB，在A平台归还之后取出ETH，然后将ETH抵押到B平台借出相同数量的BNB，然后将BNB换成DAI归还闪电贷，在不挪动原来借出来的BNB的基础上完成了不同平台资产和债务的转移。</li></ul><p>当然还存在更多的应用场景。</p><h2 id="闪电贷项目"><a href="#闪电贷项目" class="headerlink" title="闪电贷项目"></a>闪电贷项目</h2><p>主流的几个闪电贷项目，主要为Aave，Uniswap，dYdX。</p><ul><li><p>Aave。Aave 是一个去中心化的非托管流动性市场协议，用户可以作为存款人或借款人参与其中。存款人向市场提供流动性以赚取被动收入，而借款人能够以超额抵押（永久）或抵押不足（单块流动性）的方式借款。</p><p>其中Aave V3 为闪电贷提供了两种选择：</p><ul><li>flahsLoan。允许借款人在单次闪贷交易中获得多个准备金的流动性。</li><li>flahsLoanSimple。允许借款人为交易获取单一准备金的流动性。</li></ul></li></ul><p>​流程大概为实现 IFlashLoanSimpleReceiver.sol 或者 IFlashLoanReceiver.sol 中的 executeOperation 函数，该函数用来利用闪电贷，然后再调用flahsLoan函数或者 flahsLoanSimple 函数，传入相应的参数即可。executeOperation函数在flashLoan函数成功执行后被内部调用。其中Aave的手续费用为0.09%。</p><ul><li>Uniswap。Uniswap 作为 DeFi 中最受欢迎的去中心化交易所之一，从V2版本开始支持闪电贷（Flash Swaps）功能，该功能通过调用UniswapV2pair 合约实例的 swap 方法带入额外 data 实现。手续费为0.3%。</li><li>dYdX。dYdX 是一个针对专业交易者的去中心化交易所，本身并没有闪电贷功能，但是可以通过对 SoloMargin 合约执行一系列操作来实现类似闪电贷功能。其主要原理是通过继承 DydxFlashloanBase 合约编写initiateFlashLoan 回调 callFunction 实现借贷、套利、还款等操作。手续费 2 Wei。</li></ul><h2 id="闪电贷攻击"><a href="#闪电贷攻击" class="headerlink" title="闪电贷攻击"></a>闪电贷攻击</h2><p>闪电贷本身的存在是没有漏洞的，但闪电贷可以在短时间内获取到大量资金，黑客将闪电贷和其他漏洞进行结合，进行价格操控、套利。其中其他漏洞一般是合约逻辑存在问题导致黑客可以进行价格操控，或者是存在重入漏洞。以下是学习的闪电贷攻击实例。</p><h3 id="Grim-Finance-被黑事件"><a href="#Grim-Finance-被黑事件" class="headerlink" title="Grim Finance 被黑事件"></a>Grim Finance 被黑事件</h3><p>问题出在Grim Finance vault 的depositFor函数上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function depositFor(address token, uint _amount,address user ) public &#123;</span><br><span class="line"></span><br><span class="line">        uint256 _pool = balance();</span><br><span class="line">        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">        earn();</span><br><span class="line">        uint256 _after = balance();</span><br><span class="line">        _amount = _after.sub(_pool); // Additional check for deflationary tokens</span><br><span class="line">        uint256 shares = 0;</span><br><span class="line">        if (totalSupply() == 0) &#123;</span><br><span class="line">            shares = _amount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shares = (_amount.mul(totalSupply())).div(_pool);</span><br><span class="line">        &#125;</span><br><span class="line">        _mint(user, shares);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中由用户传入的token参数未做过滤，导致第四行调用的safeTransferFrom函数可被用户控制，攻击者传入自己的部署的恶意合约的地址，并在恶意合约的safeTransferFrom函数中调用depositFor，以此造成重入攻击。</p><p>其中在调用safeTransferFrom前计算了一次balance，在调用后又计算了一次balance，其差值amount为用户传入的代币数，那么攻击者只需要在最后一次重入的时候传入真实代币，当最后一次重入完成，after变成了充值后的余额，那么前面重入的amount也将改变，攻击者实现了充值一次当充值N次的目的。</p><p>大概的攻击合约伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    uint times = 0;</span><br><span class="line">    function safeTransferFrom(address token, uint _amount,address user) public &#123;</span><br><span class="line">        if(times &lt; 4)&#123;</span><br><span class="line">            times ++;</span><br><span class="line">            GrimBoostVault.depositFor(address(this), 0, attackaddress);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            GrimBoostVault.depositFor(SLPToken, 200, attackaddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wault-Finance-被黑事件"><a href="#Wault-Finance-被黑事件" class="headerlink" title="Wault Finance 被黑事件"></a>Wault Finance 被黑事件</h3><p>问题出在WUSDMaster合约中的staking函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function stake(uint256 amount) external nonReentrant &#123;</span><br><span class="line">        require(amount &lt;= maxStakeAmount, &#x27;amount too high&#x27;);</span><br><span class="line">        usdt.safeTransferFrom(msg.sender, address(this), amount);</span><br><span class="line">        if(feePermille &gt; 0) &#123;</span><br><span class="line">            uint256 feeAmount = amount * feePermille / 1000;</span><br><span class="line">            usdt.safeTransfer(treasury, feeAmount);</span><br><span class="line">            amount = amount - feeAmount;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 wexAmount = amount * wexPermille / 1000;</span><br><span class="line">        usdt.approve(address(wswapRouter), wexAmount);</span><br><span class="line">        wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            wexAmount,</span><br><span class="line">            0,</span><br><span class="line">            swapPath,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">        wusd.mint(msg.sender, amount);</span><br><span class="line">        </span><br><span class="line">        emit Stake(msg.sender, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该质押函数一比一质押USDT获得WUSD，同时还会进行swap操作，调用wswapRouter的swapExactTokensForTokensSupportingFeeOnTransferTokens，将质押一部分的 USDT 换成 WEX，这样就会使得 WaultSwapPair (BSC_USDT-WEX) 池子的 WEX 数量减少，价值变高，在多次调用stake函数后，WEX价格上涨，攻击者再将之前通过redeem和利用USDT兑换的WEX在USDT-WEX池中卖出，换取更多的WEX，完成套利。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>1、合理设计经济模型。</p><p>2、使用去中心化预言机获取价格。</p><p>3、对关键函数建立完备的访问控制机制。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://picture.iczhiku.com/weixin/message1623120320734.html">科普 | 无抵押借巨资的闪电贷是什么？缘何频频成为DeFi暴雷帮凶？</a></p></li><li><p><a href="https://www.sohu.com/a/489783580_100217347">揭开闪电贷的神秘面纱</a></p></li><li><p><a href="https://docs.aave.com/developers/guides/flash-loans">Flash Loans</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/s-1TCisIGfUIaVNNUgej0g">这波很 “严峻” – Grim Finance 被黑细节分析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/n_qF6BXp0tGriKz9WzlsvA">外部调用的不可控因素之 Grim Finance 被黑分析</a></p></li><li><p><a href="https://learnblockchain.cn/article/3311">又一经典的闪电贷套利 —— Wault.Finance 被黑事件分析</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闪电贷 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
