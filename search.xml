<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>闪电贷攻击学习</title>
      <link href="/2022/06/09/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/09/%E9%97%AA%E7%94%B5%E8%B4%B7%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是闪电贷"><a href="#什么是闪电贷" class="headerlink" title="什么是闪电贷"></a>什么是闪电贷</h2><p>闪电贷最早是由 Marble 协议引入的概念，当时是为了让用户可以在以太坊借用 Ether 和 ERC-20 代币，后来由 Aave、dYdX 等进行了普及。</p><p>简单来说，闪电贷就是在一个区块交易中，同时完成借款和还款操作这两个操作，无需抵押任何资产，只需支付手续费即可。因为要求借款和还款操作都在一个区块中完成（以太坊平均每个区块时间大概是14秒，币安智能链每个区块时间大约3秒），所以时间非常短，普通人难以操作，一般是专业人员（科学家）使用。</p><p>用户在借到款之后，可以利用借到的资产进行其他操作，然后在交易结束的时候，用户只要把借到的款项及手续费及时归还就可以，否则该笔交易就会回滚，就像什么也没有发生过一样。</p><h2 id="闪电贷的作用"><a href="#闪电贷的作用" class="headerlink" title="闪电贷的作用"></a>闪电贷的作用</h2><p>闪电贷作用大致有以下：</p><ul><li>套利。比如在两个不同DEX（中心化交易平台）之间ETH价格是有差异的，在A平台 ETH: DAI&#x3D;1: 2700，在B平台上1：2750，那么，这个时候可以去AAVE里面借入2700DAI，在A平台买入1个ETH，在B平台以2750的价格卖出ETH，然后还掉2700DAI，净赚50DAI。</li><li>自我清算。比如你在去中心化平台抵押的一笔ETH即将到达清算点，在清算之后你要付一大笔清算费（一般是5-8%左右），这个时候你可以借一笔闪电贷，归还所贷资产，然后将平台抵押的ETH取出，用ETH换成相应的DAI或其他资产归还闪电贷，此时只需要付0.09%的闪电贷手续费而已（AAVE平台闪电贷手续费0.09%，每个平台手续费不一样）。</li><li>更换抵押物。比如你在借代平台上抵押的是ETH，你想把抵押物换成USDC，这个时候你可以用闪电贷借一笔DAI，用DAI换成USDC，然后抵押进去，随后将ETH取出，换成DAI，归还闪电贷所借DAI即可。</li><li>迁移资产或债务。比如我在A平台上面有抵押ETH借出BNB，这个时候我感觉A平台有一些风险，所以想把整个借代迁移到B平台上，我可以在AAVE用闪电贷借一笔DAI，把DAI换成BNB，在A平台归还之后取出ETH，然后将ETH抵押到B平台借出相同数量的BNB，然后将BNB换成DAI归还闪电贷，在不挪动原来借出来的BNB的基础上完成了不同平台资产和债务的转移。</li></ul><p>当然还存在更多的应用场景。</p><h2 id="闪电贷项目"><a href="#闪电贷项目" class="headerlink" title="闪电贷项目"></a>闪电贷项目</h2><p>主流的几个闪电贷项目，主要为Aave，Uniswap，dYdX。</p><ul><li><p>Aave。Aave 是一个去中心化的非托管流动性市场协议，用户可以作为存款人或借款人参与其中。存款人向市场提供流动性以赚取被动收入，而借款人能够以超额抵押（永久）或抵押不足（单块流动性）的方式借款。</p><p>其中Aave V3 为闪电贷提供了两种选择：</p><ul><li>flahsLoan。允许借款人在单次闪贷交易中获得多个准备金的流动性。</li><li>flahsLoanSimple。允许借款人为交易获取单一准备金的流动性。</li></ul></li></ul><p>​流程大概为实现 IFlashLoanSimpleReceiver.sol 或者 IFlashLoanReceiver.sol 中的 executeOperation 函数，该函数用来利用闪电贷，然后再调用flahsLoan函数或者 flahsLoanSimple 函数，传入相应的参数即可。executeOperation函数在flashLoan函数成功执行后被内部调用。其中Aave的手续费用为0.09%。</p><ul><li>Uniswap。Uniswap 作为 DeFi 中最受欢迎的去中心化交易所之一，从V2版本开始支持闪电贷（Flash Swaps）功能，该功能通过调用UniswapV2pair 合约实例的 swap 方法带入额外 data 实现。手续费为0.3%。</li><li>dYdX。dYdX 是一个针对专业交易者的去中心化交易所，本身并没有闪电贷功能，但是可以通过对 SoloMargin 合约执行一系列操作来实现类似闪电贷功能。其主要原理是通过继承 DydxFlashloanBase 合约编写initiateFlashLoan 回调 callFunction 实现借贷、套利、还款等操作。手续费 2 Wei。</li></ul><h2 id="闪电贷攻击"><a href="#闪电贷攻击" class="headerlink" title="闪电贷攻击"></a>闪电贷攻击</h2><p>闪电贷本身的存在是没有漏洞的，但闪电贷可以在短时间内获取到大量资金，黑客将闪电贷和其他漏洞进行结合，进行价格操控、套利。其中其他漏洞一般是合约逻辑存在问题导致黑客可以进行价格操控，或者是存在重入漏洞。以下是学习的闪电贷攻击实例。</p><h3 id="Grim-Finance-被黑事件"><a href="#Grim-Finance-被黑事件" class="headerlink" title="Grim Finance 被黑事件"></a>Grim Finance 被黑事件</h3><p>问题出在Grim Finance vault 的depositFor函数上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function depositFor(address token, uint _amount,address user ) public &#123;</span><br><span class="line"></span><br><span class="line">        uint256 _pool = balance();</span><br><span class="line">        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">        earn();</span><br><span class="line">        uint256 _after = balance();</span><br><span class="line">        _amount = _after.sub(_pool); // Additional check for deflationary tokens</span><br><span class="line">        uint256 shares = 0;</span><br><span class="line">        if (totalSupply() == 0) &#123;</span><br><span class="line">            shares = _amount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shares = (_amount.mul(totalSupply())).div(_pool);</span><br><span class="line">        &#125;</span><br><span class="line">        _mint(user, shares);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中由用户传入的token参数未做过滤，导致第四行调用的safeTransferFrom函数可被用户控制，攻击者传入自己的部署的恶意合约的地址，并在恶意合约的safeTransferFrom函数中调用depositFor，以此造成重入攻击。</p><p>其中在调用safeTransferFrom前计算了一次balance，在调用后又计算了一次balance，其差值amount为用户传入的代币数，那么攻击者只需要在最后一次重入的时候传入真实代币，当最后一次重入完成，after变成了充值后的余额，那么前面重入的amount也将改变，攻击者实现了充值一次当充值N次的目的。</p><p>大概的攻击合约伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    uint times = 0;</span><br><span class="line">    function safeTransferFrom(address token, uint _amount,address user) public &#123;</span><br><span class="line">        if(times &lt; 4)&#123;</span><br><span class="line">            times ++;</span><br><span class="line">            GrimBoostVault.depositFor(address(this), 0, attackaddress);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            GrimBoostVault.depositFor(SLPToken, 200, attackaddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wault-Finance-被黑事件"><a href="#Wault-Finance-被黑事件" class="headerlink" title="Wault Finance 被黑事件"></a>Wault Finance 被黑事件</h3><p>问题出在WUSDMaster合约中的staking函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function stake(uint256 amount) external nonReentrant &#123;</span><br><span class="line">        require(amount &lt;= maxStakeAmount, &#x27;amount too high&#x27;);</span><br><span class="line">        usdt.safeTransferFrom(msg.sender, address(this), amount);</span><br><span class="line">        if(feePermille &gt; 0) &#123;</span><br><span class="line">            uint256 feeAmount = amount * feePermille / 1000;</span><br><span class="line">            usdt.safeTransfer(treasury, feeAmount);</span><br><span class="line">            amount = amount - feeAmount;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 wexAmount = amount * wexPermille / 1000;</span><br><span class="line">        usdt.approve(address(wswapRouter), wexAmount);</span><br><span class="line">        wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">            wexAmount,</span><br><span class="line">            0,</span><br><span class="line">            swapPath,</span><br><span class="line">            address(this),</span><br><span class="line">            block.timestamp</span><br><span class="line">        );</span><br><span class="line">        wusd.mint(msg.sender, amount);</span><br><span class="line">        </span><br><span class="line">        emit Stake(msg.sender, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该质押函数一比一质押USDT获得WUSD，同时还会进行swap操作，调用wswapRouter的swapExactTokensForTokensSupportingFeeOnTransferTokens，将质押一部分的 USDT 换成 WEX，这样就会使得 WaultSwapPair (BSC_USDT-WEX) 池子的 WEX 数量减少，价值变高，在多次调用stake函数后，WEX价格上涨，攻击者再将之前通过redeem和利用USDT兑换的WEX在USDT-WEX池中卖出，换取更多的WEX，完成套利。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>1、合理设计经济模型。</p><p>2、使用去中心化预言机获取价格。</p><p>3、对关键函数建立完备的访问控制机制。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://picture.iczhiku.com/weixin/message1623120320734.html">科普 | 无抵押借巨资的闪电贷是什么？缘何频频成为DeFi暴雷帮凶？</a></p></li><li><p><a href="https://www.sohu.com/a/489783580_100217347">揭开闪电贷的神秘面纱</a></p></li><li><p><a href="https://docs.aave.com/developers/guides/flash-loans">Flash Loans</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/s-1TCisIGfUIaVNNUgej0g">这波很 “严峻” – Grim Finance 被黑细节分析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/n_qF6BXp0tGriKz9WzlsvA">外部调用的不可控因素之 Grim Finance 被黑分析</a></p></li><li><p><a href="https://learnblockchain.cn/article/3311">又一经典的闪电贷套利 —— Wault.Finance 被黑事件分析</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闪电贷 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
